<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador IFC 3D - ProCalculo | Eng. Pedro Leite</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#007AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Proteção contra cópia -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">

    <style>
        /* ==========================================
           PROTEÇÃO CONTRA SELEÇÃO E CÓPIA
           ========================================== */
        html, body {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        
        /* Permitir seleção apenas em inputs e textareas */
        input, textarea, [contenteditable="true"] {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* ==========================================
           LAYOUT RESET & BASE
           ========================================== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            background-color: #f5f5f7;
        }

        /* ==========================================
           SIDEBAR STYLING
           ========================================== */
        #sidebar {
            width: 320px;
            background: #ffffff;
            border-left: 1px solid #e1e1e1;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .header {
            padding: 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
        }

        h2 {
            margin: 0;
            font-size: 1.1rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .subtitle {
            font-size: 0.8rem;
            color: #666;
            margin-top: 4px;
        }

        /* Tabs de navegação */
        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid #eee;
            background: #f8f9fa;
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.75rem;
            color: #666;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .sidebar-tab:hover {
            background: #e9ecef;
        }

        .sidebar-tab.active {
            background: white;
            color: #007AFF;
            border-bottom: 2px solid #007AFF;
            margin-bottom: -1px;
        }

        .sidebar-tab-icon {
            font-size: 1.2rem;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        #properties-container {
            padding: 15px;
        }

        /* ==========================================
           BUTTONS & CONTROLS
           ========================================== */
        .btn-action {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.85rem;
        }
        
        .btn-mini {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s;
        }
        
        .btn-mini:hover {
            background: #e0e0e0;
        }

        .btn-hide {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        .btn-hide:hover {
            background: #ffcdd2;
        }

        .btn-secondary {
            background: #f0f2f5;
            color: #444;
            border: 1px solid #dcdfe6;
        }

        .btn-secondary:hover {
            background: #e4e7ed;
        }

        .btn-primary {
            background: #007AFF;
            color: white;
            border: none;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-success {
            background: #28a745;
            color: white;
            border: none;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-sm {
            padding: 6px 10px;
            font-size: 0.75rem;
            margin-bottom: 5px;
        }

        /* ==========================================
           PROPERTY LIST STYLING
           ========================================== */
        .prop-group {
            margin-bottom: 12px;
            border: 1px solid #eee;
            border-radius: 6px;
            overflow: hidden;
        }

        .prop-header {
            background: #f8f9fa;
            padding: 8px 12px;
            font-weight: 600;
            font-size: 0.8rem;
            color: #555;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .prop-header:hover {
            background: #e9ecef;
        }

        .prop-row {
            display: flex;
            padding: 8px 12px;
            border-bottom: 1px solid #f5f5f5;
            font-size: 0.8rem;
        }

        .prop-row:last-child {
            border-bottom: none;
        }

        .prop-label {
            width: 40%;
            color: #666;
            font-weight: 500;
        }

        .prop-value {
            width: 60%;
            color: #333;
            word-break: break-word;
            font-weight: 600;
        }

        /* ==========================================
           QUANTITATIVOS PANEL
           ========================================== */
        .qty-panel {
            padding: 15px;
        }

        .qty-total-card {
            background: linear-gradient(135deg, #007AFF 0%, #00c6ff 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
        }

        .qty-total-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .qty-total-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 5px 0;
        }

        .qty-total-unit {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .qty-section {
            margin-bottom: 10px;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow: hidden;
        }

        .qty-section-header {
            background: #f8f9fa;
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .qty-section-header:hover {
            background: #e9ecef;
        }

        .qty-section-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .qty-section-badge {
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: #666;
        }

        .qty-section-content {
            padding: 10px 12px;
            display: none;
            border-top: 1px solid #eee;
        }

        .qty-section-content.open {
            display: block;
        }

        .qty-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.8rem;
        }

        .qty-row-label {
            color: #666;
        }

        .qty-row-value {
            font-weight: 600;
            color: #333;
        }

        /* ==========================================
           FILTROS PANEL
           ========================================== */
        .filter-panel {
            padding: 15px;
        }

        .filter-section {
            margin-bottom: 15px;
        }

        .filter-label {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 6px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .search-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #007AFF;
        }

        .filter-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .filter-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 5px 10px;
            background: #f0f2f5;
            border: 1px solid #ddd;
            border-radius: 15px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-chip:hover {
            background: #e4e7ed;
        }

        .filter-chip.active {
            background: #e3f2fd;
            border-color: #007AFF;
            color: #007AFF;
        }

        .filter-select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
        }

        /* Search Results */
        .search-results {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 6px;
            margin-top: 10px;
        }

        .search-result-item {
            padding: 10px 12px;
            border-bottom: 1px solid #f5f5f5;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-name {
            font-weight: 500;
            font-size: 0.85rem;
            color: #333;
        }

        .search-result-type {
            font-size: 0.75rem;
            color: #666;
            margin-top: 2px;
        }

        /* ==========================================
           INSTRUCTIONS & FOOTER
           ========================================== */
        .instructions {
            padding: 12px;
            background: #fff8e1;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #666;
            border: 1px solid #ffe0b2;
            margin: 15px;
        }

        .key {
            display: inline-block;
            padding: 2px 6px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 5px;
            font-size: 0.7rem;
            font-weight: bold;
            color: #555;
        }

        /* ==========================================
           TOOLBAR & LOADING
           ========================================== */
        /* ==========================================
           TOOLBAR VERTICAL - LADO ESQUERDO
           ========================================== */
        #toolbar {
            position: absolute;
            top: 50%;
            left: 12px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 10px 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
        }
        
        .toolbar-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 4px 0;
        }
        
        .toolbar-group:not(:last-child) {
            border-bottom: 1px solid #e5e5e5;
            padding-bottom: 8px;
            margin-bottom: 4px;
        }
        
        .toolbar-group-label {
            font-size: 0.6rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .tool-btn {
            position: relative;
            background: transparent;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.25rem;
            color: #555;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tool-btn .btn-label {
            display: none;
        }

        .tool-btn:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }
        
        .tool-btn:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 52px;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            animation: tooltipFade 0.2s ease;
        }
        
        .tool-btn:hover::before {
            content: '';
            position: absolute;
            left: 46px;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: #333;
            z-index: 1000;
        }
        
        @keyframes tooltipFade {
            from { opacity: 0; transform: translateY(-50%) translateX(-5px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            color: #1565c0;
            box-shadow: inset 0 0 0 2px #2196f3;
        }
        
        .tool-btn.accent {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            color: #e65100;
        }
        
        .tool-btn.accent:hover {
            background: linear-gradient(135deg, #ffe0b2, #ffcc80);
        }
        
        .tool-btn.danger {
            color: #d32f2f;
        }
        
        .tool-btn.danger:hover {
            background: #ffebee;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #loading-text {
            margin-top: 15px;
            font-size: 1rem;
            color: #666;
        }

        #loading-progress {
            width: 200px;
            height: 4px;
            background: #eee;
            border-radius: 2px;
            margin-top: 15px;
            overflow: hidden;
        }

        #loading-progress-bar {
            width: 0%;
            height: 100%;
            background: #007AFF;
            transition: width 0.3s;
        }

        /* ==========================================
           VIEWCUBE & OVERLAYS
           ========================================== */
        #viewcube-container {
            position: absolute;
            top: 15px;
            right: 340px;
            width: 120px;
            height: 120px;
            z-index: 90;
            pointer-events: none;
        }

        #viewcube-canvas {
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: pointer;
        }

        /* Company Logo */
        #company-logo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            height: 110px;
            width: auto;
            max-width: 440px;
            z-index: 90;
            pointer-events: none;
            opacity: 0.85;
            transition: opacity 0.3s;
        }
        
        #company-logo img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }
        
        #company-logo:hover {
            opacity: 1;
        }

        /* ==========================================
           INFO PANEL (Bottom Right)
           ========================================== */
        #info-panel {
            position: absolute;
            bottom: 15px;
            right: 340px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 90;
            font-size: 0.8rem;
            display: none;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 3px;
        }

        .info-label {
            color: #666;
        }

        .info-value {
            font-weight: 600;
            color: #007AFF;
        }

        /* ==========================================
           PLAN VIEW CONTAINER
           ========================================== */
        #plan-view-container {
            display: none;
            position: absolute;
            bottom: 15px;
            right: 340px;
            width: 450px;
            height: 450px;
            min-width: 300px;
            min-height: 300px;
            max-width: 90vw;
            max-height: 90vh;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 100;
            resize: both;
            overflow: hidden;
        }

        .plan-header {
            background: #2c3e50;
            padding: 8px 12px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
        }

        .plan-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: white;
        }

        .plan-subtitle {
            font-size: 0.7rem;
            color: #bdc3c7;
            margin-top: 2px;
        }

        .plan-tools {
            display: flex;
            gap: 5px;
        }

        .plan-tool-btn {
            border: none;
            background: #e9ecef;
            cursor: pointer;
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .plan-tool-btn:hover {
            background: #dee2e6;
        }

        .plan-tool-btn.active {
            background: #007AFF;
            color: white;
        }

        .plan-canvas-container {
            position: relative;
            width: 100%;
            height: calc(100% - 45px);
        }

        #plan-view-canvas {
            width: 100%;
            height: 100%;
            cursor: default;
        }

        #plan-coordinates {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #333;
        }

        #plan-zoom-info {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #333;
        }

        /* ==========================================
           SECTION CUT VIEW
           ========================================== */
        #section-view-container {
            display: none;
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 450px;
            height: 380px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            z-index: 400;
            min-width: 300px;
            min-height: 250px;
            resize: both;
        }

        .section-header {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
        }

        .section-title {
            font-weight: 600;
            font-size: 0.85rem;
            color: white;
        }

        .section-subtitle {
            font-size: 0.7rem;
            color: #c4b5fd;
            margin-top: 2px;
        }

        .section-tools {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .section-select {
            padding: 3px 6px;
            border-radius: 4px;
            border: none;
            font-size: 0.75rem;
            background: white;
            cursor: pointer;
        }

        .section-canvas-container {
            position: relative;
            width: 100%;
            height: calc(100% - 90px);
        }

        #section-view-canvas {
            width: 100%;
            height: 100%;
            cursor: default;
        }

        #section-coordinates {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #333;
        }

        #section-zoom-info {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #333;
        }

        #section-position-info {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(139, 92, 246, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        #section-measure-label {
            position: absolute;
            display: none;
            background: rgba(139, 92, 246, 0.9);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
        }

        .section-slider-container {
            padding: 10px 12px;
            background: linear-gradient(to bottom, #f8fafc, #f1f5f9);
            border-top: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-slider-container label {
            font-size: 0.75rem;
            color: #64748b;
            white-space: nowrap;
            font-weight: 500;
        }

        .section-slider-container input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #c4b5fd 0%, #8b5cf6 50%, #c4b5fd 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .section-slider-container input[type="range"]:hover {
            background: linear-gradient(to right, #a78bfa 0%, #7c3aed 50%, #a78bfa 100%);
        }

        .section-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
            transition: all 0.2s ease;
            border: 3px solid white;
        }

        .section-slider-container input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 3px 10px rgba(139, 92, 246, 0.5);
        }

        .section-slider-container input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.1);
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
        }

        .section-slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border-radius: 50%;
            cursor: grab;
            border: 3px solid white;
            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
        }

        .section-slider-container span {
            font-size: 0.8rem;
            color: #333;
            min-width: 55px;
            text-align: right;
            font-weight: 600;
            background: white;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }

        .section-nudge-btn {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.7rem;
            cursor: pointer;
            color: #8b5cf6;
            transition: all 0.2s ease;
        }

        .section-nudge-btn:hover {
            background: #8b5cf6;
            color: white;
            border-color: #8b5cf6;
        }

        .section-nudge-btn:active {
            transform: scale(0.95);
        }

        .section-limit-label {
            font-size: 0.65rem;
            color: #94a3b8;
            min-width: 30px;
            text-align: center;
        }

        /* ==========================================
           MEASURE LABELS
           ========================================== */
        #measure-label,
        #plan-measure-label {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
        }

        /* ==========================================
           EXPORT MODAL
           ========================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* ==========================================
           TOAST NOTIFICATIONS
           ========================================== */
        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
        }

        .toast {
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toast.success {
            background: #28a745;
        }

        .toast.error {
            background: #dc3545;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ==========================================
           ACCESSIBILITY & FOCUS
           ========================================== */
        *:focus-visible {
            outline: 2px solid #007AFF;
            outline-offset: 2px;
        }

        /* ==========================================
           RESPONSIVE DESIGN
           ========================================== */
        @media (max-width: 1024px) {
            #sidebar {
                width: 300px;
            }

            #viewcube-container {
                top: 15px;
                right: 320px;
                width: 100px;
                height: 100px;
            }

            #plan-view-container {
                right: 320px;
                width: 380px;
                height: 380px;
            }
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #viewer-container {
                height: 55vh;
                width: 100%;
            }

            #sidebar {
                width: 100%;
                height: 45vh;
                border-left: none;
                border-top: 1px solid #e1e1e1;
            }

            #toolbar {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
                flex-wrap: wrap;
                max-width: 90%;
                padding: 8px 12px;
                border-radius: 12px;
            }
            
            .toolbar-group {
                flex-direction: row;
                gap: 2px;
                padding: 2px 0;
            }
            
            .toolbar-group:not(:last-child) {
                border-bottom: none;
                border-right: 1px solid #e5e5e5;
                padding-right: 8px;
                margin-right: 8px;
                padding-bottom: 0;
                margin-bottom: 0;
            }
            
            .toolbar-group-label {
                display: none;
            }

            .tool-btn {
                width: 38px;
                height: 38px;
                font-size: 1.1rem;
            }
            
            .tool-btn:hover::after,
            .tool-btn:hover::before {
                display: none;
            }

            #viewcube-container {
                top: 10px;
                right: 10px;
                width: 80px;
                height: 80px;
            }

            #plan-view-container {
                bottom: auto;
                top: 10px;
                right: 10px;
                width: 280px;
                height: 280px;
            }

            .btn-action {
                min-height: 48px;
            }
            
            #controls-panel {
                left: 10px;
                top: 70px;
                width: calc(100% - 20px);
                max-width: 320px;
            }
        }

        @media (max-width: 480px) {
            #plan-view-container {
                width: 220px;
                height: 220px;
            }

            .sidebar-tab {
                padding: 8px 4px;
                font-size: 0.65rem;
            }
            
            .tool-btn {
                width: 34px;
                height: 34px;
                font-size: 1rem;
            }
        }

        /* ==========================================
           FIELD MODE (Modo Canteiro)
           ========================================== */
        body.field-mode .prop-value {
            font-size: 1.1rem;
        }

        body.field-mode #measure-label {
            font-size: 18px;
            padding: 10px 15px;
        }

        body.field-mode .qty-total-value {
            font-size: 2.2rem;
        }

        body.field-mode .btn-action {
            min-height: 52px;
            font-size: 1rem;
        }

        /* ============================================
           NOVAS FUNCIONALIDADES - TOP 5
           ============================================ */
        
        /* Busca Inteligente */
        #search-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
        }
        
        #search-container.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #search-box {
            display: flex;
            align-items: center;
            background: white;
            border-radius: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 8px 16px;
            min-width: 400px;
        }
        
        #search-input {
            border: none;
            outline: none;
            font-size: 14px;
            flex: 1;
            padding: 8px;
            background: transparent;
        }
        
        #search-input::placeholder {
            color: #999;
        }
        
        #search-results {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            margin-top: 8px;
            max-height: 300px;
            overflow-y: auto;
            width: 100%;
            display: none;
        }
        
        #search-results.has-results {
            display: block;
        }
        
        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.15s;
        }
        
        .search-result-item:hover {
            background: #f8f9fa;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .search-result-icon.pilar { background: #e3f2fd; }
        .search-result-icon.viga { background: #fff3e0; }
        .search-result-icon.laje { background: #e8f5e9; }
        .search-result-icon.other { background: #f3e5f5; }
        
        .search-result-info {
            flex: 1;
        }
        
        .search-result-name {
            font-weight: 500;
            color: #333;
        }
        
        .search-result-meta {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        
        .search-tips {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            text-align: center;
        }
        
        /* Corte Dinâmico 3D */
        #dynamic-cut-panel {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 16px 24px;
            z-index: 900;
            display: none;
            min-width: 450px;
        }
        
        #dynamic-cut-panel.active {
            display: block;
        }
        
        .cut-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .cut-panel-title {
            font-weight: 600;
            color: #333;
        }
        
        .cut-axis-btns {
            display: flex;
            gap: 6px;
        }
        
        .cut-axis-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            background: #f0f0f0;
            color: #666;
            transition: all 0.2s;
        }
        
        .cut-axis-btn.active {
            background: #007AFF;
            color: white;
        }
        
        .cut-slider-container {
            margin-top: 12px;
        }
        
        .cut-slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
        }
        
        #cut-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }
        
        #cut-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #007AFF;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,122,255,0.4);
        }
        
        .cut-value-display {
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #007AFF;
            margin-top: 8px;
        }
        
        /* Modal de Custos */
        #cost-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        #cost-modal.active {
            display: flex;
        }
        
        .cost-modal-content {
            background: white;
            border-radius: 16px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        .cost-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: white;
            border-radius: 16px 16px 0 0;
        }
        
        .cost-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        
        .cost-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            padding: 0;
            line-height: 1;
        }
        
        .cost-modal-body {
            padding: 24px;
        }
        
        .cost-section {
            margin-bottom: 24px;
        }
        
        .cost-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .cost-input-row {
            display: grid;
            grid-template-columns: 1fr 120px 100px;
            gap: 12px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .cost-input-label {
            font-size: 13px;
            color: #666;
        }
        
        .cost-input {
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            text-align: right;
            transition: border-color 0.2s;
        }
        
        .cost-input:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        .cost-subtotal {
            font-size: 13px;
            font-weight: 500;
            color: #333;
            text-align: right;
        }
        
        .cost-divider {
            height: 1px;
            background: #eee;
            margin: 20px 0;
        }
        
        .cost-total-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }
        
        .cost-total-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .cost-total-row:last-child {
            margin-bottom: 0;
            padding-top: 12px;
            border-top: 2px solid #ddd;
        }
        
        .cost-total-label {
            font-size: 14px;
            color: #666;
        }
        
        .cost-total-value {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }
        
        .cost-grand-total {
            font-size: 20px;
            font-weight: 700;
            color: #007AFF;
        }
        
        .cost-bdi-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #eee;
        }
        
        .cost-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
        
        .cost-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cost-btn-primary {
            background: #007AFF;
            color: white;
        }
        
        .cost-btn-primary:hover {
            background: #0056b3;
        }
        
        .cost-btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .cost-btn-secondary:hover {
            background: #e0e0e0;
        }
        
        /* Checklist de Execução */
        /* ==========================================
           PAINEL DE CONTROLES - LADO ESQUERDO
           ========================================== */
        #controls-panel {
            position: absolute;
            top: 80px;
            left: 70px;
            width: 280px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 150;
            display: none;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }
        
        #controls-panel.active {
            display: block;
            animation: slideIn 0.2s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .controls-header {
            padding: 14px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .controls-title {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .controls-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .controls-close:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .controls-body {
            padding: 12px;
        }
        
        .controls-section {
            margin-bottom: 16px;
        }
        
        .controls-section:last-child {
            margin-bottom: 0;
        }
        
        .controls-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .controls-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .control-chip {
            padding: 6px 12px;
            background: #f0f0f0;
            border: 1px solid #e0e0e0;
            border-radius: 20px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .control-chip:hover {
            background: #e8e8e8;
        }
        
        .control-chip.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: transparent;
        }
        
        .control-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
            background: white;
            cursor: pointer;
        }
        
        .control-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .control-slider-wrapper {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 10px;
            margin-top: 8px;
        }
        
        .control-slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 6px;
        }
        
        .control-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .control-btn {
            width: 100%;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .control-btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .control-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .control-btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .control-btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .control-btn-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .control-btn-group .control-btn {
            flex: 1;
        }
        
        .controls-divider {
            height: 1px;
            background: #e5e5e5;
            margin: 16px 0;
        }
        
        .dark-mode #controls-panel {
            background: rgba(40, 40, 45, 0.98);
        }
        
        .dark-mode .controls-header {
            background: linear-gradient(135deg, #4a4a52 0%, #3a3a42 100%);
        }
        
        .dark-mode .controls-section-title {
            color: #aaa;
        }
        
        .dark-mode .control-chip {
            background: #3a3a42;
            border-color: #4a4a52;
            color: #ddd;
        }
        
        .dark-mode .control-chip:hover {
            background: #4a4a52;
        }
        
        .dark-mode .control-chip.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .dark-mode .control-select {
            background: #2a2a32;
            border-color: #4a4a52;
            color: #ddd;
        }
        
        .dark-mode .control-slider-wrapper {
            background: #2a2a32;
        }
        
        .dark-mode .control-btn-secondary {
            background: #3a3a42;
            color: #ddd;
        }
        
        .dark-mode .control-btn-secondary:hover {
            background: #4a4a52;
        }
        
        .dark-mode .controls-divider {
            background: #4a4a52;
        }

        #checklist-panel {
            position: absolute;
            top: 60px;
            right: 370px;
            width: 280px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 800;
            display: none;
            max-height: calc(100vh - 100px);
            overflow: hidden;
        }
        
        #checklist-panel.active {
            display: flex;
            flex-direction: column;
        }
        
        .checklist-header {
            padding: 16px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .checklist-title {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        
        .checklist-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
        }
        
        .checklist-progress-bar {
            flex: 1;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .checklist-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #34c759, #30d158);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .checklist-progress-text {
            font-size: 12px;
            font-weight: 600;
            color: #34c759;
            min-width: 45px;
            text-align: right;
        }
        
        .checklist-body {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }
        
        .checklist-storey {
            padding: 8px 16px;
        }
        
        .checklist-storey-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            cursor: pointer;
            font-weight: 500;
            color: #333;
            font-size: 13px;
        }
        
        .checklist-storey-header:hover {
            color: #007AFF;
        }
        
        .checklist-storey-count {
            font-size: 11px;
            color: #888;
            font-weight: 400;
        }
        
        .checklist-items {
            padding-left: 8px;
        }
        
        .checklist-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .checklist-item:hover {
            background: #f8f9fa;
        }
        
        .checklist-item.completed {
            opacity: 0.6;
        }
        
        .checklist-item.completed .checklist-item-name {
            text-decoration: line-through;
        }
        
        .checklist-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #ddd;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .checklist-item.completed .checklist-checkbox {
            background: #34c759;
            border-color: #34c759;
            color: white;
        }
        
        .checklist-item-name {
            font-size: 12px;
            color: #333;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .checklist-item-vol {
            font-size: 11px;
            color: #888;
        }
        
        .checklist-actions {
            padding: 12px 16px;
            border-top: 1px solid #eee;
            display: flex;
            gap: 8px;
        }
        
        .checklist-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .checklist-btn-clear {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .checklist-btn-export {
            background: #dbeafe;
            color: #2563eb;
        }
        
        /* Tool button states */
        .tool-btn.active-feature {
            background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
            color: white;
        }

        /* ============================================
           MODO ESCURO
           ============================================ */
        
        body.dark-mode {
            background: #1a1a2e;
            color: #e0e0e0;
        }
        
        .dark-mode #toolbar {
            background: rgba(30, 30, 50, 0.95);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .toolbar-group:not(:last-child) {
            border-bottom-color: #444;
        }
        
        .dark-mode .toolbar-group-label {
            color: #666;
        }
        
        .dark-mode .tool-btn {
            color: #e0e0e0;
        }
        
        .dark-mode .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .tool-btn:hover::after {
            background: #222;
        }
        
        .dark-mode .tool-btn:hover::before {
            border-right-color: #222;
        }
        
        .dark-mode .tool-btn.active {
            background: linear-gradient(135deg, #1565c0, #0d47a1);
            color: white;
            box-shadow: inset 0 0 0 2px #42a5f5;
        }
        
        .dark-mode .tool-btn.accent {
            background: linear-gradient(135deg, #4a3728, #5d4037);
            color: #ffb74d;
        }
        
        .dark-mode .tool-btn.danger {
            color: #ef5350;
        }
        
        .dark-mode .tool-btn.danger:hover {
            background: rgba(239, 83, 80, 0.15);
        }
        
        .dark-mode #sidebar {
            background: rgba(25, 25, 40, 0.98);
            border-color: #333;
        }
        
        .dark-mode .sidebar-tab {
            background: #2a2a40;
            color: #aaa;
        }
        
        .dark-mode .sidebar-tab:hover {
            background: #3a3a55;
        }
        
        .dark-mode .sidebar-tab.active {
            background: #007AFF;
            color: white;
        }
        
        .dark-mode .sidebar-content {
            color: #e0e0e0;
        }
        
        .dark-mode .section-title {
            color: #fff;
            border-color: #444;
        }
        
        .dark-mode .property-row {
            border-color: #333;
        }
        
        .dark-mode .property-label {
            color: #888;
        }
        
        .dark-mode .property-value {
            color: #e0e0e0;
        }
        
        .dark-mode #info-panel {
            background: rgba(30, 30, 50, 0.95);
            border-color: #444;
        }
        
        .dark-mode .info-label {
            color: #888;
        }
        
        .dark-mode .info-value {
            color: #4fc3f7;
        }
        
        .dark-mode #plan-view-container {
            background: #1a1a2e;
            border-color: #333;
        }
        
        .dark-mode .plan-header {
            background: #2a2a40;
            border-color: #333;
            color: #e0e0e0;
        }
        
        .dark-mode #plan-canvas {
            background: #0d0d1a;
        }
        
        .dark-mode #section-view-container {
            background: #1a1a2e;
            border-color: #333;
        }
        
        .dark-mode .section-header {
            background: #2a2a40;
            border-color: #333;
            color: #e0e0e0;
        }
        
        .dark-mode #section-canvas {
            background: #0d0d1a;
        }
        
        .dark-mode #loading-overlay {
            background: rgba(15, 15, 25, 0.95);
        }
        
        .dark-mode .loading-text {
            color: #e0e0e0;
        }
        
        .dark-mode .filter-chip {
            background: #2a2a40;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-mode .filter-chip.active {
            background: #007AFF;
            color: white;
        }
        
        .dark-mode select,
        .dark-mode input[type="text"],
        .dark-mode input[type="number"] {
            background: #2a2a40;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-mode .quantity-card {
            background: #2a2a40;
            border-color: #333;
        }
        
        .dark-mode .quantity-label {
            color: #888;
        }
        
        .dark-mode .quantity-value {
            color: #4fc3f7;
        }
        
        .dark-mode .export-btn {
            background: #2a2a40;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-mode .export-btn:hover {
            background: #3a3a55;
        }
        
        .dark-mode #search-box {
            background: #2a2a40;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        .dark-mode #search-input {
            color: #e0e0e0;
        }
        
        .dark-mode #search-input::placeholder {
            color: #666;
        }
        
        .dark-mode #search-results {
            background: #2a2a40;
        }
        
        .dark-mode .search-result-item {
            border-color: #333;
        }
        
        .dark-mode .search-result-item:hover {
            background: #3a3a55;
        }
        
        .dark-mode .search-result-name {
            color: #e0e0e0;
        }
        
        .dark-mode .search-tips {
            color: #666;
        }
        
        .dark-mode #dynamic-cut-panel {
            background: #2a2a40;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        .dark-mode .cut-panel-title {
            color: #e0e0e0;
        }
        
        .dark-mode .cut-axis-btn {
            background: #3a3a55;
            color: #aaa;
        }
        
        .dark-mode .cut-slider-label {
            color: #888;
        }
        
        .dark-mode #cut-slider {
            background: #3a3a55;
        }
        
        .dark-mode #checklist-panel {
            background: #2a2a40;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        .dark-mode .checklist-title {
            color: #e0e0e0;
        }
        
        .dark-mode .checklist-progress {
            background: #1a1a2e;
        }
        
        .dark-mode .checklist-progress-bar {
            background: #3a3a55;
        }
        
        .dark-mode .checklist-storey-header {
            color: #e0e0e0;
        }
        
        .dark-mode .checklist-item:hover {
            background: #3a3a55;
        }
        
        .dark-mode .checklist-checkbox {
            border-color: #555;
        }
        
        .dark-mode .checklist-item-name {
            color: #e0e0e0;
        }
        
        .dark-mode .checklist-actions {
            border-color: #333;
        }
        
        .dark-mode #cost-modal .cost-modal-content {
            background: #2a2a40;
        }
        
        .dark-mode .cost-modal-header {
            background: #2a2a40;
            border-color: #333;
        }
        
        .dark-mode .cost-modal-title {
            color: #e0e0e0;
        }
        
        .dark-mode .cost-section-title {
            color: #e0e0e0;
        }
        
        .dark-mode .cost-input-label {
            color: #aaa;
        }
        
        .dark-mode .cost-input {
            background: #1a1a2e;
            color: #e0e0e0;
            border-color: #444;
        }
        
        .dark-mode .cost-subtotal {
            color: #e0e0e0;
        }
        
        .dark-mode .cost-divider {
            background: #444;
        }
        
        .dark-mode .cost-total-section {
            background: #1a1a2e;
        }
        
        .dark-mode .cost-total-label {
            color: #aaa;
        }
        
        .dark-mode .cost-total-value {
            color: #e0e0e0;
        }
        
        .dark-mode .cost-bdi-row {
            border-color: #444;
        }
        
        .dark-mode .cost-btn-secondary {
            background: #3a3a55;
            color: #e0e0e0;
        }
        
        .dark-mode .cost-btn-secondary:hover {
            background: #4a4a65;
        }
        
        .dark-mode #viewcube-container {
            background: rgba(30, 30, 50, 0.8);
        }
        
        .dark-mode .toast {
            background: #2a2a40;
            color: #e0e0e0;
        }
    </style>

    <!-- Three.js Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Web-IFC para carregar arquivos IFC (versão 0.0.66 - estável com IIFE) -->
    <script src="https://cdn.jsdelivr.net/npm/web-ifc@0.0.66/web-ifc-api-iife.js"></script>

    <!-- SheetJS para exportação Excel -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
</head>

<body>
    <!-- Visualizador carrega modelo embutido automaticamente -->

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <!-- Export Modal -->
    <div id="export-modal" class="modal-overlay">
        <div class="modal">
            <div class="modal-title">📥 Exportar Quantitativos</div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: #666; font-size: 0.9rem;">Escolha o formato de exportação:</p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button onclick="exportToExcel()" class="btn-action btn-success">
                        📊 Excel Completo (.xlsx)
                    </button>
                    <button onclick="exportToPDF()" class="btn-action btn-primary">
                        📑 PDF Visual (Resumo)
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="closeExportModal()" class="btn-action btn-secondary" style="width: auto; margin: 0;">
                    Cancelar
                </button>
            </div>
        </div>
    </div>

    <!-- Main Viewer Container -->
    <div id="viewer-container" style="flex:1; position:relative; overflow:hidden;">

        <!-- Global Error Handler -->
        <script>
            window.onerror = function (msg, url, line, col, error) {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) overlay.style.display = 'none';

                const errDiv = document.createElement('div');
                errDiv.style.cssText = 'position:fixed;top:10px;left:10px;z-index:9999;background:#ffdddd;color:#c00;border:1px solid red;padding:15px;font-family:monospace;max-width:80%;border-radius:8px;';
                errDiv.innerHTML = `<strong>⚠️ Erro:</strong><br>${msg}<br><small>Linha: ${line}</small>`;
                document.body.appendChild(errDiv);
                setTimeout(() => errDiv.remove(), 10000);
                return false;
            };
        </script>

        <!-- Loading Overlay -->
        <div id="loading-overlay">
            <div class="spinner"></div>
            <div id="loading-text">Iniciando Visualizador...</div>
            <div id="loading-progress">
                <div id="loading-progress-bar"></div>
            </div>
            <div id="error-log"
                style="color:red; font-size:14px; margin-top:15px; text-align:center; max-width:90%; display:none;">
            </div>
        </div>

        <!-- Toolbar -->
        <!-- Toolbar Vertical Organizada -->
        <div id="toolbar">
            <!-- Grupo: Navegação -->
            <div class="toolbar-group">
                <div class="toolbar-group-label">Vista</div>
                <button class="tool-btn" onclick="resetView()" data-tooltip="Resetar Vista" title="Resetar Vista">
                    🏠
                </button>
                <button class="tool-btn" onclick="toggleDarkMode()" id="btn-dark-mode" data-tooltip="Modo Escuro" title="Modo Escuro">
                    🌙
                </button>
                <button class="tool-btn" onclick="toggleControlsPanel()" id="btn-controls" data-tooltip="Filtros e Ferramentas" title="Filtros e Ferramentas">
                    ⚙️
                </button>
            </div>
            
            <!-- Grupo: Medição -->
            <div class="toolbar-group">
                <div class="toolbar-group-label">Medir</div>
                <button class="tool-btn" onclick="toggleMeasure()" id="btn-measure-tool" data-tooltip="Medir Distância" title="Ferramenta de Medição">
                    📏
                </button>
                <button class="tool-btn" onclick="toggleOrtho()" id="btn-ortho" data-tooltip="Modo Ortogonal" title="Modo Ortogonal (H/V)">
                    ⊥
                </button>
                <button class="tool-btn active" onclick="toggleSnap()" id="btn-snap" data-tooltip="Snap Vértices" title="Snap nos Vértices">
                    🎯
                </button>
                <button class="tool-btn danger" onclick="clearMeasurements()" data-tooltip="Limpar Medições" title="Limpar Medições">
                    🗑️
                </button>
            </div>
            
            <!-- Grupo: Análise -->
            <div class="toolbar-group">
                <div class="toolbar-group-label">Análise</div>
                <button class="tool-btn" onclick="toggleSearch()" id="btn-search" data-tooltip="Buscar (Ctrl+F)" title="Busca Inteligente">
                    🔎
                </button>
                <button class="tool-btn" onclick="toggleDynamicCut()" id="btn-dynamic-cut" data-tooltip="Corte Dinâmico" title="Corte Dinâmico 3D">
                    ✂️
                </button>
            </div>
            
            <!-- Grupo: Gestão -->
            <div class="toolbar-group">
                <div class="toolbar-group-label">Gestão</div>
                <button class="tool-btn" onclick="toggleChecklist()" id="btn-checklist" data-tooltip="Checklist Obra" title="Checklist de Execução">
                    ✅
                </button>
                <button class="tool-btn accent" onclick="openCostModal()" id="btn-costs" data-tooltip="Custos" title="Composição de Custos">
                    💰
                </button>
            </div>
        </div>

        <!-- Busca Inteligente -->
        <div id="search-container">
            <div id="search-box">
                <span style="font-size:18px; margin-right:8px;">🔎</span>
                <input type="text" id="search-input" placeholder="Buscar elemento... (ex: P12, vigas do térreo, lajes > 20cm)" autocomplete="off">
                <button onclick="clearSearch()" style="background:none; border:none; cursor:pointer; color:#999; font-size:18px;">×</button>
            </div>
            <div id="search-results"></div>
            <div class="search-tips">
                Dica: "P1", "vigas térreo", "lajes maciça", "volume > 1"
            </div>
        </div>

                <!-- Painel de Controles - Filtros e Ferramentas -->
        <div id="controls-panel">
            <div class="controls-header">
                <span class="controls-title">⚙️ Controles</span>
                <button class="controls-close" onclick="toggleControlsPanel()">×</button>
            </div>
            <div class="controls-body">
                <!-- Filtros por Tipo -->
                <div class="controls-section">
                    <div class="controls-section-title">🏗️ Filtrar por Tipo</div>
                    <div class="controls-chips" id="type-filter-chips">
                        <!-- Preenchido dinamicamente -->
                    </div>
                    <div class="control-btn-group" style="margin-top:8px;">
                        <button onclick="selectAllTypesControl()" class="control-btn control-btn-secondary" style="font-size:0.75rem; padding:6px;">✓ Todos</button>
                        <button onclick="deselectAllTypesControl()" class="control-btn control-btn-secondary" style="font-size:0.75rem; padding:6px;">✗ Nenhum</button>
                    </div>
                </div>
                
                <!-- Filtros por Pavimento -->
                <div class="controls-section">
                    <div class="controls-section-title">🏢 Filtrar por Pavimento</div>
                    <select class="control-select" id="level-filter-select" onchange="onLevelChangeControl(this.value)">
                        <option value="all">Todos os pavimentos</option>
                        <!-- Preenchido dinamicamente -->
                    </select>
                </div>
                
                <div class="controls-divider"></div>
                
                <!-- Visibilidade -->
                <div class="controls-section">
                    <div class="controls-section-title">👁️ Visibilidade</div>
                    <button onclick="showAll()" class="control-btn control-btn-secondary">
                        Mostrar Todos os Elementos
                    </button>
                </div>
                
                <!-- Transparência -->
                <div class="controls-section">
                    <div class="controls-section-title">🔮 Transparência</div>
                    <div class="control-slider-wrapper">
                        <div class="control-slider-label">
                            <span>Sólido</span>
                            <span id="transparency-value">0%</span>
                        </div>
                        <input type="range" class="control-slider" id="control-transparency-slider" 
                               min="0" max="100" value="0" 
                               oninput="updateTransparencyControl(this.value)">
                    </div>
                </div>
                
                <div class="controls-divider"></div>
                
                <!-- Cortes e Plantas -->
                <div class="controls-section">
                    <div class="controls-section-title">✂️ Cortes e Plantas</div>
                    <div class="control-btn-group" style="flex-direction:column;">
                        <button onclick="togglePlanView()" id="btn-plan-control" class="control-btn control-btn-secondary">
                            🧱 Planta de Forma
                        </button>
                        <button onclick="toggleSectionView()" id="btn-section-control" class="control-btn control-btn-secondary">
                            📐 Cortes Verticais
                        </button>
                    </div>
                </div>
                
                <!-- Plano de Corte Horizontal -->
                <div class="controls-section">
                    <div class="controls-section-title">📏 Plano de Corte (Altura)</div>
                    <div class="control-slider-wrapper">
                        <div class="control-slider-label">
                            <span id="cut-height-min">0.00m</span>
                            <span id="cut-height-value">—</span>
                        </div>
                        <input type="range" class="control-slider" id="control-cut-height-slider" 
                               step="0.1" 
                               oninput="updateCutHeightControl(this.value)">
                        <label style="display:flex; align-items:center; gap:6px; font-size:0.75rem; margin-top:8px; cursor:pointer; color:#666;">
                            <input type="checkbox" id="toggle-cut-plane-control" onchange="toggleCutPlaneVisibilityControl()">
                            Mostrar plano no 3D
                        </label>
                    </div>
                </div>
                
                <div class="controls-divider"></div>
                
                <!-- Exportação -->
                <div class="controls-section">
                    <div class="controls-section-title">📥 Exportar</div>
                    <button onclick="openExportModal()" class="control-btn control-btn-primary">
                        Exportar Quantitativos
                    </button>
                </div>
            </div>
        </div>

<!-- Corte Dinâmico 3D -->
        <div id="dynamic-cut-panel">
            <div class="cut-panel-header">
                <span class="cut-panel-title">✂️ Corte Dinâmico</span>
                <div class="cut-axis-btns">
                    <button class="cut-axis-btn active" onclick="setCutAxis('X')" id="cut-axis-x">Eixo X</button>
                    <button class="cut-axis-btn" onclick="setCutAxis('Y')" id="cut-axis-y">Eixo Y</button>
                    <button class="cut-axis-btn" onclick="setCutAxis('Z')" id="cut-axis-z">Eixo Z</button>
                </div>
            </div>
            <div class="cut-slider-container">
                <div class="cut-slider-label">
                    <span id="cut-min">0.00</span>
                    <span id="cut-max">100.00</span>
                </div>
                <input type="range" id="cut-slider" min="0" max="100" value="50" step="0.1" oninput="updateDynamicCut(this.value)">
                <div class="cut-value-display">
                    <span id="cut-value">50.00</span> m
                </div>
            </div>
            <div style="display:flex; gap:8px; margin-top:12px;">
                <button onclick="animateCut()" class="cost-btn cost-btn-secondary" style="flex:1; padding:8px;">▶ Animar</button>
                <button onclick="resetDynamicCut()" class="cost-btn cost-btn-secondary" style="flex:1; padding:8px;">↺ Resetar</button>
            </div>
        </div>

        <!-- Checklist de Execução -->
        <div id="checklist-panel">
            <div class="checklist-header">
                <span class="checklist-title">✅ Checklist de Execução</span>
                <button onclick="toggleChecklist()" style="background:none; border:none; cursor:pointer; font-size:18px; color:#999;">×</button>
            </div>
            <div class="checklist-progress">
                <div class="checklist-progress-bar">
                    <div class="checklist-progress-fill" id="checklist-progress-fill" style="width:0%"></div>
                </div>
                <span class="checklist-progress-text" id="checklist-progress-text">0%</span>
            </div>
            <div class="checklist-body" id="checklist-body">
                <!-- Preenchido dinamicamente -->
            </div>
            <div class="checklist-actions">
                <button class="checklist-btn checklist-btn-clear" onclick="clearChecklist()">🗑️ Limpar</button>
                <button class="checklist-btn checklist-btn-export" onclick="exportChecklist()">📤 Exportar</button>
            </div>
        </div>

        <!-- Modal de Custos -->
        <div id="cost-modal">
            <div class="cost-modal-content">
                <div class="cost-modal-header">
                    <span class="cost-modal-title">💰 Composição de Custos</span>
                    <button class="cost-modal-close" onclick="closeCostModal()">×</button>
                </div>
                <div class="cost-modal-body">
                    <div class="cost-section">
                        <div class="cost-section-title">🧱 Concreto</div>
                        <div class="cost-input-row">
                            <span class="cost-input-label">Concreto Estrutural (fck 30 MPa)</span>
                            <input type="number" class="cost-input" id="cost-concreto" value="450" step="10"> R$/m³
                            <span class="cost-subtotal" id="subtotal-concreto">R$ 0,00</span>
                        </div>
                        <div class="cost-input-row">
                            <span class="cost-input-label">Bombeamento</span>
                            <input type="number" class="cost-input" id="cost-bomba" value="35" step="5"> R$/m³
                            <span class="cost-subtotal" id="subtotal-bomba">R$ 0,00</span>
                        </div>
                    </div>
                    
                    <div class="cost-section">
                        <div class="cost-section-title">📐 Forma</div>
                        <div class="cost-input-row">
                            <span class="cost-input-label">Forma (material + mão de obra)</span>
                            <input type="number" class="cost-input" id="cost-forma" value="85" step="5"> R$/m²
                            <span class="cost-subtotal" id="subtotal-forma">R$ 0,00</span>
                        </div>
                    </div>
                    
                    <div class="cost-section">
                        <div class="cost-section-title">🔩 Aço</div>
                        
                        <!-- Toggle entre informar e estimar -->
                        <div style="display:flex; gap:8px; margin-bottom:12px;">
                            <button type="button" class="cost-btn" id="btn-aco-informar" onclick="setAcoMode('informar')" style="flex:1; padding:8px; font-size:12px; background:#007AFF; color:white;">
                                ✏️ Informar Quantidade
                            </button>
                            <button type="button" class="cost-btn" id="btn-aco-estimar" onclick="setAcoMode('estimar')" style="flex:1; padding:8px; font-size:12px; background:#f0f0f0; color:#333;">
                                📊 Estimar por Taxa
                            </button>
                        </div>
                        
                        <!-- Modo Informar -->
                        <div id="aco-mode-informar">
                            <div class="cost-input-row">
                                <span class="cost-input-label">Aço Pilares</span>
                                <input type="number" class="cost-input aco-input" id="aco-pilares-kg" value="0" step="100"> kg
                                <span class="cost-subtotal" id="subtotal-aco-pilares">R$ 0,00</span>
                            </div>
                            <div class="cost-input-row">
                                <span class="cost-input-label">Aço Vigas</span>
                                <input type="number" class="cost-input aco-input" id="aco-vigas-kg" value="0" step="100"> kg
                                <span class="cost-subtotal" id="subtotal-aco-vigas">R$ 0,00</span>
                            </div>
                            <div class="cost-input-row">
                                <span class="cost-input-label">Aço Lajes</span>
                                <input type="number" class="cost-input aco-input" id="aco-lajes-kg" value="0" step="100"> kg
                                <span class="cost-subtotal" id="subtotal-aco-lajes">R$ 0,00</span>
                            </div>
                            <div class="cost-input-row">
                                <span class="cost-input-label">Aço Fundações/Estacas</span>
                                <input type="number" class="cost-input aco-input" id="aco-fundacoes-kg" value="0" step="100"> kg
                                <span class="cost-subtotal" id="subtotal-aco-fundacoes">R$ 0,00</span>
                            </div>
                            <div class="cost-input-row" style="margin-top:8px; padding-top:8px; border-top:1px solid #eee;">
                                <span class="cost-input-label" style="font-weight:600;">Total Aço Informado</span>
                                <span style="font-weight:600;" id="aco-total-informado">0 kg</span>
                                <span></span>
                            </div>
                        </div>
                        
                        <!-- Modo Estimar -->
                        <div id="aco-mode-estimar" style="display:none;">
                            <div style="font-size:11px; color:#666; margin-bottom:10px; background:#f8f9fa; padding:10px; border-radius:8px;">
                                <strong>Taxas de aço utilizadas:</strong><br>
                                Pilares: 110 kg/m³ | Vigas: 100 kg/m³ | Lajes: 70 kg/m³<br>
                                Fundações: 90 kg/m³ | Estacas: 80 kg/m³ | Paredes: 60 kg/m³
                            </div>
                            <div class="cost-input-row">
                                <span class="cost-input-label">Aço Estimado Total</span>
                                <span style="font-weight:600; color:#007AFF;" id="aco-estimado-total">0 kg</span>
                                <span class="cost-subtotal" id="subtotal-aco-estimado">R$ 0,00</span>
                            </div>
                        </div>
                        
                        <div class="cost-input-row" style="margin-top:12px; padding-top:12px; border-top:1px solid #eee;">
                            <span class="cost-input-label">Preço Aço CA-50/60 (mat. + MO)</span>
                            <input type="number" class="cost-input" id="cost-aco" value="9.50" step="0.5"> R$/kg
                            <span class="cost-subtotal" id="subtotal-aco">R$ 0,00</span>
                        </div>
                    </div>
                    
                    <div class="cost-section" id="cost-section-protensao" style="display:none;">
                        <div class="cost-section-title">🔗 Protensão</div>
                        <div style="background: #e3f2fd; padding: 10px; border-radius: 8px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: #1565c0; font-weight: 500;">Cabos de Protensão:</span>
                                <span style="font-size: 1.2rem; font-weight: bold; color: #0d47a1;" id="protensao-num-cabos">0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
                                <span style="color: #1565c0; font-weight: 500;">Comprimento Total:</span>
                                <span style="font-weight: bold; color: #0d47a1;" id="protensao-comprimento">0,00 m</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
                                <span style="color: #1565c0; font-weight: 500;">Peso Total:</span>
                                <span style="font-weight: bold; color: #0d47a1;" id="protensao-peso">0,00 kg</span>
                            </div>
                        </div>
                        <div class="cost-input-row">
                            <span class="cost-input-label">Material (CP190 engraxada)</span>
                            <input type="number" class="cost-input" id="cost-protensao-material" value="0" step="0.5" placeholder="R$/kg"> R$/kg
                            <span class="cost-subtotal" id="subtotal-protensao-material">R$ 0,00</span>
                        </div>
                        <div class="cost-input-row">
                            <span class="cost-input-label">Mão de Obra (aplicação)</span>
                            <input type="number" class="cost-input" id="cost-protensao-mo" value="0" step="0.5" placeholder="R$/kg"> R$/kg
                            <span class="cost-subtotal" id="subtotal-protensao-mo">R$ 0,00</span>
                        </div>
                        <div class="cost-input-row" style="margin-top:8px; padding-top:8px; border-top:1px solid #e3f2fd;">
                            <span class="cost-input-label" style="font-weight:600;">Subtotal Protensão</span>
                            <span></span>
                            <span class="cost-subtotal" style="font-weight:600; color:#1565c0;" id="subtotal-protensao">R$ 0,00</span>
                        </div>
                    </div>
                    
                    <div class="cost-section">
                        <div class="cost-section-title">🏗️ Escoramento de Laje</div>
                        
                        <!-- Toggle entre madeira e metálico -->
                        <div style="display:flex; gap:8px; margin-bottom:12px;">
                            <button type="button" class="cost-btn" id="btn-escora-madeira" onclick="setEscoraMode('madeira')" style="flex:1; padding:8px; font-size:12px; background:#007AFF; color:white;">
                                🪵 Madeira
                            </button>
                            <button type="button" class="cost-btn" id="btn-escora-metalico" onclick="setEscoraMode('metalico')" style="flex:1; padding:8px; font-size:12px; background:#f0f0f0; color:#333;">
                                🔩 Metálico
                            </button>
                        </div>
                        
                        <!-- Modo Madeira -->
                        <div id="escora-mode-madeira">
                            <div class="cost-input-row">
                                <span class="cost-input-label">Preço Escoramento Madeira</span>
                                <input type="number" class="cost-input" id="cost-escora-madeira" value="18.00" step="1"> R$/m²
                            </div>
                        </div>
                        
                        <!-- Modo Metálico -->
                        <div id="escora-mode-metalico" style="display:none;">
                            <div class="cost-input-row">
                                <span class="cost-input-label">Preço Escoramento Metálico</span>
                                <input type="number" class="cost-input" id="cost-escora-metalico" value="45.00" step="1"> R$/m²
                            </div>
                        </div>
                        
                        <div class="cost-input-row" style="margin-top:8px; padding-top:8px; border-top:1px solid #eee;">
                            <span class="cost-input-label">Área de Laje</span>
                            <span style="font-weight:600; color:#007AFF;" id="area-laje-escora">0,00 m²</span>
                            <span class="cost-subtotal" id="subtotal-escora">R$ 0,00</span>
                        </div>
                    </div>
                    
                    <div class="cost-divider"></div>
                    
                    <div class="cost-total-section">
                        <div class="cost-total-row">
                            <span class="cost-total-label">Subtotal Concreto</span>
                            <span class="cost-total-value" id="total-concreto">R$ 0,00</span>
                        </div>
                        <div class="cost-total-row">
                            <span class="cost-total-label">Subtotal Forma</span>
                            <span class="cost-total-value" id="total-forma">R$ 0,00</span>
                        </div>
                        <div class="cost-total-row">
                            <span class="cost-total-label">Subtotal Aço (estimado)</span>
                            <span class="cost-total-value" id="total-aco">R$ 0,00</span>
                        </div>
                        <div class="cost-total-row">
                            <span class="cost-total-label">Subtotal Escoramento</span>
                            <span class="cost-total-value" id="total-escora">R$ 0,00</span>
                        </div>
                        <div class="cost-total-row" id="total-protensao-row" style="display:none;">
                            <span class="cost-total-label">Subtotal Protensão</span>
                            <span class="cost-total-value" id="total-protensao" style="color:#1565c0;">R$ 0,00</span>
                        </div>
                        <div class="cost-total-row" style="margin-top:10px; padding-top:10px; border-top:2px solid #007AFF;">
                            <span class="cost-total-label cost-grand-total">CUSTO TOTAL</span>
                            <span class="cost-total-value cost-grand-total" id="total-direto" style="color:#34c759;">R$ 0,00</span>
                        </div>
                    </div>
                    
                    <div class="cost-actions">
                        <button class="cost-btn cost-btn-secondary" onclick="exportCostPDF()">📄 Exportar PDF</button>
                        <button class="cost-btn cost-btn-secondary" onclick="exportCostExcel()">📊 Exportar Excel</button>
                        <button class="cost-btn cost-btn-primary" onclick="recalcCosts()">🔄 Recalcular</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ViewCube -->
        <div id="viewcube-container">
            <canvas id="viewcube-canvas"></canvas>
        </div>

        <!-- Info Panel (shows on element selection) -->
        <div id="info-panel">
            <div class="info-row">
                <span class="info-label">Volume:</span>
                <span class="info-value" id="info-volume">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Dimensões:</span>
                <span class="info-value" id="info-dimensions">-</span>
            </div>
        </div>

        <!-- Company Logo - SVG Profissional ProCalculo -->
        <div id="company-logo">
            <img src="data:image/png;base64,UklGRixOAABXRUJQVlA4WAoAAAAwAAAA/wMA/wMASUNDUMgBAAAAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADZBTFBItEMAAAH/JyRI8P94a0Sk7kkK2rZhUv7A3wYgIhKnj1zrG9Ybtv+PlPb/93zNbKVIr/YuijRFBCl2UOyxYXpMN9Uk77xjTDRFY0yixhZLir3GgmLvFRELiD0qChYUpC27y5aZ542ZnZmdQT77ee+NRPR/AoAC8fcfRUTCv/7/1//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvv/7/+/9f/rlGqdUpaSvqIJm57JGlD0eXLRT/5uuvRiTtNiNaVHWh3vfhtRkT70rYUuOeT7jssiJZ17Shw04/eZkXENa0pcNPvmo2I1rUdKXDPp6P+RkTLls7gpk933WxHNK2NpNz0VDGbEdGwJZ6Aez4dtcmGrGFDLAH3fBL1NyLWbOxJgXs+idrMIFuzqQe46VMx2xGxdmM85aZH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HEiDWOKflhofKEbVpn/vaC8eaJOW3DtcEICq5dDX33lrZISegHjSNC01wV8CoHy7Z739zqsDQmkQ6dEvLSmQB4J7pqaFUTx080H9EsOIAHVKWmo3Dz4AogpNzXrjnddHRTehwLVKgrciomnHgIiODjs4bC+wXbt27YV34O/Yoam6gQIiEoQSQkAgIQQkJJRKQxMQTYSDUEIIcQRACAGhhBACjgkhIJAQAoIJIQQcE0IIOCSEEAFACAGBhBAQTggBiYljkJQIB+mJSCEAQAitVlEEpCSEgGhCCAGHhBAiAoDQahUBiQkhIC2hVGqKgHhCCDgkhIBDQggBwYQQAoIJoVU0IeBq7bjdjGjem6YG93zSNseCaNmfpAU3/ZY5ZkTb4Xg1uOl3yjEjMqcSaHDTD8iuR8T8FhS46UfkWBDxYhS46VNt15sQmbzm4KZPd91oQrSdjAY3fVX0KgOi5XA3yk1PE/1XHWL94Vga3PNVsatqEc17UjXgnq+JWWpANO3rToN7vjp2pQHRuLOPDtzz1XF/1iAac1LV4J6villhQDTl9NOBez7VaW0toim7tw7c9CNXGhHNe/uqwT2fhG2pQzTvTNSDm36nv02I9fvTaHDPJ62y6xEtB3pqwU2/zQ4zovVwDzW455MO202I9pPdVeCmH5RtRmTz2lDgpt8xpx4RL3QFN30Ssr4ekckPATd9qvNmM6LtWDS46dMRK42IliNRxE1PE/1Xrd1uPtBdBW76Yf/Zt3//gTUpanDX1wUFBwUFedPwr///9f+//v/X//7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv///+v9f///r/3/9/6////X/v/7/1///+v9f///r/3/9/6////X/v/53SwdWUDgggggAANDkAJ0BKgAEAAQ+USiPRyOioSGgGAgIcAoJaW7kqpc8La0D2ufN5ezAE9yHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfb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" alt="ProCálculo" style="height: 100%; width: auto;">
        </div>

        <!-- 2D Floor Plan Container -->
        <div id="plan-view-container">
            <div class="plan-header">
                <div>
                    <div class="plan-title">Planta de Forma</div>
                    <div class="plan-subtitle">Arraste header para mover | Canto para redimensionar</div>
                </div>
                <div class="plan-tools">
                    <button onclick="togglePlanMeasure()" id="btn-plan-measure" class="plan-tool-btn"
                        title="Medição">📏</button>
                    <button onclick="togglePlanOrtho()" id="btn-plan-ortho" class="plan-tool-btn"
                        title="Modo Ortogonal">⊥</button>
                    <button onclick="togglePlanSnap()" id="btn-plan-snap" class="plan-tool-btn active"
                        title="Snap">🎯</button>
                    <button onclick="clearPlanMeasurements()" class="plan-tool-btn"
                        title="Limpar Medições">🗑️</button>
                    <button onclick="resetPlanView()" class="plan-tool-btn" title="Resetar">🔄</button>
                    <button onclick="togglePlanView()" class="plan-tool-btn" title="Fechar">✕</button>
                </div>
            </div>
            <div class="plan-canvas-container" id="plan-canvas-wrapper">
                <canvas id="plan-view-canvas"></canvas>
                <div id="plan-measure-label">0.00m</div>
                <div id="plan-coordinates">X: 0.00, Z: 0.00</div>
                <div id="plan-zoom-info">100%</div>
            </div>
        </div>

        <!-- Section Cut View Container -->
        <div id="section-view-container">
            <div class="section-header">
                <div>
                    <div class="section-title">Corte <span id="section-name">AA</span></div>
                    <div class="section-subtitle">Arraste header para mover | Canto para redimensionar</div>
                </div>
                <div class="section-tools">
                    <select id="section-selector" onchange="changeSection(this.value)" class="section-select">
                        <option value="AA">Corte AA (Transversal)</option>
                        <option value="BB">Corte BB (Longitudinal)</option>
                    </select>
                    <button onclick="alignCameraToSection()" class="plan-tool-btn" 
                        title="Alinhar Câmera 3D ao Corte">📷</button>
                    <button onclick="toggleSectionMeasure()" id="btn-section-measure" class="plan-tool-btn"
                        title="Medição">📏</button>
                    <button onclick="toggleSectionOrtho()" id="btn-section-ortho" class="plan-tool-btn"
                        title="Modo Ortogonal">⊥</button>
                    <button onclick="toggleSectionSnap()" id="btn-section-snap" class="plan-tool-btn active"
                        title="Snap">🎯</button>
                    <button onclick="clearSectionMeasurements()" class="plan-tool-btn"
                        title="Limpar Medições">🗑️</button>
                    <button onclick="resetSectionView()" class="plan-tool-btn" title="Resetar">🔄</button>
                    <button onclick="toggleSectionView()" class="plan-tool-btn" title="Fechar">✕</button>
                </div>
            </div>
            <div class="section-canvas-container" id="section-canvas-wrapper">
                <canvas id="section-view-canvas"></canvas>
                <div id="section-measure-label">0.00m</div>
                <div id="section-coordinates">X: 0.00, Y: 0.00</div>
                <div id="section-zoom-info">100%</div>
                <div id="section-position-info">Posição: 0.00m</div>
            </div>
            <!-- Section Position Slider -->
            <div class="section-slider-container">
                <span id="section-min-pos" class="section-limit-label">0.0</span>
                <button onclick="nudgeSectionPosition(-10)" class="section-nudge-btn" title="Mover -1m">◀◀</button>
                <button onclick="nudgeSectionPosition(-1)" class="section-nudge-btn" title="Mover -0.1m">◀</button>
                <input type="range" id="section-position-slider" min="0" max="100" value="50" 
                       oninput="updateSectionPosition(this.value)">
                <button onclick="nudgeSectionPosition(1)" class="section-nudge-btn" title="Mover +0.1m">▶</button>
                <button onclick="nudgeSectionPosition(10)" class="section-nudge-btn" title="Mover +1m">▶▶</button>
                <span id="section-max-pos" class="section-limit-label">100.0</span>
                <span id="section-position-value">0.00m</span>
            </div>
        </div>
    </div>

    <!-- Sidebar -->
    <div id="sidebar">
        <!-- Tabs -->
        <div class="sidebar-tabs">
            <button class="sidebar-tab active" onclick="switchTab('properties')" id="tab-properties">
                <span class="sidebar-tab-icon">📋</span>
                Propriedades
            </button>
            <button class="sidebar-tab" onclick="switchTab('quantities')" id="tab-quantities">
                <span class="sidebar-tab-icon">📊</span>
                Quantitativos
            </button>
        </div>

        <!-- Tab: Properties -->
        <div id="content-properties" class="tab-content active">
            <div id="properties-container">
                <div style="text-align: center; padding: 40px 20px; color: #999;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">👆</div>
                    <p>Clique em um elemento para ver suas propriedades</p>
                </div>
            </div>
        </div>

        <!-- Tab: Quantities -->
        <div id="content-quantities" class="tab-content">
            <div id="quantities-container" class="qty-panel">
                <!-- Será preenchido dinamicamente -->
            </div>
        </div>

        
    </div>

    <!-- Measurement Label -->
    <div id="measure-label">0.00m</div>

    <script>
        // ==========================================
        // PROTEÇÕES CONTRA CÓPIA E INSPEÇÃO
        // ==========================================
        (function() {
            // Desabilitar clique direito
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });
            
            // Desabilitar atalhos de teclado
            document.addEventListener('keydown', function(e) {
                // Ctrl+U (ver código fonte)
                if (e.ctrlKey && e.key === 'u') {
                    e.preventDefault();
                    return false;
                }
                // Ctrl+S (salvar)
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    return false;
                }
                // Ctrl+Shift+I (DevTools)
                if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                    e.preventDefault();
                    return false;
                }
                // Ctrl+Shift+J (Console)
                if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                    e.preventDefault();
                    return false;
                }
                // Ctrl+Shift+C (Inspect)
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    e.preventDefault();
                    return false;
                }
                // F12
                if (e.key === 'F12') {
                    e.preventDefault();
                    return false;
                }
            });
            
            // Detectar DevTools aberto
            let devToolsOpen = false;
            const threshold = 160;
            setInterval(function() {
                const widthThreshold = window.outerWidth - window.innerWidth > threshold;
                const heightThreshold = window.outerHeight - window.innerHeight > threshold;
                if (widthThreshold || heightThreshold) {
                    if (!devToolsOpen) {
                        devToolsOpen = true;
                        console.clear();
                        console.log('%c⚠️ ProCalculo - Conteúdo Protegido', 'color: red; font-size: 24px; font-weight: bold;');
                    }
                } else {
                    devToolsOpen = false;
                }
            }, 1000);
            
            // Desabilitar arrastar imagens
            document.addEventListener('dragstart', function(e) {
                e.preventDefault();
                return false;
            });
            
            // Desabilitar copiar
            document.addEventListener('copy', function(e) {
                e.preventDefault();
                return false;
            });
        })();

        // ==========================================
        // DADOS INJETADOS (placeholder para IFC)
        // ==========================================
        const MODEL_DATA_BASE64 = "[[IFC_DATA_PLACEHOLDER]]";
        
        // Metadados do IFC - substituídos pelo gerador Python
        // Quando processado pelo Python: vira o JSON dos metadados
        // Quando usado diretamente: usa detecção automática via web-ifc
        
let IFC_METADATA = {};

// ==========================================
// METADADOS EXTERNOS (GitHub Pages)
// - Se você estiver usando este HTML + model.glb + metadata.json na mesma pasta,
//   o viewer tenta carregar automaticamente o metadata.json.
// ==========================================
async function tryLoadMetadataFromUrl(url) {
    try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return false;
        const data = await res.json();
        if (data && typeof data === 'object') {
            IFC_METADATA = data;
            console.log('Metadata carregado de', url, 'itens:', Object.keys(IFC_METADATA).length);
            return true;
        }
        return false;
    } catch (e) {
        console.warn('Não foi possível carregar metadata:', url, e);
        return false;
    }
}
        
        // O Python substitui a linha abaixo com: IFC_METADATA = {...json...};
        // [[METADATA_INJECTION]]

        // ==========================================
        // CONFIGURAÇÃO GLOBAL
        // ==========================================
        let camera, scene, renderer, controls;
        let raycaster, mouse;
        let selectedObject = null;
        let selectedMesh = null;
        let originalMaterials = new Map();
        let hiddenObjects = new Set();
        let loadedModel = null;

        // Drag Detection - Simplificado
        let mouseDownX = 0;
        let mouseDownY = 0;
        const DRAG_THRESHOLD = 5; // pixels - se mover mais que isso, é drag/rotação

        // Measurement State
        let isMeasuring = false;
        let measureStep = 0;
        let measureStart = new THREE.Vector3();
        let measureEnd = new THREE.Vector3();
        let measureMarker = null;
        let measureLine = null;
        let measureLabels = []; // Labels de medição permanentes
        let measureLinesGroup = null; // Grupo de linhas de medição
        let isOrthoMode = false; // Modo ORTHO
        let snapEnabled = true; // SNAP nos vértices

        // ViewCube State
        let viewCubeScene, viewCubeCamera, viewCubeRenderer;
        let viewCubeMesh;
        let viewCubeRaycaster = new THREE.Raycaster();
        let viewCubeMouse = new THREE.Vector2();
        let isAnimatingCamera = false;

        // Floor Plan State
        let isPlanViewActive = false;
        let manualCutHeight = 1.2;
        let planLines = [];
        let planSelectedLine = null;
        let planCanvas = null;
        let planCtx = null;

        // Plan View Controls
        let planTransform = {
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            minScale: 0.1,
            maxScale: 10,
            isPanning: false,
            lastMouseX: 0,
            lastMouseY: 0,
            isMeasuring: false,
            measurePoints: [],
            measureLines: [],
            currentMouseWorld: null,
            isOrtho: false,
            isSnap: true
        };

        let planBounds = { minX: 0, maxX: 0, minZ: 0, maxZ: 0 };
        let planCache = {
            elements: [],
            lastCutHeight: null,
            lastBounds: null,
            needsUpdate: true
        };

        // Section Cut State
        let isSectionViewActive = false;
        let sectionCanvas = null;
        let sectionCtx = null;
        let sectionLines = [];
        let sectionSelectedLine = null;
        
        // Section Definitions - AA: Transversal (eixo X), BB: Longitudinal (eixo Z)
        let sectionCuts = {
            AA: { axis: 'X', position: 0, minPos: 0, maxPos: 100, label: 'Transversal' },
            BB: { axis: 'Z', position: 0, minPos: 0, maxPos: 100, label: 'Longitudinal' }
        };
        let currentSection = 'AA';
        
        // Section View Controls
        let sectionTransform = {
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            minScale: 0.1,
            maxScale: 10,
            isPanning: false,
            lastMouseX: 0,
            lastMouseY: 0,
            isMeasuring: false,
            measurePoints: [],
            measureLines: [],
            currentMouseWorld: null,
            isOrtho: false,
            isSnap: true
        };
        
        let sectionCache = {
            elements: [],
            lastPosition: null,
            lastBounds: null,
            needsUpdate: true
        };
        
        // Section Plane Helper (visual no 3D)
        let sectionPlaneHelpers = {};

        // Cut Plane State
        let cutPlaneMesh = null;
        let cutPlaneHelper = null;
        let cutPlaneVisible = false;
        let modelBounds = null;

        // Transparency
        let globalTransparency = 1.0;

        // Dimension Labels
        let dimensionLabels = [];

        // Filter State
        const filterState = {
            types: new Set(['Pilar', 'Viga', 'Laje', 'Parede', 'Fundação', 'Estaca', 'Cabos', 'Outros']),
            levels: new Set(),
            selectedStorey: null,
            searchQuery: ''
        };

        // Field Mode
        let isFieldMode = false;

        // ==========================================
        // TOP 5 FEATURES - STATE VARIABLES
        // ==========================================
        
        // Busca Inteligente
        let searchActive = false;
        let searchTimeout = null;
        
        // Corte Dinâmico 3D
        let dynamicCutActive = false;
        let dynamicCutAxis = 'X';
        let dynamicCutPlane = null;
        let dynamicCutValue = 0;
        let dynamicCutBounds = { min: 0, max: 100 };
        let cutAnimationId = null;
        let clippingPlane = null; // THREE.Plane para corte real
        
        // Checklist de Execução
        let checklistActive = false;
        let completedElements = new Set();
        
        // Custos
        let costPrices = {
            concreto: 450,
            bomba: 35,
            forma: 85,
            aco: 9.50,
            bdi: 25
        };
        let costTaxasAco = {
            pilar: 110,
            viga: 100,
            laje: 70,
            fundacao: 90,
            estaca: 80,
            parede: 60
        };

        // Type Map for IFC elements
        const typeMap = {
            'IfcBeam': 'Viga',
            'IfcColumn': 'Pilar',
            'IfcSlab': 'Laje',
            'IfcWall': 'Parede',
            'IfcWallStandardCase': 'Parede',
            'IfcFooting': 'Fundação',
            'IfcPile': 'Fundação',
            'IfcWindow': 'Janela',
            'IfcDoor': 'Porta',
            'IfcRoof': 'Telhado',
            'IfcStair': 'Escada',
            'IfcRamp': 'Rampa',
            'IfcMember': 'Elemento Estrutural',
            'IfcPlate': 'Laje'
        };

        // ==========================================
        // MODELO CARREGADO AUTOMATICAMENTE (embutido)
        // ==========================================
        // Funções de upload externo removidas - o modelo é gerado pelo ui.py

                // ==========================================
        // INITIALIZATION
        // ==========================================
        async function init() {
            try {
                updateLoadingProgress(10, 'Criando cena 3D...');
                const container = document.getElementById('viewer-container');

                // iPhone/iPad Safari tende a perder contexto WebGL com pixelRatio alto e antialias.
                // Ajustes para robustez no iOS.
                const ua = navigator.userAgent || '';
                const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf5f5f7);

                // Lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(50, 200, 100);
                scene.add(dirLight);
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                scene.add(hemiLight);

                // Camera
                camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100000);
                camera.position.set(10, 10, 10);
                camera.lookAt(0, 0, 0);

                // Renderer
                updateLoadingProgress(20, 'Configurando renderizador...');
                renderer = new THREE.WebGLRenderer({ antialias: !isIOS, alpha: false, powerPreference: 'high-performance' });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isIOS ? 1.5 : 2));
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.localClippingEnabled = true; // Habilitar clipping planes
                container.appendChild(renderer.domElement);

                // Se o Safari perder o contexto WebGL, mostre mensagem clara.
                renderer.domElement.addEventListener('webglcontextlost', function(e) {
                    e.preventDefault();
                    showError('O iPhone perdeu o contexto 3D (WebGL). Feche a aba e abra o link novamente. Se persistir, reduza o tamanho do modelo.');
                }, false);

                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;

                // Raycaster
                raycaster = new THREE.Raycaster();
                raycaster.params.Line.threshold = 0.1;
                mouse = new THREE.Vector2();

                // Setup
                updateLoadingProgress(30, 'Configurando ferramentas...');
                setupMeasurementVisuals();
                setupViewCube();
                setupPlanCanvas();
                setupSectionCanvas();
                setupEventListeners();

                // Start animation loop
                animate();

                updateLoadingProgress(100, 'Pronto!');

                // Verificar se há dados de modelo pré-carregados
                if (MODEL_DATA_BASE64 && !MODEL_DATA_BASE64.startsWith("[[")) {
                    // Carregar modelo embutido (Base64 dentro do HTML)
                    updateLoadingProgress(50, 'Carregando modelo...');
                    await loadModel();

                    if (!IFC_METADATA || Object.keys(IFC_METADATA).length === 0) {
                        updateLoadingProgress(40, 'Carregando metadados...');
                        await tryLoadMetadataFromUrl('metadata.json');
                    }
                } else {
                    // Carregar modelo externo (model.glb na mesma pasta do index.html)
                    updateLoadingProgress(35, 'Baixando modelo...');
                    await loadModelFromUrl('model.glb');

                // Carregar metadata.json se não houve injeção via Python
                if (!IFC_METADATA || Object.keys(IFC_METADATA).length === 0) {
                    updateLoadingProgress(40, 'Carregando metadados...');
                    await tryLoadMetadataFromUrl('metadata.json');
                }

                }

                // Atualizar UI (mesmo se o metadata estiver incompleto)
                renderFiltersPanel();
                updateQuantitiesPanel();
                document.getElementById('loading-overlay').style.display = 'none';


            } catch (e) {
                console.error('Erro na inicialização:', e);
                showError(e.message || 'Erro desconhecido na inicialização');
                // Sempre esconder o overlay em caso de erro
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }

        function updateLoadingProgress(percent, text) {
            const bar = document.getElementById('loading-progress-bar');
            const textEl = document.getElementById('loading-text');
            if (bar) bar.style.width = percent + '%';
            if (textEl && text) textEl.innerText = text;
        }

        function showError(msg) {
            const el = document.getElementById('error-log');
            if (el) {
                el.style.display = 'block';
                el.innerText = msg;
            }
            // Também mostrar toast se disponível
            if (typeof showToast === 'function') {
                showToast('❌ ' + msg, 'error');
            }
        }

        // ==========================================
        // GEOMETRY CALCULATIONS (Real Volume & Area)
        // ==========================================
        
        /**
         * Calcula o comprimento de um tendon/cabo
         * Para tendons curvos, usa Volume / Área da seção
         * Para tendons retos, usa a maior dimensão
         */
        function calculateTendonLength(geometry, matrixWorld, boundingBoxSize) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return boundingBoxSize; // Fallback para bounding box
            }
            
            const sz = boundingBoxSize;
            const minDim = Math.min(sz.x, sz.y, sz.z); // Diâmetro aproximado
            const maxDim = Math.max(sz.x, sz.y, sz.z); // Comprimento reto
            
            // Se é quase um cilindro reto (razão > 10:1), usar bounding box
            if (maxDim / minDim > 10) {
                return maxDim;
            }
            
            // Para tendons mais curtos ou curvos, calcular via volume
            try {
                const volume = calculateMeshVolume(geometry, matrixWorld);
                if (volume > 0 && minDim > 0) {
                    // L = V / (π × r²) onde r = minDim/2
                    const radius = minDim / 2;
                    const sectionArea = Math.PI * radius * radius;
                    const calculatedLength = volume / sectionArea;
                    
                    // Validar: comprimento calculado deve ser >= maxDim (não menor que reto)
                    // e não muito maior (máximo 2x para curvas acentuadas)
                    if (calculatedLength >= maxDim * 0.9 && calculatedLength <= maxDim * 2.5) {
                        return calculatedLength;
                    }
                }
            } catch (e) {
                // Em caso de erro, usar bounding box
            }
            
            return maxDim; // Fallback
        }
        
        /**
         * Calcula o volume real de um mesh usando tetraedros assinados
         * Funciona para qualquer geometria fechada (não apenas caixas)
         */
        function calculateMeshVolume(geometry, matrixWorld) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return 0;
            }
            
            // Garantir que a geometria não é indexada ou converter
            let positions;
            if (geometry.index) {
                // Geometria indexada - precisamos desindexar
                const posAttr = geometry.attributes.position;
                const index = geometry.index;
                const triCount = index.count / 3;
                let volume = 0;
                
                for (let i = 0; i < triCount; i++) {
                    const i0 = index.getX(i * 3);
                    const i1 = index.getX(i * 3 + 1);
                    const i2 = index.getX(i * 3 + 2);
                    
                    // Vértices do triângulo
                    const v0 = new THREE.Vector3(posAttr.getX(i0), posAttr.getY(i0), posAttr.getZ(i0));
                    const v1 = new THREE.Vector3(posAttr.getX(i1), posAttr.getY(i1), posAttr.getZ(i1));
                    const v2 = new THREE.Vector3(posAttr.getX(i2), posAttr.getY(i2), posAttr.getZ(i2));
                    
                    // Aplicar transformação mundial
                    if (matrixWorld) {
                        v0.applyMatrix4(matrixWorld);
                        v1.applyMatrix4(matrixWorld);
                        v2.applyMatrix4(matrixWorld);
                    }
                    
                    // Volume do tetraedro com origem (método de divergência)
                    // V = (1/6) * |v0 · (v1 × v2)|
                    volume += signedVolumeOfTriangle(v0, v1, v2);
                }
                
                return Math.abs(volume);
            } else {
                // Geometria não indexada
                positions = geometry.attributes.position;
                const triCount = positions.count / 3;
                let volume = 0;
                
                for (let i = 0; i < triCount; i++) {
                    const v0 = new THREE.Vector3(
                        positions.getX(i * 3),
                        positions.getY(i * 3),
                        positions.getZ(i * 3)
                    );
                    const v1 = new THREE.Vector3(
                        positions.getX(i * 3 + 1),
                        positions.getY(i * 3 + 1),
                        positions.getZ(i * 3 + 1)
                    );
                    const v2 = new THREE.Vector3(
                        positions.getX(i * 3 + 2),
                        positions.getY(i * 3 + 2),
                        positions.getZ(i * 3 + 2)
                    );
                    
                    if (matrixWorld) {
                        v0.applyMatrix4(matrixWorld);
                        v1.applyMatrix4(matrixWorld);
                        v2.applyMatrix4(matrixWorld);
                    }
                    
                    volume += signedVolumeOfTriangle(v0, v1, v2);
                }
                
                return Math.abs(volume);
            }
        }
        
        /**
         * Volume assinado de um tetraedro formado por um triângulo e a origem
         */
        function signedVolumeOfTriangle(v0, v1, v2) {
            return v0.dot(v1.clone().cross(v2)) / 6.0;
        }
        
        /**
         * Calcula a área das faces horizontais (para lajes)
         * Considera faces com normal aproximadamente vertical (±Y)
         */
        function calculateHorizontalArea(geometry, matrixWorld) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return 0;
            }
            
            const normalThreshold = 0.7; // cos(45°) - faces com inclinação até 45°
            let totalArea = 0;
            
            // Matriz de rotação para transformar normais
            const normalMatrix = new THREE.Matrix3();
            if (matrixWorld) {
                normalMatrix.getNormalMatrix(matrixWorld);
            }
            
            if (geometry.index) {
                const posAttr = geometry.attributes.position;
                const index = geometry.index;
                const triCount = index.count / 3;
                
                for (let i = 0; i < triCount; i++) {
                    const i0 = index.getX(i * 3);
                    const i1 = index.getX(i * 3 + 1);
                    const i2 = index.getX(i * 3 + 2);
                    
                    const v0 = new THREE.Vector3(posAttr.getX(i0), posAttr.getY(i0), posAttr.getZ(i0));
                    const v1 = new THREE.Vector3(posAttr.getX(i1), posAttr.getY(i1), posAttr.getZ(i1));
                    const v2 = new THREE.Vector3(posAttr.getX(i2), posAttr.getY(i2), posAttr.getZ(i2));
                    
                    if (matrixWorld) {
                        v0.applyMatrix4(matrixWorld);
                        v1.applyMatrix4(matrixWorld);
                        v2.applyMatrix4(matrixWorld);
                    }
                    
                    // Calcular normal do triângulo
                    const edge1 = v1.clone().sub(v0);
                    const edge2 = v2.clone().sub(v0);
                    const normal = edge1.cross(edge2).normalize();
                    
                    // Verificar se é aproximadamente horizontal (normal vertical)
                    if (Math.abs(normal.y) > normalThreshold) {
                        // Área do triângulo = |edge1 × edge2| / 2
                        const crossProduct = v1.clone().sub(v0).cross(v2.clone().sub(v0));
                        const area = crossProduct.length() / 2;
                        totalArea += area;
                    }
                }
            } else {
                const positions = geometry.attributes.position;
                const triCount = positions.count / 3;
                
                for (let i = 0; i < triCount; i++) {
                    const v0 = new THREE.Vector3(
                        positions.getX(i * 3),
                        positions.getY(i * 3),
                        positions.getZ(i * 3)
                    );
                    const v1 = new THREE.Vector3(
                        positions.getX(i * 3 + 1),
                        positions.getY(i * 3 + 1),
                        positions.getZ(i * 3 + 1)
                    );
                    const v2 = new THREE.Vector3(
                        positions.getX(i * 3 + 2),
                        positions.getY(i * 3 + 2),
                        positions.getZ(i * 3 + 2)
                    );
                    
                    if (matrixWorld) {
                        v0.applyMatrix4(matrixWorld);
                        v1.applyMatrix4(matrixWorld);
                        v2.applyMatrix4(matrixWorld);
                    }
                    
                    const edge1 = v1.clone().sub(v0);
                    const edge2 = v2.clone().sub(v0);
                    const normal = edge1.clone().cross(edge2).normalize();
                    
                    if (Math.abs(normal.y) > normalThreshold) {
                        const crossProduct = v1.clone().sub(v0).cross(v2.clone().sub(v0));
                        const area = crossProduct.length() / 2;
                        totalArea += area;
                    }
                }
            }
            
            // Dividir por 2 porque contamos topo e fundo
            return totalArea / 2;
        }
        
        /**
         * Calcula a área total da superfície de um mesh
         */
        function calculateSurfaceArea(geometry, matrixWorld) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return 0;
            }
            
            let totalArea = 0;
            
            if (geometry.index) {
                const posAttr = geometry.attributes.position;
                const index = geometry.index;
                const triCount = index.count / 3;
                
                for (let i = 0; i < triCount; i++) {
                    const i0 = index.getX(i * 3);
                    const i1 = index.getX(i * 3 + 1);
                    const i2 = index.getX(i * 3 + 2);
                    
                    const v0 = new THREE.Vector3(posAttr.getX(i0), posAttr.getY(i0), posAttr.getZ(i0));
                    const v1 = new THREE.Vector3(posAttr.getX(i1), posAttr.getY(i1), posAttr.getZ(i1));
                    const v2 = new THREE.Vector3(posAttr.getX(i2), posAttr.getY(i2), posAttr.getZ(i2));
                    
                    if (matrixWorld) {
                        v0.applyMatrix4(matrixWorld);
                        v1.applyMatrix4(matrixWorld);
                        v2.applyMatrix4(matrixWorld);
                    }
                    
                    const crossProduct = v1.clone().sub(v0).cross(v2.clone().sub(v0));
                    totalArea += crossProduct.length() / 2;
                }
            } else {
                const positions = geometry.attributes.position;
                const triCount = positions.count / 3;
                
                for (let i = 0; i < triCount; i++) {
                    const v0 = new THREE.Vector3(
                        positions.getX(i * 3),
                        positions.getY(i * 3),
                        positions.getZ(i * 3)
                    );
                    const v1 = new THREE.Vector3(
                        positions.getX(i * 3 + 1),
                        positions.getY(i * 3 + 1),
                        positions.getZ(i * 3 + 1)
                    );
                    const v2 = new THREE.Vector3(
                        positions.getX(i * 3 + 2),
                        positions.getY(i * 3 + 2),
                        positions.getZ(i * 3 + 2)
                    );
                    
                    if (matrixWorld) {
                        v0.applyMatrix4(matrixWorld);
                        v1.applyMatrix4(matrixWorld);
                        v2.applyMatrix4(matrixWorld);
                    }
                    
                    const crossProduct = v1.clone().sub(v0).cross(v2.clone().sub(v0));
                    totalArea += crossProduct.length() / 2;
                }
            }
            
            return totalArea;
        }
        
        /**
         * Calcula OBB (Oriented Bounding Box) usando PCA simplificado
         * Retorna dimensões reais de elementos inclinados
         */
        function calculateOBB(geometry, matrixWorld) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return null;
            }
            
            const positions = geometry.attributes.position;
            const vertex = new THREE.Vector3();
            const vertices = [];
            
            // Transformar todos os vértices para coordenadas mundo
            for (let i = 0; i < positions.count; i++) {
                vertex.fromBufferAttribute(positions, i);
                if (matrixWorld) {
                    vertex.applyMatrix4(matrixWorld);
                }
                vertices.push(vertex.clone());
            }
            
            if (vertices.length < 4) return null;
            
            // Calcular centróide
            const centroid = new THREE.Vector3();
            vertices.forEach(v => centroid.add(v));
            centroid.divideScalar(vertices.length);
            
            // Calcular matriz de covariância 3x3
            let cxx = 0, cyy = 0, czz = 0;
            let cxy = 0, cxz = 0, cyz = 0;
            
            vertices.forEach(v => {
                const dx = v.x - centroid.x;
                const dy = v.y - centroid.y;
                const dz = v.z - centroid.z;
                cxx += dx * dx;
                cyy += dy * dy;
                czz += dz * dz;
                cxy += dx * dy;
                cxz += dx * dz;
                cyz += dy * dz;
            });
            
            const n = vertices.length;
            cxx /= n; cyy /= n; czz /= n;
            cxy /= n; cxz /= n; cyz /= n;
            
            // Encontrar autovetores usando método de potência iterativo (simplificado)
            // Para elementos estruturais, geralmente um eixo é muito maior que os outros
            const axes = [];
            
            // Eixo 1: direção de maior variância (comprimento)
            let axis1 = new THREE.Vector3(1, 0, 0);
            for (let iter = 0; iter < 20; iter++) {
                const newAxis = new THREE.Vector3(
                    cxx * axis1.x + cxy * axis1.y + cxz * axis1.z,
                    cxy * axis1.x + cyy * axis1.y + cyz * axis1.z,
                    cxz * axis1.x + cyz * axis1.y + czz * axis1.z
                );
                if (newAxis.length() > 0.0001) {
                    newAxis.normalize();
                    axis1 = newAxis;
                }
            }
            axes.push(axis1);
            
            // Eixo 2: perpendicular ao eixo 1, na direção de segunda maior variância
            // Usar Gram-Schmidt para ortogonalizar
            let axis2 = new THREE.Vector3(0, 1, 0);
            if (Math.abs(axis1.dot(axis2)) > 0.9) {
                axis2 = new THREE.Vector3(0, 0, 1);
            }
            axis2.sub(axis1.clone().multiplyScalar(axis1.dot(axis2))).normalize();
            
            // Refinar eixo 2 com iteração na submatriz
            for (let iter = 0; iter < 10; iter++) {
                const newAxis = new THREE.Vector3(
                    cxx * axis2.x + cxy * axis2.y + cxz * axis2.z,
                    cxy * axis2.x + cyy * axis2.y + cyz * axis2.z,
                    cxz * axis2.x + cyz * axis2.y + czz * axis2.z
                );
                // Remover componente ao longo de axis1
                newAxis.sub(axis1.clone().multiplyScalar(axis1.dot(newAxis)));
                if (newAxis.length() > 0.0001) {
                    newAxis.normalize();
                    axis2 = newAxis;
                }
            }
            axes.push(axis2);
            
            // Eixo 3: produto vetorial dos dois primeiros
            const axis3 = new THREE.Vector3().crossVectors(axis1, axis2).normalize();
            axes.push(axis3);
            
            // Projetar vértices nos eixos e encontrar extensão em cada direção
            const extents = axes.map(axis => {
                let min = Infinity, max = -Infinity;
                vertices.forEach(v => {
                    const proj = v.clone().sub(centroid).dot(axis);
                    min = Math.min(min, proj);
                    max = Math.max(max, proj);
                });
                return max - min;
            });
            
            return {
                dimensions: extents.sort((a, b) => b - a), // [maior, médio, menor]
                axes: axes,
                centroid: centroid
            };
        }
        
        /**
         * Calcula dimensões usando AABB (Axis-Aligned Bounding Box)
         * Melhor para elementos horizontais como lajes
         */
        function calculateAABBDimensions(geometry, matrixWorld) {
            if (!geometry) return { x: 0, y: 0, z: 0 };
            
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            const size = new THREE.Vector3();
            box.getSize(size);
            
            // Aplicar transformação da matriz mundo
            if (matrixWorld) {
                // Extrair escala e rotação
                const scale = new THREE.Vector3();
                const rotation = new THREE.Quaternion();
                matrixWorld.decompose(new THREE.Vector3(), rotation, scale);
                
                // Aplicar escala
                size.multiply(scale);
                
                // Para elementos rotacionados, precisamos recalcular o bounding box transformado
                // Criar 8 cantos do bounding box e transformar
                const corners = [
                    new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                    new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                    new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                    new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                    new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                    new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                    new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                    new THREE.Vector3(box.max.x, box.max.y, box.max.z)
                ];
                
                // Transformar cantos
                corners.forEach(c => c.applyMatrix4(matrixWorld));
                
                // Encontrar novo AABB
                const newMin = new THREE.Vector3(Infinity, Infinity, Infinity);
                const newMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
                corners.forEach(c => {
                    newMin.min(c);
                    newMax.max(c);
                });
                
                return {
                    x: newMax.x - newMin.x,
                    y: newMax.y - newMin.y,
                    z: newMax.z - newMin.z
                };
            }
            
            return { x: size.x, y: size.y, z: size.z };
        }
        
        /**
         * Estima as dimensões principais de um elemento (comprimento, largura, altura)
         * - Para LAJES: usa AABB, altura = dimensão Y (espessura vertical)
         * - Para VIGAS/PILARES: usa OBB (correto para elementos inclinados)
         */
        function estimateDimensions(geometry, matrixWorld, elementType = '') {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return { comp: 0, larg: 0, alt: 0 };
            }
            
            const typeLower = (elementType || '').toLowerCase();
            const isLaje = typeLower.includes('laje') || typeLower.includes('slab');
            
            // Para LAJES: usar AABB - altura é a dimensão Y (espessura)
            if (isLaje) {
                const aabb = calculateAABBDimensions(geometry, matrixWorld);
                // Para lajes horizontais: Y é a espessura, X e Z são comprimento/largura
                const horizontal = [aabb.x, aabb.z].sort((a, b) => b - a);
                return {
                    comp: horizontal[0],  // Maior dimensão horizontal
                    larg: horizontal[1],  // Segunda maior horizontal
                    alt: aabb.y           // Altura/espessura (dimensão vertical)
                };
            }
            
            // Para VIGAS e PILARES: usar OBB (correto para elementos inclinados)
            const obb = calculateOBB(geometry, matrixWorld);
            
            if (obb && obb.dimensions[0] > 0) {
                return {
                    comp: obb.dimensions[0],  // Maior dimensão (comprimento)
                    larg: obb.dimensions[1],  // Média dimensão (largura)
                    alt: obb.dimensions[2]    // Menor dimensão (altura da seção)
                };
            }
            
            // Fallback: usar AABB ordenado
            const aabb = calculateAABBDimensions(geometry, matrixWorld);
            const dims = [aabb.x, aabb.y, aabb.z].sort((a, b) => b - a);
            
            return {
                comp: dims[0],
                larg: dims[1],
                alt: dims[2]
            };
        }

        // ==========================================
        // MODEL LOADING
        // ==========================================
        function processNodes(object) {
            const typeMap = {
                'IFCBEAM': 'Viga',
                'IFCCOLUMN': 'Pilar',
                'IFCSLAB': 'Laje',
                'IFCWALL': 'Parede',
                'IFCWALLSTANDARDCASE': 'Parede',
                'IFCFOOTING': 'Fundação',
                'IFCROOF': 'Telhado',
                'IFCSTAIR': 'Escada',
                'IFCSTAIRFLIGHT': 'Escada',
                'IFCWINDOW': 'Janela',
                'IFCDOOR': 'Porta',
                'IFCMEMBER': 'Elemento',
                'IFCPLATE': 'Laje',
                'IFCRAILING': 'Guarda-corpo',
                'IFCRAMP': 'Rampa',
                'IFCRAMPFLIGHT': 'Rampa',
                'IFCCURTAINWALL': 'Cortina',
                'IFCCOVERING': 'Revestimento',
                'IFCBUILDINGELEMENTPROXY': 'Elemento',
                'IFCOPENINGELEMENT': 'Abertura',
                'IFCREINFORCINGBAR': 'Armadura',
                'IFCREINFORCINGMESH': 'Armadura',
                'IFCPILE': 'Estaca',
                'IFCFURNISHINGELEMENT': 'Mobiliário',
                'IFCTENDON': 'Cabos',
                'IFCTENDONANCHOR': 'Ancoragem',
                'IFCCABLECARRIERFITTING': 'Cabos',
                'IFCCABLESEGMENT': 'Cabos'
            };

            // Cores em tons de cinza (estilo Apple)
            const typeColors = {
                'Pilar': 0xA8A8A8,
                'Viga': 0xB8B8B8,
                'Laje': 0xC8C8C8,
                'Parede': 0xD0D0D0,
                'Fundação': 0x909090,
                'Estaca': 0x989898,
                'Telhado': 0xBBBBBB,
                'Escada': 0xAAAAAA,
                'Janela': 0xE0E0E0,
                'Cabos': 0x1565c0,
                'Ancoragem': 0x1976d2,
                'Porta': 0xCCCCCC,
                'Armadura': 0x858585,
                'Outros': 0xB0B0B0
            };

            console.log("Metadados IFC:", typeof IFC_METADATA !== 'undefined' ? Object.keys(IFC_METADATA).length + " elementos" : "não disponível");

            // Função para inferir tipo pelo nome do elemento
            function inferTypeFromName(name) {
                if (!name) return null;
                const nameLower = name.toLowerCase();
                
                // Padrões comuns em arquivos IFC/GLTF
                if (nameLower.includes('column') || nameLower.includes('pilar') || nameLower.includes('coluna')) return 'Pilar';
                if (nameLower.includes('beam') || nameLower.includes('viga')) return 'Viga';
                if (nameLower.includes('slab') || nameLower.includes('laje') || nameLower.includes('floor')) return 'Laje';
                if (nameLower.includes('wall') || nameLower.includes('parede')) return 'Parede';
                if (nameLower.includes('footing') || nameLower.includes('fundacao') || nameLower.includes('fundação') || nameLower.includes('sapata')) return 'Fundação';
                if (nameLower.includes('pile') || nameLower.includes('estaca')) return 'Estaca';
                if (nameLower.includes('roof') || nameLower.includes('telhado') || nameLower.includes('cobertura')) return 'Telhado';
                if (nameLower.includes('stair') || nameLower.includes('escada')) return 'Escada';
                if (nameLower.includes('ramp') || nameLower.includes('rampa')) return 'Rampa';
                if (nameLower.includes('tendon') || nameLower.includes('cable') || nameLower.includes('cordoalha') || nameLower.includes('protensao') || nameLower.includes('protensão')) return 'Cabos';
                if (nameLower.includes('rebar') || nameLower.includes('reinforc') || nameLower.includes('armadura') || nameLower.includes('ferro')) return 'Armadura';
                if (nameLower.includes('window') || nameLower.includes('janela')) return 'Janela';
                if (nameLower.includes('door') || nameLower.includes('porta')) return 'Porta';
                
                return null;
            }

            // Função para extrair nome legível
            function extractReadableName(rawName, userData) {
                // Primeiro tentar userData
                if (userData) {
                    if (userData.name && !isIfcGuid(userData.name)) return userData.name;
                    if (userData.Name && !isIfcGuid(userData.Name)) return userData.Name;
                    if (userData.info && userData.info.nome && !isIfcGuid(userData.info.nome)) return userData.info.nome;
                    if (userData.properties) {
                        if (userData.properties.Name && !isIfcGuid(userData.properties.Name)) return userData.properties.Name;
                        if (userData.properties.name && !isIfcGuid(userData.properties.name)) return userData.properties.name;
                        if (userData.properties.Tag && !isIfcGuid(userData.properties.Tag)) return userData.properties.Tag;
                        if (userData.properties.tag && !isIfcGuid(userData.properties.tag)) return userData.properties.tag;
                        if (userData.properties.Mark) return userData.properties.Mark;
                        if (userData.properties.Marca) return userData.properties.Marca;
                    }
                }
                
                if (!rawName) return 'Elemento';
                
                // Verificar se é um GUID IFC
                if (isIfcGuid(rawName)) {
                    // Tentar extrair tipo inferido e criar nome
                    const inferredType = inferTypeFromName(rawName);
                    if (inferredType) {
                        return inferredType + '_' + rawName.substring(0, 8);
                    }
                    return 'Elemento_' + rawName.substring(0, 8);
                }
                
                return rawName;
            }

            // Função para extrair tipo do userData
            function extractTypeFromUserData(userData) {
                if (!userData) return null;
                
                // Verificar tipo direto
                if (userData.type) {
                    const t = userData.type.toUpperCase();
                    if (typeMap[t]) return typeMap[t];
                    if (t.startsWith('IFC')) return typeMap[t] || t.replace('IFC', '');
                }
                if (userData.Type) {
                    const t = userData.Type.toUpperCase();
                    if (typeMap[t]) return typeMap[t];
                }
                
                // Verificar info
                if (userData.info && userData.info.tipo) {
                    return userData.info.tipo;
                }
                
                // Verificar properties
                if (userData.properties) {
                    if (userData.properties.ObjectType) return userData.properties.ObjectType;
                    if (userData.properties.objectType) return userData.properties.objectType;
                }
                
                return null;
            }

            object.traverse((child) => {
                if (child.isMesh) {
                    const guid = child.name;
                    let friendlyType = 'Outros';
                    let elementName = guid || 'Elemento';
                    let storey = '';
                    let elevation = null;
                    let meta = null; // Declarar meta no escopo correto

                    // PRIORIDADE 1: IFC_METADATA (gerado pelo conversor)
                    if (typeof IFC_METADATA !== 'undefined' && IFC_METADATA[guid]) {
                        meta = IFC_METADATA[guid];
                        
                        if (typeof meta === 'string') {
                            // Verificar se é abertura e ignorar
                            if (meta.toUpperCase() === 'IFCOPENINGELEMENT') {
                                child.visible = false;
                                return;
                            }
                            friendlyType = typeMap[meta.toUpperCase()] || meta.replace('IFC', '');
                        } else if (typeof meta === 'object') {
                            const type = (meta.type || meta.Type || '').toUpperCase();
                            // Verificar se é abertura e ignorar
                            if (type === 'IFCOPENINGELEMENT') {
                                child.visible = false;
                                return;
                            }
                            friendlyType = typeMap[type] || type.replace('IFC', '') || 'Outros';
                            elementName = meta.name || meta.Name || meta.tag || meta.Tag || guid;
                            storey = meta.storey || meta.Storey || meta.level || meta.Level || '';
                            elevation = (meta && meta.elevation != null) ? meta.elevation : ((meta && meta.Elevation != null) ? meta.Elevation : null);
                        }
                    }
                    // PRIORIDADE 2: userData do mesh (comum em arquivos GLTF)
                    else if (child.userData && Object.keys(child.userData).length > 0) {
                        const typeFromUserData = extractTypeFromUserData(child.userData);
                        if (typeFromUserData) friendlyType = typeFromUserData;
                        
                        elementName = extractReadableName(guid, child.userData);
                        
                        // Extrair storey do userData se disponível
                        if (child.userData.storey) storey = child.userData.storey;
                        if (child.userData.level) storey = child.userData.level;
                        if (child.userData.properties) {
                            if (child.userData.properties.Storey) storey = child.userData.properties.Storey;
                            if (child.userData.properties.Level) storey = child.userData.properties.Level;
                        }
                    }
                    // PRIORIDADE 3: Inferir pelo nome
                    else {
                        const inferredType = inferTypeFromName(guid);
                        if (inferredType) friendlyType = inferredType;
                        elementName = extractReadableName(guid, null);
                    }
                    
                    // Se tipo ainda é "Outros", tentar inferir pelo nome extraído
                    if (friendlyType === 'Outros') {
                        const inferredType = inferTypeFromName(elementName);
                        if (inferredType) friendlyType = inferredType;
                    }

                    // Aplicar cor cinza baseada no tipo
                    const color = typeColors[friendlyType] || typeColors['Outros'];
                    const newMat = new THREE.MeshStandardMaterial({
                        color: color,
                        roughness: 0.7,
                        metalness: 0.1,
                        side: THREE.DoubleSide
                    });
                    child.material = newMat;
                    originalMaterials.set(child.uuid, newMat.clone());

                    try { addEdges(child); } catch (e) { }

                    // Atualizar matriz mundial para cálculos precisos
                    child.updateMatrixWorld(true);
                    
                    // =====================================================
                    // CÁLCULOS DE GEOMETRIA - OTIMIZADO PARA TENDONS
                    // =====================================================
                    
                    let vol = 0;
                    let area = 0;
                    
                    // Para Tendons: usar bounding box (mais rápido, são cilindros simples)
                    if (friendlyType === 'Cabos') {
                        const box = new THREE.Box3().setFromObject(child);
                        const sz = box.getSize(new THREE.Vector3());
                        // Volume aproximado de cilindro: π * r² * L
                        const minDim = Math.min(sz.x, sz.y, sz.z);
                        const maxDim = Math.max(sz.x, sz.y, sz.z);
                        vol = Math.PI * Math.pow(minDim / 2, 2) * maxDim;
                    } else {
                        // Volume real do mesh (funciona para qualquer formato)
                        vol = calculateMeshVolume(child.geometry, child.matrixWorld);
                    }
                    
                    // Área para lajes (faces horizontais)
                    if (friendlyType === 'Laje') {
                        area = calculateHorizontalArea(child.geometry, child.matrixWorld);
                        // Se área horizontal for muito pequena, pode ser uma laje inclinada
                        // Nesse caso, usar metade da área de superfície total
                        if (area < 0.1) {
                            area = calculateSurfaceArea(child.geometry, child.matrixWorld) / 2;
                        }
                    }
                    
                    // Dimensões usando OBB para elementos inclinados, AABB para lajes
                    const obbDims = estimateDimensions(child.geometry, child.matrixWorld, friendlyType);
                    let comprimento = obbDims.comp;
                    const largura = obbDims.larg;
                    const altura = obbDims.alt;
                    
                    // Classificar tipo de laje (usando propriedades IFC e nome)
                    let tipoLaje = '';
                    let espessuraIFC = 0; // Para pegar a espessura das propriedades
                    
                    if (friendlyType === 'Laje') {
                        const nomeLower = elementName.toLowerCase();
                        
                        // 1. Tentar pegar tipo e espessura das propriedades IFC
                        if (meta && meta.properties) {
                            const props = meta.properties;
                            
                            for (const [key, val] of Object.entries(props)) {
                                const keyLower = key.toLowerCase();
                                const valStr = String(val || '').toLowerCase();
                                
                                // Espessura (Eberick)
                                if (keyLower === 'espessura' && typeof val === 'number') {
                                    espessuraIFC = val / 100; // cm para m
                                }
                                
                                // Tipo do Eberick
                                if (keyLower === 'tipo' && typeof val === 'string') {
                                    const tipoLower = val.toLowerCase();
                                    if (tipoLower.includes('nervurada')) {
                                        tipoLaje = 'Nervurada';
                                    } else if (tipoLower.includes('maciça') || tipoLower.includes('macica')) {
                                        tipoLaje = 'Maciça';
                                    } else if (tipoLower.includes('alveolar') || tipoLower.includes('protendida')) {
                                        tipoLaje = 'Alveolar';
                                    } else if (tipoLower.includes('treliç') || tipoLower.includes('trelic')) {
                                        tipoLaje = 'Treliçada';
                                    } else {
                                        tipoLaje = val; // Usar valor original
                                    }
                                }
                                
                                // Reference do Pset_SlabCommon
                                if (!tipoLaje && keyLower === 'reference' && valStr.includes('laje')) {
                                    if (valStr.includes('maciça') || valStr.includes('macica')) tipoLaje = 'Maciça';
                                    else if (valStr.includes('nervurada')) tipoLaje = 'Nervurada';
                                    else if (valStr.includes('treliçada') || valStr.includes('trelicada')) tipoLaje = 'Treliçada';
                                    else if (valStr.includes('alveolar')) tipoLaje = 'Alveolar';
                                }
                            }
                        }
                        
                        // 2. Se não encontrou no IFC, tentar pelo nome
                        if (!tipoLaje) {
                            if (nomeLower.includes('trelicada 1d') || nomeLower.includes('treliçada 1d')) {
                                tipoLaje = 'Treliçada 1D';
                            } else if (nomeLower.includes('trelicada 2d') || nomeLower.includes('treliçada 2d')) {
                                tipoLaje = 'Treliçada 2D';
                            } else if (nomeLower.includes('nervurada') || nomeLower.includes('treliça') || nomeLower.includes('trelica')) {
                                tipoLaje = 'Nervurada';
                            } else if (nomeLower.includes('maciça') || nomeLower.includes('macica')) {
                                tipoLaje = 'Maciça';
                            } else if (nomeLower.includes('alveolar') || nomeLower.includes('protendida')) {
                                tipoLaje = 'Alveolar';
                            } else if (nomeLower.includes('steel') || nomeLower.includes('deck')) {
                                tipoLaje = 'Steel Deck';
                            } else {
                                tipoLaje = 'Laje'; // Genérico
                            }
                        }
                    }
                    
                    // Calcular protensão para Tendons
                    let diametro = 0;
                    let pesoProtensao = 0;
                    let numCabos = 1; // Número de cabos por feixe (default 1)
                    
                    if (friendlyType === 'Cabos') {
                        // Calcular comprimento real do tendon (considera curvas)
                        const comprimentoReal = calculateTendonLength(child.geometry, child.matrixWorld, sz);
                        
                        // Estimar diâmetro pela menor dimensão (largura do cabo)
                        const minDim = Math.min(sz.x, sz.y, sz.z) * 1000; // em mm
                        const nomeLower = elementName.toLowerCase();
                        
                        // 1. Buscar número de cabos nas propriedades do IFC
                        if (meta && meta.properties) {
                            const props = meta.properties;
                            // Nomes comuns para número de cabos/cordoalhas (case insensitive)
                            const cabosKeys = [
                                'numberofstrands', 'strandcount', 'strands', 'numstrands',
                                'numcabos', 'numerodecabos', 'cordoalhas', 'ncordoalhas',
                                'quantity', 'count', 'number', 'cabos', 'ncabos',
                                'n_cabos', 'n_cordoalhas', 'qtd', 'qtde', 'quantidade'
                            ];
                            
                            for (const key of Object.keys(props)) {
                                const keyLower = key.toLowerCase();
                                if (cabosKeys.includes(keyLower) || 
                                    keyLower.includes('cabo') || 
                                    keyLower.includes('strand') || 
                                    keyLower.includes('cordoalha')) {
                                    const val = parseInt(props[key]);
                                    if (val >= 1 && val <= 31) {
                                        numCabos = val;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 2. Se não encontrou nas propriedades, extrair do nome
                        if (numCabos === 1) {
                            // Padrões: "3C", "4 cabos", "feixe 5", "F-3", "5x", "T-4C", etc.
                            const patterns = [
                                /(\d+)\s*(?:c(?:abos?)?|cord(?:oalhas?)?)/i,  // 3C, 4cabos, 5cordoalhas
                                /feixe\s*[-:]?\s*(\d+)/i,                      // feixe 3, feixe-4
                                /(\d+)\s*(?:x|×)\s*(?:\d|cp|strand)/i,         // 4x, 3×CP
                                /[TF][-_]?(\d)C/i,                             // T-3C, F4C
                                /[-_](\d+)[-_]?(?:c|cord)/i,                   // -3-cord, _4c
                                /(\d{1,2})(?:cp|strand|str)/i,                 // 4CP, 3strand
                                /^(\d)C[-\s]/                                  // 3C- no início
                            ];
                            
                            for (const pattern of patterns) {
                                const match = elementName.match(pattern);
                                if (match) {
                                    const val = parseInt(match[1]);
                                    if (val >= 1 && val <= 31) {
                                        numCabos = val;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // 3. Determinar diâmetro
                        if (minDim >= 14 && minDim <= 17) {
                            diametro = 15.2;
                        } else if (minDim >= 11 && minDim <= 14) {
                            diametro = 12.7;
                        } else {
                            // Tentar pelo nome
                            if (nomeLower.includes('15.2') || nomeLower.includes('15,2') || 
                                nomeLower.includes('cp190') || nomeLower.includes('rbtmeta')) {
                                diametro = 15.2;
                            } else if (nomeLower.includes('12.7') || nomeLower.includes('12,7') || 
                                      nomeLower.includes('cp175')) {
                                diametro = 12.7;
                            } else {
                                // Default para 15.2 (mais comum)
                                diametro = 15.2;
                            }
                        }
                        
                        // 4. Calcular peso: comprimento × peso/m × número de cabos
                        // Cordoalha CP190 RB 7 fios (valores típicos de fabricantes)
                        // Ø15.2mm: 1.10 kg/m
                        // Ø12.7mm: 0.79 kg/m
                        const pesoPorMetro = diametro >= 15 ? 1.10 : 0.79;
                        pesoProtensao = comprimentoReal * pesoPorMetro * numCabos;
                        
                        // Atualizar comprimento para o valor real calculado
                        comprimento = comprimentoReal;
                        
                        // Volume = 0 para tendons (não é concreto)
                        vol = 0;
                    }

                    // Para lajes, preferir espessura do IFC se disponível
                    const alturaFinal = (friendlyType === 'Laje' && espessuraIFC > 0) ? espessuraIFC : altura;
                    
                    child.userData.info = {
                        tipo: friendlyType,
                        nome: elementName,
                        guid: guid,
                        storey: storey,
                        elevation: elevation,
                        volume: vol,
                        area: area,
                        comp: comprimento,
                        larg: largura,
                        alt: alturaFinal, // Usar espessura IFC para lajes quando disponível
                        tipoLaje: tipoLaje,
                        diametro: diametro,
                        numCabos: numCabos,
                        pesoProtensao: pesoProtensao
                    };
                }
            });
        }
        
        // Versão assíncrona de processNodes - processa em chunks para não travar
        async function processNodesAsync(object) {
            // Coletar todos os meshes primeiro
            const meshes = [];
            object.traverse((child) => {
                if (child.isMesh) {
                    meshes.push(child);
                }
            });
            
            const total = meshes.length;
            const chunkSize = 50; // Processar 50 elementos por vez
            
            console.log(`Processando ${total} elementos em chunks de ${chunkSize}...`);
            
            for (let i = 0; i < total; i += chunkSize) {
                const chunk = meshes.slice(i, Math.min(i + chunkSize, total));
                
                // Processar chunk
                for (const child of chunk) {
                    processSingleMesh(child);
                }
                
                // Atualizar progresso
                const progress = Math.round(60 + (i / total) * 25);
                updateLoadingProgress(progress, `Processando elementos (${Math.min(i + chunkSize, total)}/${total})...`);
                
                // Dar tempo para o browser respirar
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            
            console.log(`Processamento concluído: ${total} elementos`);
        }
        
        // Processa um único mesh (extraído de processNodes)
        function processSingleMesh(child) {
            const typeMap = {
                'IFCBEAM': 'Viga', 'IFCCOLUMN': 'Pilar', 'IFCSLAB': 'Laje',
                'IFCWALL': 'Parede', 'IFCWALLSTANDARDCASE': 'Parede',
                'IFCFOOTING': 'Fundação', 'IFCROOF': 'Telhado',
                'IFCSTAIR': 'Escada', 'IFCSTAIRFLIGHT': 'Escada',
                'IFCWINDOW': 'Janela', 'IFCDOOR': 'Porta',
                'IFCMEMBER': 'Elemento', 'IFCPLATE': 'Laje',
                'IFCRAILING': 'Guarda-corpo', 'IFCRAMP': 'Rampa',
                'IFCRAMPFLIGHT': 'Rampa', 'IFCCURTAINWALL': 'Cortina',
                'IFCCOVERING': 'Revestimento', 'IFCBUILDINGELEMENTPROXY': 'Elemento',
                'IFCOPENINGELEMENT': 'Abertura', 'IFCREINFORCINGBAR': 'Armadura',
                'IFCREINFORCINGMESH': 'Armadura', 'IFCPILE': 'Estaca',
                'IFCFURNISHINGELEMENT': 'Mobiliário', 'IFCTENDON': 'Cabos',
                'IFCTENDONANCHOR': 'Ancoragem', 'IFCCABLECARRIERFITTING': 'Cabos',
                'IFCCABLESEGMENT': 'Cabos'
            };
            
            const typeColors = {
                'Pilar': 0xA8A8A8, 'Viga': 0xB8B8B8, 'Laje': 0xC8C8C8,
                'Parede': 0xD0D0D0, 'Fundação': 0x909090, 'Estaca': 0x989898,
                'Telhado': 0xBBBBBB, 'Escada': 0xAAAAAA, 'Janela': 0xE0E0E0,
                'Cabos': 0x1565c0, 'Ancoragem': 0x1976d2, 'Porta': 0xCCCCCC,
                'Armadura': 0x858585, 'Outros': 0xB0B0B0
            };
            
            const guid = child.name;
            let friendlyType = 'Outros';
            let elementName = guid || 'Elemento';
            let storey = '';
            let elevation = null;
            let meta = null;

            // PRIORIDADE 1: IFC_METADATA
            if (typeof IFC_METADATA !== 'undefined' && IFC_METADATA[guid]) {
                meta = IFC_METADATA[guid];
                if (typeof meta === 'string') {
                    // Verificar se é abertura e ignorar
                    if (meta.toUpperCase() === 'IFCOPENINGELEMENT') {
                        child.visible = false;
                        return;
                    }
                    friendlyType = typeMap[meta.toUpperCase()] || meta.replace('IFC', '');
                } else if (typeof meta === 'object') {
                    const type = (meta.type || meta.Type || '').toUpperCase();
                    // Verificar se é abertura e ignorar
                    if (type === 'IFCOPENINGELEMENT') {
                        child.visible = false;
                        return;
                    }
                    friendlyType = typeMap[type] || type.replace('IFC', '') || 'Outros';
                    elementName = meta.name || meta.Name || meta.tag || meta.Tag || guid;
                    storey = meta.storey || meta.Storey || meta.level || meta.Level || '';
                    elevation = (meta && meta.elevation != null) ? meta.elevation : ((meta && meta.Elevation != null) ? meta.Elevation : null);
                }
            }
            // PRIORIDADE 2: Inferir pelo nome
            else {
                const nameLower = guid.toLowerCase();
                if (nameLower.includes('pilar') || nameLower.includes('column')) friendlyType = 'Pilar';
                else if (nameLower.includes('viga') || nameLower.includes('beam')) friendlyType = 'Viga';
                else if (nameLower.includes('laje') || nameLower.includes('slab')) friendlyType = 'Laje';
                else if (nameLower.includes('tendon') || nameLower.includes('cabo')) friendlyType = 'Cabos';
            }

            // Aplicar cor
            const color = typeColors[friendlyType] || typeColors['Outros'];
            child.material = new THREE.MeshStandardMaterial({
                color: color, roughness: 0.7, metalness: 0.1, side: THREE.DoubleSide
            });
            originalMaterials.set(child.uuid, child.material.clone());

            try { addEdges(child); } catch (e) { }

            child.updateMatrixWorld(true);
            
            // Usar OBB para elementos inclinados, AABB para lajes
            const obbDims = estimateDimensions(child.geometry, child.matrixWorld, friendlyType);
            let comprimento = obbDims.comp;
            const largura = obbDims.larg;
            const altura = obbDims.alt;
            
            // Bounding box apenas para tendons (cilindros)
            const box = new THREE.Box3().setFromObject(child);
            const sz = box.getSize(new THREE.Vector3());
            
            // Inicializar valores
            let vol = 0, area = 0;
            let diametro = 0, numCabos = 1, pesoProtensao = 0;
            let tipoLaje = '';
            let espessuraIFC = 0; // Espessura do IFC para lajes
            
            // =====================================================
            // PROCESSAMENTO ESPECÍFICO POR TIPO
            // =====================================================
            
            if (friendlyType === 'Cabos') {
                // TENDON: usar dados extraídos pelo Python (ifcopenshell) quando disponíveis
                
                // Verificar se os metadados têm dados de protensão calculados pelo Python
                if (meta && meta.properties && meta.properties.numCordoalhas) {
                    // USAR DADOS DOS METADADOS (calculados corretamente pelo ifcopenshell)
                    numCabos = meta.properties.numCordoalhas || 1;
                    comprimento = meta.properties.comprimentoTotal || 0;
                    diametro = meta.properties.diametroMm || 15.2;
                    pesoProtensao = meta.properties.pesoTotal || 0;
                    
                    // Armazenar dados extras para exibição
                    child.userData.tendonData = {
                        numCordoalhas: numCabos,
                        comprimentoTotal: comprimento,
                        comprimentoPorCordoalha: meta.properties.comprimentoPorCordoalha || 0,
                        diametroMm: diametro,
                        pesoTotal: pesoProtensao,
                        pesoPorMetro: meta.properties.pesoPorMetro || 1.126
                    };
                    
                    console.log(`[Tendon] ${elementName}: ${numCabos} cordoalhas, ${comprimento.toFixed(2)}m, ${pesoProtensao.toFixed(2)}kg (dados IFC)`);
                } else {
                    // FALLBACK: calcular manualmente (menos preciso)
                    comprimento = calculateTendonLength(child.geometry, child.matrixWorld, sz);
                    
                    // 1. Buscar número de cabos nas propriedades do IFC
                    if (meta && meta.properties) {
                        const props = meta.properties;
                        const cabosKeys = [
                            'numberofstrands', 'strandcount', 'strands', 'numstrands',
                            'numcabos', 'numerodecabos', 'cordoalhas', 'ncordoalhas',
                            'quantity', 'count', 'number', 'cabos', 'ncabos'
                        ];
                        
                        for (const key of Object.keys(props)) {
                            const keyLower = key.toLowerCase();
                            if (cabosKeys.includes(keyLower) || keyLower.includes('cabo') || keyLower.includes('strand')) {
                                const val = parseInt(props[key]);
                                if (val >= 1 && val <= 31) {
                                    numCabos = val;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // 2. Tentar extrair do nome
                    if (numCabos === 1 && elementName) {
                        const patterns = [
                            /(\d+)\s*(?:c(?:abos?)?|cord(?:oalhas?)?)/i,
                            /feixe\s*[-:]?\s*(\d+)/i,
                            /[TF][-_]?(\d)C/i
                        ];
                        
                        for (const pattern of patterns) {
                            const match = elementName.match(pattern);
                            if (match) {
                                const val = parseInt(match[1]);
                                if (val >= 1 && val <= 31) {
                                    numCabos = val;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // 3. Determinar diâmetro
                    const minDim = Math.min(sz.x, sz.y, sz.z) * 1000;
                    if (minDim >= 14 && minDim <= 17) {
                        diametro = 15.2;
                    } else if (minDim >= 11 && minDim <= 14) {
                        diametro = 12.7;
                    } else {
                        diametro = 15.2;
                    }
                    
                    // 4. Calcular peso
                    const pesoPorMetro = diametro >= 15 ? 1.126 : 0.792;
                    pesoProtensao = comprimento * pesoPorMetro * numCabos;
                    
                    console.log(`[Tendon] ${elementName}: ${numCabos} cordoalhas, ${comprimento.toFixed(2)}m, ${pesoProtensao.toFixed(2)}kg (fallback)`);
                }
                
                // Volume = 0 para tendons (não é concreto)
                vol = 0;
                
            } else if (friendlyType === 'Laje') {
                // LAJE: calcular volume, área e classificar tipo
                vol = calculateMeshVolume(child.geometry, child.matrixWorld);
                area = calculateHorizontalArea(child.geometry, child.matrixWorld);
                if (area < 0.1) area = calculateSurfaceArea(child.geometry, child.matrixWorld) / 2;
                
                // Classificar tipo de laje (usando propriedades IFC e nome)
                const nomeLower = elementName.toLowerCase();
                
                // 1. Primeiro tentar pegar do IFC (propriedades Eberick ou Reference)
                if (meta && meta.properties) {
                    const props = meta.properties;
                    
                    // Buscar tipo e espessura nas propriedades do Eberick ou Reference
                    let tipoIFC = '';
                    for (const [key, val] of Object.entries(props)) {
                        const keyLower = key.toLowerCase();
                        const valStr = String(val || '').toLowerCase();
                        
                        // Espessura do Eberick (em cm)
                        if (keyLower === 'espessura' && typeof val === 'number') {
                            espessuraIFC = val / 100; // cm para m
                        }
                        
                        // Propriedade "Tipo" do Eberick
                        if (keyLower === 'tipo' && typeof val === 'string') {
                            tipoIFC = val;
                        }
                        // Reference do Pset_SlabCommon (ex: "Laje Maciça - h=10cm")
                        if (!tipoIFC && keyLower === 'reference' && valStr.includes('laje')) {
                            if (valStr.includes('maciça') || valStr.includes('macica')) tipoIFC = 'Maciça';
                            else if (valStr.includes('nervurada')) tipoIFC = 'Nervurada';
                            else if (valStr.includes('treliçada') || valStr.includes('trelicada')) tipoIFC = 'Treliçada';
                            else if (valStr.includes('alveolar')) tipoIFC = 'Alveolar';
                        }
                    }
                    
                    if (tipoIFC) {
                        const tipoLower = tipoIFC.toLowerCase();
                        if (tipoLower.includes('nervurada') || tipoLower.includes('treliç') || tipoLower.includes('trelic')) {
                            tipoLaje = 'Nervurada';
                        } else if (tipoLower.includes('maciça') || tipoLower.includes('macica')) {
                            tipoLaje = 'Maciça';
                        } else if (tipoLower.includes('alveolar') || tipoLower.includes('protendida')) {
                            tipoLaje = 'Alveolar';
                        } else if (tipoLower.includes('steel') || tipoLower.includes('deck')) {
                            tipoLaje = 'Steel Deck';
                        } else {
                            tipoLaje = tipoIFC; // Usar valor original
                        }
                    }
                }
                
                // 2. Se não encontrou no IFC, tentar pelo nome do elemento
                if (!tipoLaje) {
                    if (nomeLower.includes('trelicada 1d') || nomeLower.includes('treliçada 1d')) {
                        tipoLaje = 'Treliçada 1D';
                    } else if (nomeLower.includes('trelicada 2d') || nomeLower.includes('treliçada 2d')) {
                        tipoLaje = 'Treliçada 2D';
                    } else if (nomeLower.includes('nervurada') || nomeLower.includes('treliça') || 
                        nomeLower.includes('trelica') || nomeLower.includes('treliçada') || nomeLower.includes('trelicada')) {
                        tipoLaje = 'Nervurada';
                    } else if (nomeLower.includes('maciça') || nomeLower.includes('macica') || nomeLower.includes('solida')) {
                        tipoLaje = 'Maciça';
                    } else if (nomeLower.includes('alveolar') || nomeLower.includes('protendida')) {
                        tipoLaje = 'Alveolar';
                    } else if (nomeLower.includes('steel') || nomeLower.includes('deck') || nomeLower.includes('mista')) {
                        tipoLaje = 'Steel Deck';
                    } else {
                        tipoLaje = 'Laje'; // Genérico
                    }
                }
                
            } else {
                // OUTROS ELEMENTOS: calcular volume
                vol = calculateMeshVolume(child.geometry, child.matrixWorld);
            }

            // Para lajes, preferir espessura do IFC se disponível
            const alturaFinal = (friendlyType === 'Laje' && espessuraIFC > 0) ? espessuraIFC : altura;

            child.userData.info = {
                tipo: friendlyType, nome: elementName, guid: guid,
                storey: storey, elevation: elevation,
                volume: vol, area: area,
                comp: comprimento, larg: largura, alt: alturaFinal,
                tipoLaje: tipoLaje, diametro: diametro,
                numCabos: numCabos, pesoProtensao: pesoProtensao
            };
        }

        function loadModel() {
            return new Promise((resolve) => {
                if (MODEL_DATA_BASE64.startsWith("[[")) {
                    showError("Modelo não gerado corretamente (Placeholder encontrado).");
                    document.getElementById('loading-overlay').style.display = 'none';
                    resolve();
                    return;
                }

                try {
                    updateLoadingProgress(20, 'Decodificando modelo...');
                    const binStr = window.atob(MODEL_DATA_BASE64);
                    const len = binStr.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) bytes[i] = binStr.charCodeAt(i);

                    updateLoadingProgress(40, 'Carregando geometria...');
                    const loader = new THREE.GLTFLoader();
                    loader.parse(bytes.buffer, '', async (gltf) => {
                        loadedModel = gltf.scene;
                        
                        updateLoadingProgress(60, 'Processando elementos...');
                        await processNodesAsync(loadedModel);
                        
                        updateLoadingProgress(85, 'Configurando cena...');
                        scene.add(loadedModel);
                        const box = new THREE.Box3().setFromObject(loadedModel);
                        modelBounds = box;
                        initializeCutPlaneControls(box);
                        createCutPlane();
                        fitCamera(loadedModel);
                        
                        updateLoadingProgress(100, 'Concluído!');
                        resolve();
                    }, (err) => {
                        showError("Erro GLB: " + err.message);
                        resolve();
                    });
                } catch (e) {
                    showError("Erro Decode: " + e.message);
                    resolve();
                }
            });
        }


        function loadModelFromUrl(url) {
            return new Promise((resolve) => {
                try {
                    updateLoadingProgress(20, 'Baixando modelo...');
                    const loader = new THREE.GLTFLoader();

                    loader.load(
                        url,
                        async (gltf) => {
                            loadedModel = gltf.scene;

                            updateLoadingProgress(60, 'Processando elementos...');
                            await processNodesAsync(loadedModel);

                            updateLoadingProgress(85, 'Configurando cena...');
                            scene.add(loadedModel);
                            const box = new THREE.Box3().setFromObject(loadedModel);
                            modelBounds = box;
                            initializeCutPlaneControls(box);
                            createCutPlane();
                            fitCamera(loadedModel);

                            updateLoadingProgress(100, 'Concluído!');
                            resolve();
                        },
                        (xhr) => {
                            if (xhr && xhr.total) {
                                const pct = Math.round((xhr.loaded / xhr.total) * 100);
                                // Mapeia o download para 20%..55%
                                const mapped = 20 + Math.round(pct * 0.35);
                                updateLoadingProgress(mapped, `Baixando modelo... ${pct}%`);
                            }
                        },
                        (err) => {
                            const msg = (err && err.message) ? err.message : String(err || '');
                            showError('Erro ao carregar model.glb: ' + msg);
                            resolve();
                        }
                    );
                } catch (e) {
                    showError('Erro ao carregar model.glb: ' + (e.message || e));
                    resolve();
                }
            });
        }






        function createExampleModel() {
            const group = new THREE.Group();

            // Pilares
            const pilarGeo = new THREE.BoxGeometry(0.3, 3, 0.3);
            const pilarMat = new THREE.MeshStandardMaterial({ color: 0x888888 });

            const pilarPositions = [
                [-3, 1.5, -3], [3, 1.5, -3], [-3, 1.5, 3], [3, 1.5, 3],
                [0, 1.5, -3], [0, 1.5, 3], [-3, 1.5, 0], [3, 1.5, 0]
            ];

            pilarPositions.forEach((pos, i) => {
                const pilar = new THREE.Mesh(pilarGeo.clone(), pilarMat.clone());
                pilar.position.set(...pos);
                pilar.name = `P${i + 1}`;
                pilar.userData.info = {
                    nome: `P${i + 1}`,
                    tipo: 'Pilar',
                    comp: 0.3,
                    larg: 0.3,
                    alt: 3,
                    volume: 0.27,
                    area: 0
                };
                addEdges(pilar);
                group.add(pilar);
            });

            // Vigas
            const vigaMat = new THREE.MeshStandardMaterial({ color: 0x999999 });

            const vigaConfigs = [
                { name: 'V1', start: [-3, 3, -3], end: [3, 3, -3], height: 0.5, width: 0.2 },
                { name: 'V2', start: [-3, 3, 3], end: [3, 3, 3], height: 0.5, width: 0.2 },
                { name: 'V3', start: [-3, 3, -3], end: [-3, 3, 3], height: 0.5, width: 0.2 },
                { name: 'V4', start: [3, 3, -3], end: [3, 3, 3], height: 0.5, width: 0.2 },
                { name: 'V5', start: [0, 3, -3], end: [0, 3, 3], height: 0.5, width: 0.2 }
            ];

            vigaConfigs.forEach(config => {
                const length = Math.sqrt(
                    Math.pow(config.end[0] - config.start[0], 2) +
                    Math.pow(config.end[2] - config.start[2], 2)
                );
                const vigaGeo = new THREE.BoxGeometry(config.width, config.height, length);
                const viga = new THREE.Mesh(vigaGeo, vigaMat.clone());

                const midX = (config.start[0] + config.end[0]) / 2;
                const midZ = (config.start[2] + config.end[2]) / 2;
                viga.position.set(midX, config.start[1] - config.height / 2, midZ);

                if (config.start[0] === config.end[0]) {
                    viga.rotation.y = Math.PI / 2;
                }

                viga.name = config.name;
                viga.userData.info = {
                    nome: config.name,
                    tipo: 'Viga',
                    comp: length,
                    larg: config.width,
                    alt: config.height,
                    volume: length * config.width * config.height,
                    area: 0
                };
                addEdges(viga);
                group.add(viga);
            });

            // Laje
            const lajeGeo = new THREE.BoxGeometry(6.4, 0.12, 6.4);
            const lajeMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const laje = new THREE.Mesh(lajeGeo, lajeMat);
            laje.position.set(0, 3.06, 0);
            laje.name = 'L1';
            laje.userData.info = {
                nome: 'L1 - Laje Cobertura',
                tipo: 'Laje',
                comp: 6.4,
                larg: 6.4,
                alt: 0.12,
                volume: 6.4 * 6.4 * 0.12,
                area: 6.4 * 6.4
            };
            addEdges(laje);
            group.add(laje);

            // Sapatas
            const sapataGeo = new THREE.BoxGeometry(0.8, 0.3, 0.8);
            const sapataMat = new THREE.MeshStandardMaterial({ color: 0x666666 });

            pilarPositions.forEach((pos, i) => {
                const sapata = new THREE.Mesh(sapataGeo.clone(), sapataMat.clone());
                sapata.position.set(pos[0], -0.15, pos[2]);
                sapata.name = `S${i + 1}`;
                sapata.userData.info = {
                    nome: `S${i + 1}`,
                    tipo: 'Fundação',
                    comp: 0.8,
                    larg: 0.8,
                    alt: 0.3,
                    volume: 0.8 * 0.8 * 0.3,
                    area: 0
                };
                addEdges(sapata);
                group.add(sapata);
            });

            loadedModel = group;
            scene.add(group);

            const box = new THREE.Box3().setFromObject(group);
            modelBounds = box;

            initializeCutPlaneControls(box);
            createCutPlane();
            fitCamera(group);

            // Store original materials
            group.traverse((node) => {
                if (node.isMesh) {
                    originalMaterials.set(node.uuid, node.material.clone());
                }
            });
        }

        function addEdges(mesh) {
            const edges = new THREE.EdgesGeometry(mesh.geometry, 15);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333 }));
            mesh.add(line);
        }


        function getVolume(geometry) {
            if (!geometry.isBufferGeometry) return 0;
            let vol = 0;
            const pos = geometry.attributes.position;
            const index = geometry.index;
            if (!index) return 0;
            const p1 = new THREE.Vector3(), p2 = new THREE.Vector3(), p3 = new THREE.Vector3();
            for (let i = 0; i < index.count; i += 3) {
                p1.fromBufferAttribute(pos, index.getX(i));
                p2.fromBufferAttribute(pos, index.getX(i + 1));
                p3.fromBufferAttribute(pos, index.getX(i + 2));
                vol += p1.dot(p2.clone().cross(p3)) / 6.0;
            }
            return Math.abs(vol);
        }

        function getTopArea(geometry) {
            if (!geometry.isBufferGeometry) return 0;
            let area = 0;
            const pos = geometry.attributes.position;
            const index = geometry.index;
            if (!index) return 0;
            const p1 = new THREE.Vector3(), p2 = new THREE.Vector3(), p3 = new THREE.Vector3();
            const edge1 = new THREE.Vector3(), edge2 = new THREE.Vector3(), faceNormal = new THREE.Vector3();

            for (let i = 0; i < index.count; i += 3) {
                p1.fromBufferAttribute(pos, index.getX(i));
                p2.fromBufferAttribute(pos, index.getX(i + 1));
                p3.fromBufferAttribute(pos, index.getX(i + 2));
                edge1.subVectors(p2, p1);
                edge2.subVectors(p3, p1);
                faceNormal.crossVectors(edge1, edge2);
                const area2 = faceNormal.length();
                faceNormal.normalize();
                if (faceNormal.y > 0.7) {
                    area += area2 / 2.0;
                }
            }
            return area;
        }

        function fitCamera(model) {
            const box = new THREE.Box3().setFromObject(model);
            if (box.isEmpty()) return;
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            model.position.sub(center);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5;
            if (cameraZ < 5) cameraZ = 5;
            camera.position.set(cameraZ * 0.8, cameraZ * 0.6, cameraZ * 0.8);
            camera.lookAt(0, 0, 0);
            controls.maxDistance = size.length() * 10;
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // ==========================================
        // CUT PLANE
        // ==========================================
        function initializeCutPlaneControls(box) {
            const slider = document.getElementById('input-cut-height-slider');
            if (slider && isFinite(box.min.y) && isFinite(box.max.y)) {
                const buffer = Math.max((box.max.y - box.min.y) * 0.1, 0.5);
                slider.min = Math.floor(box.min.y - buffer);
                slider.max = Math.ceil(box.max.y + buffer);
                const mid = (box.min.y + box.max.y) / 2;
                slider.value = mid.toFixed(2);
                manualCutHeight = mid;
            }
        }

        function createCutPlane() {
            if (cutPlaneMesh) scene.remove(cutPlaneMesh);
            if (cutPlaneHelper) scene.remove(cutPlaneHelper);
            cutPlaneMesh = null;
            cutPlaneHelper = null;

            const _cutToggle = document.getElementById('toggle-cut-plane');
            const showCutPlane = _cutToggle ? _cutToggle.checked : false;
            if (!showCutPlane || !modelBounds) return;

            const planeSize = Math.max(
                modelBounds.max.x - modelBounds.min.x,
                modelBounds.max.z - modelBounds.min.z
            ) * 1.3;

            const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0x007AFF,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            cutPlaneMesh = new THREE.Mesh(planeGeo, planeMat);
            cutPlaneMesh.rotation.x = -Math.PI / 2;
            cutPlaneMesh.position.y = manualCutHeight;

            const edges = new THREE.EdgesGeometry(planeGeo);
            const borderMat = new THREE.LineBasicMaterial({ color: 0x007AFF });
            cutPlaneHelper = new THREE.LineSegments(edges, borderMat);
            cutPlaneHelper.rotation.x = -Math.PI / 2;
            cutPlaneHelper.position.y = manualCutHeight + 0.001;

            scene.add(cutPlaneMesh);
            scene.add(cutPlaneHelper);
        }

        function toggleCutPlaneVisibility() {
            createCutPlane();
        }

        function updateCutHeight(value) {
            manualCutHeight = parseFloat(value);
            document.getElementById('input-cut-height-slider').value = value;

            createCutPlane();

            if (isPlanViewActive) {
                planCache.needsUpdate = true;
                drawFloorPlanOptimized();
            }
        }

        // ==========================================
        // TRANSPARENCY
        // ==========================================
        function updateTransparency(value) {
            globalTransparency = 1 - value;
            if (!loadedModel) return;

            loadedModel.traverse((node) => {
                if (node.isMesh && originalMaterials.has(node.uuid)) {
                    const origMat = originalMaterials.get(node.uuid);
                    if (node !== selectedObject) {
                        node.material = origMat.clone();
                        node.material.transparent = globalTransparency < 1;
                        node.material.opacity = globalTransparency;
                    }
                }
            });
        }

        // ==========================================
        // VIEWCUBE
        // ==========================================
        function setupViewCube() {
            const canvas = document.getElementById('viewcube-canvas');
            const container = document.getElementById('viewcube-container');

            viewCubeScene = new THREE.Scene();
            viewCubeCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            viewCubeCamera.position.set(0, 0, 3);

            viewCubeRenderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            viewCubeRenderer.setSize(container.clientWidth, container.clientHeight);
            viewCubeRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));

            const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                createFaceMaterial('D'), createFaceMaterial('E'),
                createFaceMaterial('CIMA'), createFaceMaterial('BAIXO'),
                createFaceMaterial('F'), createFaceMaterial('T')
            ];
            viewCubeMesh = new THREE.Mesh(cubeGeo, materials);
            viewCubeScene.add(viewCubeMesh);

            const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
            viewCubeScene.add(ambLight);

            canvas.addEventListener('click', onViewCubeClick);
            canvas.addEventListener('mousemove', onViewCubeHover);
        }

        function createFaceMaterial(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, 128, 128);
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, 126, 126);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshLambertMaterial({ map: texture });
        }

        function onViewCubeClick(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            viewCubeMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            viewCubeMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            viewCubeRaycaster.setFromCamera(viewCubeMouse, viewCubeCamera);
            const intersects = viewCubeRaycaster.intersectObject(viewCubeMesh);
            if (intersects.length > 0 && intersects[0].face) {
                orientCameraToFace(intersects[0].face.materialIndex);
            }
        }

        function onViewCubeHover(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            viewCubeMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            viewCubeMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            viewCubeRaycaster.setFromCamera(viewCubeMouse, viewCubeCamera);
            const intersects = viewCubeRaycaster.intersectObject(viewCubeMesh);
            canvas.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
            viewCubeMesh.scale.setScalar(intersects.length > 0 ? 1.05 : 1);
        }

        function orientCameraToFace(faceIndex) {
            if (isAnimatingCamera) return;
            const distance = camera.position.length();
            let targetPosition = new THREE.Vector3();
            switch (faceIndex) {
                case 0: targetPosition.set(distance, 0, 0); break;
                case 1: targetPosition.set(-distance, 0, 0); break;
                case 2: targetPosition.set(0, distance, 0); break;
                case 3: targetPosition.set(0, -distance, 0); break;
                case 4: targetPosition.set(0, 0, distance); break;
                case 5: targetPosition.set(0, 0, -distance); break;
            }
            animateCameraTo(targetPosition);
        }

        function animateCameraTo(targetPosition, lookAtTarget) {
            if (isAnimatingCamera) return;
            isAnimatingCamera = true;
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endTarget = lookAtTarget || new THREE.Vector3(0, 0, 0);
            const duration = 500;
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);

                camera.position.lerpVectors(startPosition, targetPosition, eased);
                controls.target.lerpVectors(startTarget, endTarget, eased);
                camera.lookAt(controls.target);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isAnimatingCamera = false;
                }
            }
            animate();
        }

        function updateViewCube() {
            if (!viewCubeMesh || !camera) return;
            const quaternion = camera.quaternion.clone().invert();
            viewCubeMesh.setRotationFromQuaternion(quaternion);
            viewCubeRenderer.render(viewCubeScene, viewCubeCamera);
        }

        // ==========================================
        // MEASUREMENT
        // ==========================================
        function setupMeasurementVisuals() {
            const geometry = new THREE.SphereGeometry(0.05, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false, transparent: true, opacity: 0.9 });
            measureMarker = new THREE.Mesh(geometry, material);
            measureMarker.renderOrder = 999;
            measureMarker.visible = false;
            scene.add(measureMarker);

            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2, depthTest: false });
            measureLine = new THREE.Line(lineGeo, lineMat);
            measureLine.renderOrder = 998;
            measureLine.visible = false;
            scene.add(measureLine);
            
            // Grupo para linhas de medição permanentes
            measureLinesGroup = new THREE.Group();
            measureLinesGroup.renderOrder = 997;
            scene.add(measureLinesGroup);
        }

        function toggleMeasure() {
            isMeasuring = !isMeasuring;
            const btn = document.getElementById('btn-measure-tool');

            if (isMeasuring) {
                btn.classList.add('active');
                renderer.domElement.style.cursor = 'crosshair';
                measureStep = 0;
                const orthoStatus = isOrthoMode ? ' | ORTHO: ON' : '';
                const snapStatus = snapEnabled ? ' | SNAP: ON' : '';
                showToast('📏 Modo medição ativo' + orthoStatus + snapStatus);
            } else {
                btn.classList.remove('active');
                renderer.domElement.style.cursor = 'default';
                resetMeasurement();
            }
        }
        
        function toggleOrtho() {
            isOrthoMode = !isOrthoMode;
            const btn = document.getElementById('btn-ortho');
            if (isOrthoMode) {
                btn.classList.add('active');
                showToast('⊥ ORTHO ativado');
            } else {
                btn.classList.remove('active');
                showToast('⊥ ORTHO desativado');
            }
        }
        
        function toggleSnap() {
            snapEnabled = !snapEnabled;
            const btn = document.getElementById('btn-snap');
            if (snapEnabled) {
                btn.classList.add('active');
                showToast('🎯 SNAP ativado');
            } else {
                btn.classList.remove('active');
                showToast('🎯 SNAP desativado');
            }
        }
        
        function clearMeasurements() {
            // Limpar linhas de medição permanentes
            if (measureLinesGroup) {
                while (measureLinesGroup.children.length > 0) {
                    measureLinesGroup.remove(measureLinesGroup.children[0]);
                }
            }
            // Limpar labels
            measureLabels.forEach(lbl => {
                if (lbl.parentNode) lbl.parentNode.removeChild(lbl);
            });
            measureLabels = [];
            resetMeasurement();
            showToast('🗑️ Medições limpas');
        }
        
        function addPermanentMeasurement(start, end, distance) {
            // Criar linha permanente estilo AutoCAD
            const points = [start.clone(), end.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00aaff, 
                linewidth: 2, 
                depthTest: false 
            });
            const line = new THREE.Line(geometry, material);
            line.renderOrder = 997;
            measureLinesGroup.add(line);
            
            // Criar marcadores nos pontos
            const markerGeo = new THREE.SphereGeometry(0.03, 8, 8);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, depthTest: false });
            
            const marker1 = new THREE.Mesh(markerGeo, markerMat);
            marker1.position.copy(start);
            marker1.renderOrder = 998;
            measureLinesGroup.add(marker1);
            
            const marker2 = new THREE.Mesh(markerGeo, markerMat);
            marker2.position.copy(end);
            marker2.renderOrder = 998;
            measureLinesGroup.add(marker2);
            
            // Criar label HTML permanente
            const midpoint = start.clone().add(end).multiplyScalar(0.5);
            const label = document.createElement('div');
            label.className = 'measure-label-permanent';
            label.innerHTML = distance.toFixed(3) + ' m';
            label.style.cssText = 'position:fixed;background:#00aaff;color:white;padding:2px 6px;border-radius:3px;font-size:11px;font-weight:bold;pointer-events:none;z-index:1000;box-shadow:0 1px 3px rgba(0,0,0,0.3);';
            document.body.appendChild(label);
            measureLabels.push(label);
            
            // Atualizar posição do label no render
            label.userData = { worldPos: midpoint };
        }
        
        function updateMeasureLabels() {
            measureLabels.forEach(label => {
                if (label.userData && label.userData.worldPos) {
                    const pos = label.userData.worldPos.clone();
                    pos.project(camera);
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = (pos.x * 0.5 + 0.5) * rect.width + rect.left;
                    const y = (-pos.y * 0.5 + 0.5) * rect.height + rect.top;
                    
                    if (pos.z < 1) {
                        label.style.display = 'block';
                        label.style.left = x + 'px';
                        label.style.top = y + 'px';
                    } else {
                        label.style.display = 'none';
                    }
                }
            });
        }
        
        function applyOrtho(start, end) {
            if (!isOrthoMode) return end;
            
            const dx = Math.abs(end.x - start.x);
            const dy = Math.abs(end.y - start.y);
            const dz = Math.abs(end.z - start.z);
            
            const result = end.clone();
            
            // Encontrar o eixo dominante
            if (dx >= dy && dx >= dz) {
                // Movimento em X
                result.y = start.y;
                result.z = start.z;
            } else if (dy >= dx && dy >= dz) {
                // Movimento em Y
                result.x = start.x;
                result.z = start.z;
            } else {
                // Movimento em Z
                result.x = start.x;
                result.y = start.y;
            }
            
            return result;
        }

        function resetMeasurement() {
            measureStep = 0;
            measureMarker.visible = false;
            measureLine.visible = false;
            document.getElementById('measure-label').style.display = 'none';
        }

        function getClosestVertex(intersects) {
            const hit = intersects.find(i => i.object.isMesh && i.object !== measureMarker && !measureLinesGroup.children.includes(i.object));
            if (!hit) return null;
            
            // Se SNAP desativado, retornar ponto de interseção
            if (!snapEnabled) {
                return hit.point.clone();
            }

            const mesh = hit.object;
            const geo = mesh.geometry;
            const pos = geo.attributes.position;
            
            // Buscar em TODOS os vértices, não só na face clicada
            let minDist = Infinity;
            let closestLocal = new THREE.Vector3();
            const localPoint = hit.point.clone();
            mesh.worldToLocal(localPoint);
            
            // Threshold para snap (em unidades locais)
            const snapThreshold = 0.5;

            for (let i = 0; i < pos.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                const d = v.distanceTo(localPoint);
                if (d < minDist && d < snapThreshold) {
                    minDist = d;
                    closestLocal.copy(v);
                }
            }
            
            // Se não encontrou vértice próximo, usar ponto de interseção
            if (minDist === Infinity) {
                return hit.point.clone();
            }

            const closestWorld = closestLocal.clone();
            mesh.localToWorld(closestWorld);
            return closestWorld;
        }

        // ==========================================
        // FLOOR PLAN
        // ==========================================
        
        // Variáveis para arrastar a janela da planta
        let planWindowDragging = false;
        let planWindowOffsetX = 0;
        let planWindowOffsetY = 0;
        
        function setupPlanCanvas() {
            planCanvas = document.getElementById('plan-view-canvas');
            planCtx = planCanvas.getContext('2d');

            planCanvas.addEventListener('wheel', onPlanWheel, { passive: false });
            planCanvas.addEventListener('mousedown', onPlanMouseDown);
            planCanvas.addEventListener('mousemove', onPlanMouseMove);
            planCanvas.addEventListener('mouseup', onPlanMouseUp);
            planCanvas.addEventListener('mouseleave', onPlanMouseUp);
            planCanvas.addEventListener('dblclick', onPlanDoubleClick);
            
            // Configurar arrastar da janela pelo header
            const planHeader = document.querySelector('.plan-header');
            const planContainer = document.getElementById('plan-view-container');
            
            if (planHeader && planContainer) {
                planHeader.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON') return; // Ignorar cliques em botões
                    planWindowDragging = true;
                    const rect = planContainer.getBoundingClientRect();
                    planWindowOffsetX = e.clientX - rect.left;
                    planWindowOffsetY = e.clientY - rect.top;
                    planHeader.style.cursor = 'grabbing';
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!planWindowDragging) return;
                    const newX = e.clientX - planWindowOffsetX;
                    const newY = e.clientY - planWindowOffsetY;
                    
                    // Limitar dentro da viewport
                    const maxX = window.innerWidth - planContainer.offsetWidth;
                    const maxY = window.innerHeight - planContainer.offsetHeight;
                    
                    planContainer.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
                    planContainer.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';
                    planContainer.style.right = 'auto';
                    planContainer.style.bottom = 'auto';
                });
                
                document.addEventListener('mouseup', () => {
                    if (planWindowDragging) {
                        planWindowDragging = false;
                        planHeader.style.cursor = 'move';
                    }
                });
            }
            
            // Observer para redimensionamento
            let resizeObserver = null;
            const _handlePlanResize = function() {
                if (isPlanViewActive && planCanvas) {
                    const wrapper = planCanvas.parentElement;
                    if (wrapper) {
                        planCanvas.width = wrapper.clientWidth;
                        planCanvas.height = wrapper.clientHeight;
                        planCache.needsUpdate = true;
                        drawFloorPlanOptimized();
                    }
                }
            };

            if (typeof ResizeObserver !== 'undefined') {
                resizeObserver = new ResizeObserver(_handlePlanResize);
                const canvasWrapper = document.getElementById('plan-canvas-wrapper');
                if (canvasWrapper) {
                    resizeObserver.observe(canvasWrapper);
                }
            } else {
                // Fallback para Safari antigo
                window.addEventListener('resize', _handlePlanResize);
            }
        }

        function togglePlanView() {
            const container = document.getElementById('plan-view-container');
            const btn = document.getElementById('btn-toggle-plan');
            isPlanViewActive = !isPlanViewActive;

            if (isPlanViewActive) {
                container.style.display = 'block';
                planCanvas.width = planCanvas.parentElement.clientWidth;
                planCanvas.height = planCanvas.parentElement.clientHeight;
                btn.innerHTML = '🧱 Fechar Planta';
                planCache.needsUpdate = true;
                resetPlanView();
                drawFloorPlanOptimized();
            } else {
                container.style.display = 'none';
                btn.innerHTML = '🧱 Abrir Planta de Forma';
            }
        }

        function resetPlanView() {
            planTransform.scale = 1;
            planTransform.offsetX = 0;
            planTransform.offsetY = 0;
            planCache.needsUpdate = true;
            if (isPlanViewActive) drawFloorPlanOptimized();
        }

        function drawFloorPlanOptimized() {
            if (!planCanvas || !planCtx || !loadedModel) return;

            planCtx.fillStyle = '#ffffff';
            planCtx.fillRect(0, 0, planCanvas.width, planCanvas.height);

            // Calculate bounds
            if (planCache.needsUpdate) {
                planCache.elements = [];
                const bounds = { minX: Infinity, maxX: -Infinity, minZ: Infinity, maxZ: -Infinity };

                loadedModel.traverse((node) => {
                    if (node.isMesh && node.visible && node.userData.info) {
                        const box = new THREE.Box3().setFromObject(node);

                        if (box.min.y <= manualCutHeight && box.max.y >= manualCutHeight - 0.5) {
                            bounds.minX = Math.min(bounds.minX, box.min.x);
                            bounds.maxX = Math.max(bounds.maxX, box.max.x);
                            bounds.minZ = Math.min(bounds.minZ, box.min.z);
                            bounds.maxZ = Math.max(bounds.maxZ, box.max.z);

                            planCache.elements.push({
                                node: node,
                                box: box,
                                info: node.userData.info,
                                isBelow: box.max.y < manualCutHeight
                            });
                        }
                    }
                });

                if (bounds.minX === Infinity) {
                    bounds.minX = -10; bounds.maxX = 10;
                    bounds.minZ = -10; bounds.maxZ = 10;
                }

                planCache.lastBounds = bounds;
                planCache.needsUpdate = false;
            }

            const bounds = planCache.lastBounds;
            if (!bounds) return;

            drawGrid(bounds);

            // Draw elements
            planCache.elements.forEach(elem => {
                drawPlanElement(elem, bounds);
            });

            drawMeasurements();
            drawLegend();
            updatePlanInfo();
        }

        function drawGrid(bounds) {
            const padding = 30;
            const worldWidth = bounds.maxX - bounds.minX;
            const worldHeight = bounds.maxZ - bounds.minZ;
            const scale = Math.min(
                (planCanvas.width - padding * 2) / worldWidth,
                (planCanvas.height - padding * 2) / worldHeight
            ) * planTransform.scale;

            planCtx.strokeStyle = '#e8e8e8';
            planCtx.lineWidth = 0.5;

            const gridSize = worldWidth > 20 ? 5 : worldWidth > 10 ? 2 : 1;

            for (let x = Math.floor(bounds.minX / gridSize) * gridSize; x <= bounds.maxX; x += gridSize) {
                const canvasX = worldToCanvasX(x, bounds);
                if (canvasX >= 0 && canvasX <= planCanvas.width) {
                    planCtx.beginPath();
                    planCtx.moveTo(canvasX, 0);
                    planCtx.lineTo(canvasX, planCanvas.height);
                    planCtx.stroke();
                }
            }

            for (let z = Math.floor(bounds.minZ / gridSize) * gridSize; z <= bounds.maxZ; z += gridSize) {
                const canvasZ = worldToCanvasZ(z, bounds);
                if (canvasZ >= 0 && canvasZ <= planCanvas.height) {
                    planCtx.beginPath();
                    planCtx.moveTo(0, canvasZ);
                    planCtx.lineTo(planCanvas.width, canvasZ);
                    planCtx.stroke();
                }
            }
        }

        function worldToCanvasX(worldX, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxX - bounds.minX;
            const worldHeight = bounds.maxZ - bounds.minZ;
            const baseScale = Math.min(
                (planCanvas.width - padding * 2) / worldWidth,
                (planCanvas.height - padding * 2) / worldHeight
            );
            const centerX = planCanvas.width / 2;
            const worldCenterX = (bounds.minX + bounds.maxX) / 2;
            return centerX + (worldX - worldCenterX) * baseScale * planTransform.scale + planTransform.offsetX;
        }

        function worldToCanvasZ(worldZ, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxX - bounds.minX;
            const worldHeight = bounds.maxZ - bounds.minZ;
            const baseScale = Math.min(
                (planCanvas.width - padding * 2) / worldWidth,
                (planCanvas.height - padding * 2) / worldHeight
            );
            const centerZ = planCanvas.height / 2;
            const worldCenterZ = (bounds.minZ + bounds.maxZ) / 2;
            return centerZ + (worldZ - worldCenterZ) * baseScale * planTransform.scale + planTransform.offsetY;
        }

        function canvasToWorldX(canvasX, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxX - bounds.minX;
            const worldHeight = bounds.maxZ - bounds.minZ;
            const baseScale = Math.min(
                (planCanvas.width - padding * 2) / worldWidth,
                (planCanvas.height - padding * 2) / worldHeight
            );
            const centerX = planCanvas.width / 2;
            const worldCenterX = (bounds.minX + bounds.maxX) / 2;
            return (canvasX - centerX - planTransform.offsetX) / (baseScale * planTransform.scale) + worldCenterX;
        }

        function canvasToWorldZ(canvasZ, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxX - bounds.minX;
            const worldHeight = bounds.maxZ - bounds.minZ;
            const baseScale = Math.min(
                (planCanvas.width - padding * 2) / worldWidth,
                (planCanvas.height - padding * 2) / worldHeight
            );
            const centerZ = planCanvas.height / 2;
            const worldCenterZ = (bounds.minZ + bounds.maxZ) / 2;
            return (canvasZ - centerZ - planTransform.offsetY) / (baseScale * planTransform.scale) + worldCenterZ;
        }

        function drawPlanElement(elem, bounds) {
            const box = elem.box;
            const info = elem.info;
            const tipo = info.tipo;
            const node = elem.node;

            const x1 = worldToCanvasX(box.min.x, bounds);
            const z1 = worldToCanvasZ(box.min.z, bounds);
            const x2 = worldToCanvasX(box.max.x, bounds);
            const z2 = worldToCanvasZ(box.max.z, bounds);

            const width = x2 - x1;
            const height = z2 - z1;

            const style = getTypeStyle(tipo, elem.isBelow);
            
            // Detectar se é elemento circular
            const isCircular = detectCircularElement(node, box, info);
            
            // Obter contorno projetado para elementos inclinados
            const projectedContour = getProjectedContourXZ(node, bounds);

            // Fill
            planCtx.fillStyle = style.fill;
            planCtx.globalAlpha = style.opacity || 1;
            
            if (isCircular) {
                // Desenhar círculo
                const centerX = (x1 + x2) / 2;
                const centerZ = (z1 + z2) / 2;
                const radius = Math.min(width, height) / 2;
                
                if (style.fill !== 'transparent') {
                    planCtx.beginPath();
                    planCtx.arc(centerX, centerZ, radius, 0, Math.PI * 2);
                    planCtx.fill();
                }
                
                // Hatch para pilares circulares
                if (style.pattern === 'hatch' && !elem.isBelow) {
                    drawCircularHatch(centerX, centerZ, radius);
                }
                
                // Stroke
                planCtx.strokeStyle = style.stroke;
                planCtx.lineWidth = style.lineWidth;
                if (elem.isBelow) {
                    planCtx.setLineDash([4, 2]);
                    planCtx.globalAlpha = 0.5;
                } else {
                    planCtx.setLineDash([]);
                }
                
                if (planSelectedLine && planSelectedLine.node === node) {
                    planCtx.strokeStyle = '#007AFF';
                    planCtx.lineWidth = 3;
                }
                
                planCtx.beginPath();
                planCtx.arc(centerX, centerZ, radius, 0, Math.PI * 2);
                planCtx.stroke();
                
            } else if (projectedContour && projectedContour.length > 2) {
                // Desenhar polígono projetado (para elementos inclinados)
                if (style.fill !== 'transparent') {
                    planCtx.beginPath();
                    planCtx.moveTo(projectedContour[0].x, projectedContour[0].z);
                    for (let i = 1; i < projectedContour.length; i++) {
                        planCtx.lineTo(projectedContour[i].x, projectedContour[i].z);
                    }
                    planCtx.closePath();
                    planCtx.fill();
                }
                
                // Hatch para pilares
                if (style.pattern === 'hatch' && !elem.isBelow) {
                    drawPolygonHatch(projectedContour);
                }
                
                // Stroke
                planCtx.strokeStyle = style.stroke;
                planCtx.lineWidth = style.lineWidth;
                if (elem.isBelow) {
                    planCtx.setLineDash([4, 2]);
                    planCtx.globalAlpha = 0.5;
                } else {
                    planCtx.setLineDash([]);
                }
                
                if (planSelectedLine && planSelectedLine.node === node) {
                    planCtx.strokeStyle = '#007AFF';
                    planCtx.lineWidth = 3;
                }
                
                planCtx.beginPath();
                planCtx.moveTo(projectedContour[0].x, projectedContour[0].z);
                for (let i = 1; i < projectedContour.length; i++) {
                    planCtx.lineTo(projectedContour[i].x, projectedContour[i].z);
                }
                planCtx.closePath();
                planCtx.stroke();
                
            } else {
                // Desenhar retângulo padrão
                if (style.fill !== 'transparent') {
                    planCtx.fillRect(x1, z1, width, height);
                }

                // Hatch pattern for pilares
                if (style.pattern === 'hatch' && !elem.isBelow) {
                    drawHatchPattern(x1, z1, width, height);
                }

                // Stroke
                planCtx.strokeStyle = style.stroke;
                planCtx.lineWidth = style.lineWidth;
                if (elem.isBelow) {
                    planCtx.setLineDash([4, 2]);
                    planCtx.globalAlpha = 0.5;
                } else {
                    planCtx.setLineDash([]);
                }

                // Highlight selected
                if (planSelectedLine && planSelectedLine.node === node) {
                    planCtx.strokeStyle = '#007AFF';
                    planCtx.lineWidth = 3;
                }

                planCtx.strokeRect(x1, z1, width, height);
            }
            
            planCtx.setLineDash([]);
            planCtx.globalAlpha = 1;

            // Label
            const labelX = isCircular || projectedContour ? (x1 + x2) / 2 : x1 + width / 2;
            const labelZ = isCircular || projectedContour ? (z1 + z2) / 2 : z1 + height / 2;
            if (width > 20 && height > 15 && !elem.isBelow) {
                planCtx.fillStyle = '#333';
                planCtx.font = '10px Arial';
                planCtx.textAlign = 'center';
                planCtx.textBaseline = 'middle';
                const label = info.nome.length > 8 ? info.nome.substring(0, 8) : info.nome;
                planCtx.fillText(label, labelX, labelZ);
            }

            // Store for selection
            planLines.push({
                node: node,
                bounds: { minX: x1, maxX: x2, minZ: z1, maxZ: z2 }
            });
        }
        
        // Detecta se um elemento é circular baseado na geometria
        function detectCircularElement(node, box, info) {
            if (!node || !node.geometry) return false;
            
            // Verificar pelo nome - precisa ter indicação clara de circular
            const nome = (info.nome || '').toLowerCase();
            if (nome.includes('circular') || nome.includes('cilind') || nome.includes('ø') || 
                nome.includes('tubo') || nome.includes('pipe')) {
                return true;
            }
            
            // Verificar se é estaca (geralmente circular) - mas precisa ser quadrada
            if (info.tipo === 'Estaca') {
                const sizeX = box.max.x - box.min.x;
                const sizeZ = box.max.z - box.min.z;
                const ratio = Math.min(sizeX, sizeZ) / Math.max(sizeX, sizeZ);
                // Precisa ser muito próximo de 1:1 para ser circular
                if (ratio > 0.95) return true;
            }
            
            // Para outros elementos, NÃO detectar como circular baseado na geometria
            // pois isso está gerando falsos positivos
            return false;
        }
        
        // Obtém o contorno projetado no plano XZ (para planta)
        function getProjectedContourXZ(node, bounds) {
            if (!node || !node.geometry) return null;
            
            const geometry = node.geometry;
            if (!geometry.attributes || !geometry.attributes.position) return null;
            
            const positions = geometry.attributes.position;
            const points = [];
            const vertex = new THREE.Vector3();
            
            // Coletar vértices transformados
            for (let i = 0; i < positions.count; i++) {
                vertex.fromBufferAttribute(positions, i);
                vertex.applyMatrix4(node.matrixWorld);
                points.push({ x: vertex.x, z: vertex.z });
            }
            
            if (points.length < 3) return null;
            
            // Calcular convex hull para obter contorno
            const hull = computeConvexHull2D(points);
            
            if (!hull || hull.length < 3) return null;
            
            // Converter para coordenadas do canvas
            return hull.map(p => ({
                x: worldToCanvasX(p.x, bounds),
                z: worldToCanvasZ(p.z, bounds)
            }));
        }
        
        // Calcula o convex hull 2D (algoritmo Gift Wrapping simplificado)
        function computeConvexHull2D(points) {
            if (points.length < 3) return points;
            
            // Encontrar ponto mais à esquerda
            let leftmost = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].x < points[leftmost].x) {
                    leftmost = i;
                }
            }
            
            const hull = [];
            let current = leftmost;
            let iterations = 0;
            const maxIterations = Math.min(points.length, 50); // Limitar para performance
            
            do {
                hull.push(points[current]);
                let next = 0;
                
                for (let i = 1; i < points.length; i++) {
                    if (next === current) {
                        next = i;
                        continue;
                    }
                    
                    // Cross product para determinar lado
                    const cross = (points[i].x - points[current].x) * (points[next].z - points[current].z) -
                                  (points[i].z - points[current].z) * (points[next].x - points[current].x);
                    
                    if (cross > 0) {
                        next = i;
                    }
                }
                
                current = next;
                iterations++;
                
            } while (current !== leftmost && iterations < maxIterations);
            
            return hull;
        }
        
        // Desenha hachura em círculo
        function drawCircularHatch(cx, cz, radius) {
            planCtx.save();
            planCtx.beginPath();
            planCtx.arc(cx, cz, radius, 0, Math.PI * 2);
            planCtx.clip();
            planCtx.strokeStyle = '#666';
            planCtx.lineWidth = 0.5;
            const spacing = 4;
            for (let i = -radius * 2; i < radius * 2; i += spacing) {
                planCtx.beginPath();
                planCtx.moveTo(cx + i - radius, cz - radius);
                planCtx.lineTo(cx + i + radius, cz + radius);
                planCtx.stroke();
            }
            planCtx.restore();
        }
        
        // Desenha hachura em polígono
        function drawPolygonHatch(contour) {
            if (!contour || contour.length < 3) return;
            
            planCtx.save();
            planCtx.beginPath();
            planCtx.moveTo(contour[0].x, contour[0].z);
            for (let i = 1; i < contour.length; i++) {
                planCtx.lineTo(contour[i].x, contour[i].z);
            }
            planCtx.closePath();
            planCtx.clip();
            
            // Calcular bounds do polígono
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            contour.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minZ = Math.min(minZ, p.z);
                maxZ = Math.max(maxZ, p.z);
            });
            
            planCtx.strokeStyle = '#666';
            planCtx.lineWidth = 0.5;
            const spacing = 4;
            const diagonal = Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxZ - minZ, 2));
            
            for (let i = -diagonal; i < diagonal; i += spacing) {
                planCtx.beginPath();
                planCtx.moveTo(minX + i, minZ);
                planCtx.lineTo(minX + i + diagonal, maxZ);
                planCtx.stroke();
            }
            planCtx.restore();
        }

        function getTypeStyle(tipo, isBelow) {
            const styles = {
                'Pilar': { stroke: '#444', fill: '#D0D0D0', lineWidth: 2, pattern: 'hatch' },
                'Viga': { stroke: '#666', fill: '#E8E8E8', lineWidth: 1.5, pattern: 'solid' },
                'Laje': { stroke: '#888', fill: '#F5F5F5', lineWidth: 1, pattern: 'solid' },
                'Parede': { stroke: '#333', fill: '#E0E0E0', lineWidth: 1.5, pattern: 'solid' },
                'Fundação': { stroke: '#555', fill: '#C8C8C8', lineWidth: 2, pattern: 'cross' },
                'default': { stroke: '#888', fill: '#EEEEEE', lineWidth: 1, pattern: 'solid' }
            };

            const base = styles[tipo] || styles.default;
            if (isBelow) {
                return { ...base, fill: 'transparent', opacity: 0.5, lineWidth: base.lineWidth * 0.6 };
            }
            return base;
        }

        function drawHatchPattern(x, y, width, height) {
            planCtx.save();
            planCtx.beginPath();
            planCtx.rect(x, y, width, height);
            planCtx.clip();
            planCtx.strokeStyle = '#666';
            planCtx.lineWidth = 0.5;
            const spacing = 6;
            for (let i = -height; i < width + height; i += spacing) {
                planCtx.beginPath();
                planCtx.moveTo(x + i, y);
                planCtx.lineTo(x + i + height, y + height);
                planCtx.stroke();
            }
            planCtx.restore();
        }

        function drawLegend() {
            const items = [
                { tipo: 'Pilar', label: 'Pilar' },
                { tipo: 'Viga', label: 'Viga' },
                { tipo: 'Laje', label: 'Laje' },
                { tipo: 'Fundação', label: 'Fundação' }
            ];

            const x = planCanvas.width - 90;
            const y = 10;
            const itemH = 18;

            planCtx.fillStyle = 'rgba(255,255,255,0.95)';
            planCtx.strokeStyle = '#ccc';
            planCtx.lineWidth = 1;
            planCtx.beginPath();
            planCtx.roundRect(x - 8, y, 90, items.length * itemH + 20, 4);
            planCtx.fill();
            planCtx.stroke();

            planCtx.fillStyle = '#333';
            planCtx.font = 'bold 9px Arial';
            planCtx.fillText('LEGENDA', x, y + 12);

            items.forEach((item, i) => {
                const iy = y + 20 + i * itemH;
                const style = getTypeStyle(item.tipo, false);

                planCtx.fillStyle = style.fill;
                planCtx.fillRect(x, iy, 12, 12);
                planCtx.strokeStyle = style.stroke;
                planCtx.lineWidth = 1;
                planCtx.strokeRect(x, iy, 12, 12);

                planCtx.fillStyle = '#333';
                planCtx.font = '9px Arial';
                planCtx.fillText(item.label, x + 16, iy + 9);
            });
        }

        function drawMeasurements() {
            // Desenhar medições permanentes
            planTransform.measureLines.forEach(line => {
                const x1 = worldToCanvasX(line.start.x, planCache.lastBounds);
                const z1 = worldToCanvasZ(line.start.z, planCache.lastBounds);
                const x2 = worldToCanvasX(line.end.x, planCache.lastBounds);
                const z2 = worldToCanvasZ(line.end.z, planCache.lastBounds);
                drawDimensionLine(x1, z1, x2, z2, line.distance.toFixed(3) + 'm');
            });

            // Desenhar primeiro ponto marcado (esperando segundo)
            if (planTransform.isMeasuring && planTransform.measurePoints.length === 1) {
                const start = planTransform.measurePoints[0];
                const x1 = worldToCanvasX(start.x, planCache.lastBounds);
                const z1 = worldToCanvasZ(start.z, planCache.lastBounds);
                
                // Marcador do primeiro ponto (verde pulsante)
                planCtx.fillStyle = '#00cc00';
                planCtx.beginPath();
                planCtx.arc(x1, z1, 6, 0, Math.PI * 2);
                planCtx.fill();
                planCtx.strokeStyle = '#ffffff';
                planCtx.lineWidth = 2;
                planCtx.stroke();
                
                // Linha de preview até o mouse
                if (planTransform.currentMouseWorld) {
                    const x2 = worldToCanvasX(planTransform.currentMouseWorld.x, planCache.lastBounds);
                    const z2 = worldToCanvasZ(planTransform.currentMouseWorld.z, planCache.lastBounds);
                    const dist = Math.sqrt(
                        Math.pow(planTransform.currentMouseWorld.x - start.x, 2) +
                        Math.pow(planTransform.currentMouseWorld.z - start.z, 2)
                    );
                    planCtx.globalAlpha = 0.7;
                    drawDimensionLine(x1, z1, x2, z2, dist.toFixed(3) + 'm', true);
                    planCtx.globalAlpha = 1;
                }
            }
        }

        function drawDimensionLine(x1, y1, x2, y2, text, isPreview = false) {
            const color = isPreview ? '#ff6600' : '#0066ff';
            planCtx.strokeStyle = color;
            planCtx.fillStyle = color;
            planCtx.lineWidth = 1.5;

            planCtx.beginPath();
            planCtx.moveTo(x1, y1);
            planCtx.lineTo(x2, y2);
            planCtx.stroke();

            // End markers
            planCtx.beginPath();
            planCtx.arc(x1, y1, 4, 0, Math.PI * 2);
            planCtx.arc(x2, y2, 4, 0, Math.PI * 2);
            planCtx.fill();

            // Text
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            planCtx.font = 'bold 11px Arial';
            planCtx.textAlign = 'center';
            planCtx.fillStyle = 'white';
            planCtx.fillRect(midX - 25, midY - 8, 50, 16);
            planCtx.fillStyle = color;
            planCtx.fillText(text, midX, midY + 4);
        }

        function updatePlanInfo() {
            document.getElementById('plan-zoom-info').textContent = Math.round(planTransform.scale * 100) + '%';
        }

        function onPlanWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(planTransform.minScale, Math.min(planTransform.maxScale, planTransform.scale * delta));

            const rect = planCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            planTransform.offsetX = mouseX - (mouseX - planTransform.offsetX) * (newScale / planTransform.scale);
            planTransform.offsetY = mouseY - (mouseY - planTransform.offsetY) * (newScale / planTransform.scale);
            planTransform.scale = newScale;

            drawFloorPlanOptimized();
        }

        // Variáveis para detectar arraste vs clique na planta
        let planMouseDownX = 0;
        let planMouseDownY = 0;
        let planWasDragging = false;
        const PLAN_DRAG_THRESHOLD = 5; // pixels

        function onPlanMouseDown(e) {
            // Botão do meio (wheel) ou shift+esquerdo para pan (estilo AutoCAD)
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                e.preventDefault();
                planTransform.isPanning = true;
                planCanvas.style.cursor = 'grabbing';
            }
            // Botão esquerdo para medição/seleção
            else if (e.button === 0) {
                planMouseDownX = e.clientX;
                planMouseDownY = e.clientY;
                planWasDragging = false;
            }
            planTransform.lastMouseX = e.clientX;
            planTransform.lastMouseY = e.clientY;
        }

        function onPlanMouseMove(e) {
            const rect = planCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Detectar se está arrastando com botão esquerdo (para ignorar cliques)
            if (e.buttons === 1 && !e.shiftKey && !planTransform.isPanning) {
                const dx = e.clientX - planMouseDownX;
                const dy = e.clientY - planMouseDownY;
                if (Math.sqrt(dx * dx + dy * dy) > PLAN_DRAG_THRESHOLD) {
                    planWasDragging = true;
                }
            }

            if (planCache.lastBounds) {
                let worldX = canvasToWorldX(x, planCache.lastBounds);
                let worldZ = canvasToWorldZ(y, planCache.lastBounds);
                
                // Aplicar SNAP para mostrar coordenadas com snap
                if (planTransform.isSnap && planTransform.isMeasuring) {
                    const snapped = snapToElementCorner(worldX, worldZ);
                    worldX = snapped.x;
                    worldZ = snapped.z;
                }
                
                document.getElementById('plan-coordinates').textContent = `X: ${worldX.toFixed(2)}, Z: ${worldZ.toFixed(2)}`;
                
                // Se estiver medindo com um ponto já marcado, aplicar ORTHO
                if (planTransform.isMeasuring && planTransform.measurePoints.length === 1) {
                    let mouseWorld = { x: worldX, z: worldZ };
                    mouseWorld = applyPlanOrtho(planTransform.measurePoints[0], mouseWorld);
                    planTransform.currentMouseWorld = mouseWorld;
                } else {
                    planTransform.currentMouseWorld = { x: worldX, z: worldZ };
                }
            }

            if (planTransform.isPanning) {
                // Pan com botão do meio
                planTransform.offsetX += e.clientX - planTransform.lastMouseX;
                planTransform.offsetY += e.clientY - planTransform.lastMouseY;
                planTransform.lastMouseX = e.clientX;
                planTransform.lastMouseY = e.clientY;
                drawFloorPlanOptimized();
            } else if (planTransform.isMeasuring && planTransform.measurePoints.length === 1) {
                drawFloorPlanOptimized();
            }
        }

        function onPlanMouseUp(e) {
            const wasDragging = planWasDragging;
            
            // Se era pan (botão do meio ou shift+esquerdo)
            if (e.button === 1 || (e.button === 0 && e.shiftKey && planTransform.isPanning)) {
                planTransform.isPanning = false;
                planCanvas.style.cursor = planTransform.isMeasuring ? 'crosshair' : 'default';
                return;
            }
            
            planTransform.isPanning = false;
            planWasDragging = false;
            
            // Restaurar cursor
            planCanvas.style.cursor = planTransform.isMeasuring ? 'crosshair' : 'default';
            
            // Se estava arrastando, não fazer nada mais
            if (wasDragging) {
                return;
            }
            
            // Se não estava arrastando, foi um clique
            if (e.button === 0 && planCache.lastBounds) {
                if (planTransform.isMeasuring) {
                    // Modo medição: registrar ponto
                    const rect = planCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    let worldX = canvasToWorldX(x, planCache.lastBounds);
                    let worldZ = canvasToWorldZ(y, planCache.lastBounds);
                    
                    // Aplicar SNAP
                    if (planTransform.isSnap) {
                        const snapped = snapToElementCorner(worldX, worldZ);
                        worldX = snapped.x;
                        worldZ = snapped.z;
                    }

                    if (planTransform.measurePoints.length === 0) {
                        // Primeiro ponto
                        planTransform.measurePoints.push({ x: worldX, z: worldZ });
                        showToast('📏 Primeiro ponto marcado. Clique no segundo ponto.');
                    } else {
                        // Segundo ponto - aplicar ORTHO
                        const p1 = planTransform.measurePoints[0];
                        let p2 = { x: worldX, z: worldZ };
                        p2 = applyPlanOrtho(p1, p2);
                        
                        const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));

                        // Adicionar linha de medição permanente
                        planTransform.measureLines.push({
                            start: p1,
                            end: p2,
                            distance: dist
                        });

                        planTransform.measurePoints = [];
                        showToast(`📏 Distância: ${dist.toFixed(3)}m`);
                    }

                    drawFloorPlanOptimized();
                } else {
                    // Modo normal: selecionar elemento
                    const rect = planCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    selectPlanElement(x, y);
                }
            }
        }

        function onPlanDoubleClick() {
            resetPlanView();
        }

        function selectPlanElement(x, y) {
            planLines = [];
            planCache.elements.forEach(elem => {
                const box = elem.box;
                const bounds = planCache.lastBounds;
                const x1 = worldToCanvasX(box.min.x, bounds);
                const z1 = worldToCanvasZ(box.min.z, bounds);
                const x2 = worldToCanvasX(box.max.x, bounds);
                const z2 = worldToCanvasZ(box.max.z, bounds);
                planLines.push({ node: elem.node, bounds: { minX: x1, maxX: x2, minZ: z1, maxZ: z2 } });
            });

            for (const line of planLines) {
                if (x >= line.bounds.minX && x <= line.bounds.maxX &&
                    y >= line.bounds.minZ && y <= line.bounds.maxZ) {
                    planSelectedLine = line;
                    selectObject(line.node);
                    drawFloorPlanOptimized();
                    return;
                }
            }

            planSelectedLine = null;
            drawFloorPlanOptimized();
        }

        function togglePlanMeasure() {
            planTransform.isMeasuring = !planTransform.isMeasuring;
            planTransform.measurePoints = [];
            const btn = document.getElementById('btn-plan-measure');

            if (planTransform.isMeasuring) {
                btn.classList.add('active');
                planCanvas.style.cursor = 'crosshair';
                let status = '📏 Modo Medição ATIVO - Clique para marcar pontos';
                if (planTransform.isOrtho) status += ' | ORTHO';
                if (planTransform.isSnap) status += ' | SNAP';
                showToast(status);
            } else {
                btn.classList.remove('active');
                planCanvas.style.cursor = 'default';
                showToast('📏 Modo Medição desativado');
            }
        }
        
        function togglePlanOrtho() {
            planTransform.isOrtho = !planTransform.isOrtho;
            const btn = document.getElementById('btn-plan-ortho');
            if (planTransform.isOrtho) {
                btn.classList.add('active');
                showToast('⊥ ORTHO ativado na planta');
            } else {
                btn.classList.remove('active');
                showToast('⊥ ORTHO desativado na planta');
            }
        }
        
        function togglePlanSnap() {
            planTransform.isSnap = !planTransform.isSnap;
            const btn = document.getElementById('btn-plan-snap');
            if (planTransform.isSnap) {
                btn.classList.add('active');
                showToast('🎯 SNAP ativado na planta');
            } else {
                btn.classList.remove('active');
                showToast('🎯 SNAP desativado na planta');
            }
        }
        
        function clearPlanMeasurements() {
            planTransform.measureLines = [];
            planTransform.measurePoints = [];
            drawFloorPlanOptimized();
            showToast('🗑️ Medições da planta limpas');
        }
        
        function applyPlanOrtho(start, end) {
            if (!planTransform.isOrtho) return end;
            
            const dx = Math.abs(end.x - start.x);
            const dz = Math.abs(end.z - start.z);
            
            if (dx >= dz) {
                return { x: end.x, z: start.z };
            } else {
                return { x: start.x, z: end.z };
            }
        }
        
        function snapToElementCorner(worldX, worldZ) {
            if (!planTransform.isSnap || !planCache.elements) return { x: worldX, z: worldZ };
            
            let minDist = 0.5; // Threshold de snap em metros
            let snapPoint = { x: worldX, z: worldZ };
            
            planCache.elements.forEach(elem => {
                const box = elem.box;
                // Cantos do elemento
                const corners = [
                    { x: box.min.x, z: box.min.z },
                    { x: box.min.x, z: box.max.z },
                    { x: box.max.x, z: box.min.z },
                    { x: box.max.x, z: box.max.z },
                    // Centro das arestas
                    { x: (box.min.x + box.max.x) / 2, z: box.min.z },
                    { x: (box.min.x + box.max.x) / 2, z: box.max.z },
                    { x: box.min.x, z: (box.min.z + box.max.z) / 2 },
                    { x: box.max.x, z: (box.min.z + box.max.z) / 2 },
                    // Centro
                    { x: (box.min.x + box.max.x) / 2, z: (box.min.z + box.max.z) / 2 }
                ];
                
                corners.forEach(c => {
                    const d = Math.sqrt(Math.pow(c.x - worldX, 2) + Math.pow(c.z - worldZ, 2));
                    if (d < minDist) {
                        minDist = d;
                        snapPoint = c;
                    }
                });
            });
            
            return snapPoint;
        }

        // ==========================================
        // SECTION CUT VIEW (Cortes Verticais)
        // ==========================================
        
        function setupSectionCanvas() {
            sectionCanvas = document.getElementById('section-view-canvas');
            sectionCtx = sectionCanvas.getContext('2d');
            
            sectionCanvas.addEventListener('wheel', onSectionWheel, { passive: false });
            sectionCanvas.addEventListener('mousedown', onSectionMouseDown);
            sectionCanvas.addEventListener('mousemove', onSectionMouseMove);
            sectionCanvas.addEventListener('mouseup', onSectionMouseUp);
            sectionCanvas.addEventListener('mouseleave', onSectionMouseUp);
            sectionCanvas.addEventListener('dblclick', onSectionDoubleClick);
            
            // Make container draggable
            const container = document.getElementById('section-view-container');
            const header = container.querySelector('.section-header');
            
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            header.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = container.offsetLeft;
                startTop = container.offsetTop;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                container.style.left = (startLeft + dx) + 'px';
                container.style.top = (startTop + dy) + 'px';
                container.style.bottom = 'auto';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Resize observer
            new ResizeObserver(() => {
                if (isSectionViewActive && sectionCanvas) {
                    const wrapper = sectionCanvas.parentElement;
                    if (wrapper) {
                        sectionCanvas.width = wrapper.clientWidth;
                        sectionCanvas.height = wrapper.clientHeight;
                        sectionCache.needsUpdate = true;
                        drawSectionView();
                    }
                }
            }).observe(document.getElementById('section-canvas-wrapper'));
        }
        
        function toggleSectionView() {
            const container = document.getElementById('section-view-container');
            const btn = document.getElementById('btn-toggle-section');
            isSectionViewActive = !isSectionViewActive;
            
            if (isSectionViewActive) {
                container.style.display = 'block';
                btn.innerHTML = '✂️ Fechar Cortes';
                sectionCanvas.width = sectionCanvas.parentElement.clientWidth;
                sectionCanvas.height = sectionCanvas.parentElement.clientHeight;
                
                // Initialize section positions based on model bounds
                if (modelBounds) {
                    const centerX = (modelBounds.min.x + modelBounds.max.x) / 2;
                    const centerZ = (modelBounds.min.z + modelBounds.max.z) / 2;
                    
                    // AA: Corte Transversal (perpendicular ao eixo X)
                    sectionCuts.AA = { 
                        axis: 'X', 
                        position: centerX, 
                        minPos: modelBounds.min.x, 
                        maxPos: modelBounds.max.x,
                        label: 'Transversal'
                    };
                    
                    // BB: Corte Longitudinal (perpendicular ao eixo Z)
                    sectionCuts.BB = { 
                        axis: 'Z', 
                        position: centerZ, 
                        minPos: modelBounds.min.z, 
                        maxPos: modelBounds.max.z,
                        label: 'Longitudinal'
                    };
                    
                    updateSectionSlider();
                }
                
                sectionCache.needsUpdate = true;
                drawSectionView();
                updateSectionPlaneHelper();
                
                const cut = sectionCuts[currentSection];
                showToast(`✂️ Corte ${currentSection} (${cut.label}) ativado`);
            } else {
                container.style.display = 'none';
                btn.innerHTML = '✂️ Abrir Cortes';
                removeSectionPlaneHelper();
            }
        }
        
        function changeSection(sectionName) {
            currentSection = sectionName;
            const cut = sectionCuts[sectionName];
            document.getElementById('section-name').textContent = `${sectionName} (${cut.label})`;
            sectionCache.needsUpdate = true;
            updateSectionSlider();
            drawSectionView();
            updateSectionPlaneHelper();
            showToast(`✂️ Corte ${sectionName} (${cut.label}) selecionado`);
        }
        
        function updateSectionSlider() {
            const cut = sectionCuts[currentSection];
            const slider = document.getElementById('section-position-slider');
            const valueSpan = document.getElementById('section-position-value');
            
            // Normalizar posição para 0-100
            const range = cut.maxPos - cut.minPos;
            const normalizedValue = range > 0 ? ((cut.position - cut.minPos) / range) * 100 : 50;
            
            slider.value = normalizedValue;
            valueSpan.textContent = cut.position.toFixed(2) + 'm';
            
            document.getElementById('section-position-info').textContent = 
                `${cut.axis === 'X' ? 'X' : 'Z'}: ${cut.position.toFixed(2)}m`;
            
            // Atualizar labels de limite min/max
            document.getElementById('section-min-pos').textContent = cut.minPos.toFixed(1);
            document.getElementById('section-max-pos').textContent = cut.maxPos.toFixed(1);
        }
        
        // Throttle para atualização do corte
        let sectionUpdateTimeout = null;
        let sectionPlaneObject = null; // Objeto persistente do plano
        
        function updateSectionPosition(sliderValue) {
            const cut = sectionCuts[currentSection];
            const range = cut.maxPos - cut.minPos;
            cut.position = cut.minPos + (sliderValue / 100) * range;
            
            document.getElementById('section-position-value').textContent = cut.position.toFixed(2) + 'm';
            document.getElementById('section-position-info').textContent = 
                `${cut.axis === 'X' ? 'X' : 'Z'}: ${cut.position.toFixed(2)}m`;
            
            // Atualizar plano de corte imediatamente (apenas posição)
            updateSectionPlanePosition();
            
            // Throttle para redesenhar a vista de corte (mais pesado)
            if (sectionUpdateTimeout) {
                cancelAnimationFrame(sectionUpdateTimeout);
            }
            sectionUpdateTimeout = requestAnimationFrame(() => {
                sectionCache.needsUpdate = true;
                drawSectionView();
            });
        }
        
        // Atualiza apenas a posição do plano (rápido)
        function updateSectionPlanePosition() {
            if (!sectionPlaneObject || !modelBounds || !isSectionViewActive) return;
            
            const cut = sectionCuts[currentSection];
            const centerY = (modelBounds.min.y + modelBounds.max.y) / 2;
            
            if (cut.axis === 'X') {
                sectionPlaneObject.position.x = cut.position;
            } else {
                sectionPlaneObject.position.z = cut.position;
            }
        }
        
        // Move o corte em incrementos
        function nudgeSectionPosition(delta) {
            const slider = document.getElementById('section-position-slider');
            let newValue = parseFloat(slider.value) + delta;
            newValue = Math.max(0, Math.min(100, newValue));
            slider.value = newValue;
            updateSectionPosition(newValue);
        }
        
        // Alinha a câmera 3D para visualizar o corte atual
        function alignCameraToSection() {
            if (!modelBounds || !loadedModel) return;
            
            const cut = sectionCuts[currentSection];
            const centerY = (modelBounds.min.y + modelBounds.max.y) / 2;
            const height = modelBounds.max.y - modelBounds.min.y;
            const distance = Math.max(
                modelBounds.max.x - modelBounds.min.x,
                modelBounds.max.z - modelBounds.min.z,
                height
            ) * 1.5;
            
            let targetPos, lookAt;
            
            if (cut.axis === 'X') {
                // Corte transversal - câmera olhando para +X
                targetPos = new THREE.Vector3(
                    cut.position - distance,
                    centerY,
                    (modelBounds.min.z + modelBounds.max.z) / 2
                );
                lookAt = new THREE.Vector3(
                    cut.position,
                    centerY,
                    (modelBounds.min.z + modelBounds.max.z) / 2
                );
            } else {
                // Corte longitudinal - câmera olhando para +Z
                targetPos = new THREE.Vector3(
                    (modelBounds.min.x + modelBounds.max.x) / 2,
                    centerY,
                    cut.position - distance
                );
                lookAt = new THREE.Vector3(
                    (modelBounds.min.x + modelBounds.max.x) / 2,
                    centerY,
                    cut.position
                );
            }
            
            // Animação suave
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 800;
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                // Ease out cubic
                const ease = 1 - Math.pow(1 - t, 3);
                
                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.lerpVectors(startTarget, lookAt, ease);
                controls.update();
                
                if (t < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            animateCamera();
            showToast(`📷 Câmera alinhada ao corte ${currentSection}`);
        }
        
        // Cria ou recria o plano de corte completo
        function updateSectionPlaneHelper() {
            removeSectionPlaneHelper();
            if (!loadedModel || !modelBounds || !isSectionViewActive) return;
            
            const cut = sectionCuts[currentSection];
            const height = modelBounds.max.y - modelBounds.min.y;
            const width = cut.axis === 'X' ? 
                (modelBounds.max.z - modelBounds.min.z) : 
                (modelBounds.max.x - modelBounds.min.x);
            
            // Criar grupo para o plano
            const planeGroup = new THREE.Group();
            
            // Plano semi-transparente
            const geometry = new THREE.PlaneGeometry(width + 2, height + 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,
                depthTest: false
            });
            
            const planeMesh = new THREE.Mesh(geometry, material);
            planeGroup.add(planeMesh);
            
            // Bordas do plano
            const edgesGeometry = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 2 });
            const lineEdges = new THREE.LineSegments(edgesGeometry, lineMaterial);
            planeGroup.add(lineEdges);
            
            // Linha central de corte (mais visível)
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -height/2 - 1, 0),
                new THREE.Vector3(0, height/2 + 1, 0)
            ]);
            const cutLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff0000, 
                linewidth: 3 
            });
            const cutLine = new THREE.Line(lineGeometry, cutLineMaterial);
            planeGroup.add(cutLine);
            
            // Marcadores nas extremidades
            const markerGeometry = new THREE.CircleGeometry(0.3, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            
            const topMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            topMarker.position.y = height/2 + 1;
            topMarker.rotation.x = Math.PI / 2;
            planeGroup.add(topMarker);
            
            const bottomMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            bottomMarker.position.y = -height/2 - 1;
            bottomMarker.rotation.x = Math.PI / 2;
            planeGroup.add(bottomMarker);
            
            // Label do corte
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8b5cf6';
            ctx.fillRect(0, 0, 128, 64);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(currentSection, 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 1, 1);
            sprite.position.y = height / 2 + 2;
            planeGroup.add(sprite);
            
            // Posicionar o grupo
            const centerY = (modelBounds.min.y + modelBounds.max.y) / 2;
            
            if (cut.axis === 'X') {
                planeGroup.rotation.y = Math.PI / 2;
                planeGroup.position.set(cut.position, centerY, (modelBounds.min.z + modelBounds.max.z) / 2);
            } else {
                planeGroup.position.set((modelBounds.min.x + modelBounds.max.x) / 2, centerY, cut.position);
            }
            
            scene.add(planeGroup);
            sectionPlaneHelpers[currentSection] = planeGroup;
            sectionPlaneObject = planeGroup;
        }
        
        function removeSectionPlaneHelper() {
            Object.values(sectionPlaneHelpers).forEach(helper => {
                if (helper) scene.remove(helper);
            });
            sectionPlaneHelpers = {};
            sectionPlaneObject = null;
        }
        
        function drawSectionView() {
            if (!sectionCanvas || !sectionCtx || !loadedModel) return;
            
            sectionCtx.fillStyle = '#ffffff';
            sectionCtx.fillRect(0, 0, sectionCanvas.width, sectionCanvas.height);
            
            const cut = sectionCuts[currentSection];
            
            // Calculate bounds and collect elements
            if (sectionCache.needsUpdate) {
                sectionCache.elements = [];
                const bounds = { minH: Infinity, maxH: -Infinity, minY: Infinity, maxY: -Infinity };
                
                const tolerance = 0.3; // Tolerance for intersection
                
                loadedModel.traverse((node) => {
                    if (node.isMesh && node.visible && node.userData.info) {
                        const box = new THREE.Box3().setFromObject(node);
                        
                        // Check if element intersects the cut plane
                        let intersects = false;
                        if (cut.axis === 'X') {
                            intersects = box.min.x <= cut.position + tolerance && box.max.x >= cut.position - tolerance;
                        } else {
                            intersects = box.min.z <= cut.position + tolerance && box.max.z >= cut.position - tolerance;
                        }
                        
                        if (intersects) {
                            // For X-axis cut, horizontal is Z; for Z-axis cut, horizontal is X
                            const minH = cut.axis === 'X' ? box.min.z : box.min.x;
                            const maxH = cut.axis === 'X' ? box.max.z : box.max.x;
                            
                            bounds.minH = Math.min(bounds.minH, minH);
                            bounds.maxH = Math.max(bounds.maxH, maxH);
                            bounds.minY = Math.min(bounds.minY, box.min.y);
                            bounds.maxY = Math.max(bounds.maxY, box.max.y);
                            
                            // Determine if element is in front or behind the cut
                            const centerPos = cut.axis === 'X' ? 
                                (box.min.x + box.max.x) / 2 : 
                                (box.min.z + box.max.z) / 2;
                            const isBehind = centerPos < cut.position;
                            
                            sectionCache.elements.push({
                                node: node,
                                box: box,
                                info: node.userData.info,
                                minH: minH,
                                maxH: maxH,
                                isBehind: isBehind
                            });
                        }
                    }
                });
                
                if (bounds.minH === Infinity) {
                    bounds.minH = -10; bounds.maxH = 10;
                    bounds.minY = 0; bounds.maxY = 10;
                }
                
                sectionCache.lastBounds = bounds;
                sectionCache.needsUpdate = false;
            }
            
            const bounds = sectionCache.lastBounds;
            if (!bounds) return;
            
            drawSectionGrid(bounds);
            
            // Draw elements (behind first, then front)
            sectionCache.elements
                .filter(e => e.isBehind)
                .forEach(elem => drawSectionElement(elem, bounds));
            sectionCache.elements
                .filter(e => !e.isBehind)
                .forEach(elem => drawSectionElement(elem, bounds));
            
            // Desenhar linha de corte vertical central
            drawSectionCutLine(bounds);
            
            drawSectionMeasurements();
            drawSectionLegend();
            drawSectionDirectionIndicator();
            updateSectionInfo();
        }
        
        // Desenha a linha de corte central
        function drawSectionCutLine(bounds) {
            const centerX = sectionCanvas.width / 2 + sectionTransform.offsetX;
            
            // Linha de corte vertical tracejada
            sectionCtx.save();
            sectionCtx.strokeStyle = '#8b5cf6';
            sectionCtx.lineWidth = 2;
            sectionCtx.setLineDash([8, 4]);
            
            sectionCtx.beginPath();
            sectionCtx.moveTo(centerX, 10);
            sectionCtx.lineTo(centerX, sectionCanvas.height - 10);
            sectionCtx.stroke();
            
            // Marcadores no topo e embaixo
            sectionCtx.setLineDash([]);
            sectionCtx.fillStyle = '#8b5cf6';
            
            // Triângulo no topo
            sectionCtx.beginPath();
            sectionCtx.moveTo(centerX, 5);
            sectionCtx.lineTo(centerX - 8, 15);
            sectionCtx.lineTo(centerX + 8, 15);
            sectionCtx.closePath();
            sectionCtx.fill();
            
            // Triângulo embaixo
            sectionCtx.beginPath();
            sectionCtx.moveTo(centerX, sectionCanvas.height - 5);
            sectionCtx.lineTo(centerX - 8, sectionCanvas.height - 15);
            sectionCtx.lineTo(centerX + 8, sectionCanvas.height - 15);
            sectionCtx.closePath();
            sectionCtx.fill();
            
            // Label do corte
            sectionCtx.fillStyle = '#8b5cf6';
            sectionCtx.font = 'bold 12px Arial';
            sectionCtx.textAlign = 'center';
            sectionCtx.fillText(currentSection, centerX, 28);
            
            sectionCtx.restore();
        }
        
        // Indicador de direção do corte
        function drawSectionDirectionIndicator() {
            const cut = sectionCuts[currentSection];
            
            sectionCtx.save();
            
            // Box no canto superior direito
            const boxX = sectionCanvas.width - 70;
            const boxY = 10;
            const boxW = 60;
            const boxH = 45;
            
            // Fundo
            sectionCtx.fillStyle = 'rgba(139, 92, 246, 0.1)';
            sectionCtx.fillRect(boxX, boxY, boxW, boxH);
            sectionCtx.strokeStyle = '#8b5cf6';
            sectionCtx.lineWidth = 1;
            sectionCtx.strokeRect(boxX, boxY, boxW, boxH);
            
            // Texto da direção
            sectionCtx.fillStyle = '#8b5cf6';
            sectionCtx.font = 'bold 10px Arial';
            sectionCtx.textAlign = 'center';
            
            if (cut.axis === 'X') {
                // Corte transversal - olhando para X
                sectionCtx.fillText('VISTA', boxX + boxW/2, boxY + 15);
                sectionCtx.fillText('→ +X', boxX + boxW/2, boxY + 30);
                sectionCtx.font = '9px Arial';
                sectionCtx.fillStyle = '#666';
                sectionCtx.fillText('(Z × Y)', boxX + boxW/2, boxY + 42);
            } else {
                // Corte longitudinal - olhando para Z
                sectionCtx.fillText('VISTA', boxX + boxW/2, boxY + 15);
                sectionCtx.fillText('→ +Z', boxX + boxW/2, boxY + 30);
                sectionCtx.font = '9px Arial';
                sectionCtx.fillStyle = '#666';
                sectionCtx.fillText('(X × Y)', boxX + boxW/2, boxY + 42);
            }
            
            sectionCtx.restore();
        }
        
        function drawSectionGrid(bounds) {
            const padding = 30;
            const worldWidth = bounds.maxH - bounds.minH;
            const worldHeight = bounds.maxY - bounds.minY;
            const scale = Math.min(
                (sectionCanvas.width - padding * 2) / worldWidth,
                (sectionCanvas.height - padding * 2) / worldHeight
            ) * sectionTransform.scale;
            
            sectionCtx.strokeStyle = '#e8e8e8';
            sectionCtx.lineWidth = 0.5;
            
            const gridSize = worldWidth > 20 ? 5 : worldWidth > 10 ? 2 : 1;
            
            // Vertical grid lines
            for (let h = Math.floor(bounds.minH / gridSize) * gridSize; h <= bounds.maxH; h += gridSize) {
                const canvasX = sectionWorldToCanvasX(h, bounds);
                if (canvasX >= 0 && canvasX <= sectionCanvas.width) {
                    sectionCtx.beginPath();
                    sectionCtx.moveTo(canvasX, 0);
                    sectionCtx.lineTo(canvasX, sectionCanvas.height);
                    sectionCtx.stroke();
                }
            }
            
            // Horizontal grid lines
            for (let y = Math.floor(bounds.minY / gridSize) * gridSize; y <= bounds.maxY; y += gridSize) {
                const canvasY = sectionWorldToCanvasY(y, bounds);
                if (canvasY >= 0 && canvasY <= sectionCanvas.height) {
                    sectionCtx.beginPath();
                    sectionCtx.moveTo(0, canvasY);
                    sectionCtx.lineTo(sectionCanvas.width, canvasY);
                    sectionCtx.stroke();
                }
            }
            
            // Draw ground line
            const groundY = sectionWorldToCanvasY(0, bounds);
            if (groundY >= 0 && groundY <= sectionCanvas.height) {
                sectionCtx.strokeStyle = '#94a3b8';
                sectionCtx.lineWidth = 1.5;
                sectionCtx.setLineDash([5, 3]);
                sectionCtx.beginPath();
                sectionCtx.moveTo(0, groundY);
                sectionCtx.lineTo(sectionCanvas.width, groundY);
                sectionCtx.stroke();
                sectionCtx.setLineDash([]);
                
                // Ground label
                sectionCtx.fillStyle = '#64748b';
                sectionCtx.font = '10px Arial';
                sectionCtx.fillText('NÍVEL 0.00', 5, groundY - 5);
            }
        }
        
        function sectionWorldToCanvasX(worldH, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxH - bounds.minH;
            const worldHeight = bounds.maxY - bounds.minY;
            const baseScale = Math.min(
                (sectionCanvas.width - padding * 2) / worldWidth,
                (sectionCanvas.height - padding * 2) / worldHeight
            );
            const centerX = sectionCanvas.width / 2;
            const worldCenterH = (bounds.minH + bounds.maxH) / 2;
            return centerX + (worldH - worldCenterH) * baseScale * sectionTransform.scale + sectionTransform.offsetX;
        }
        
        function sectionWorldToCanvasY(worldY, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxH - bounds.minH;
            const worldHeight = bounds.maxY - bounds.minY;
            const baseScale = Math.min(
                (sectionCanvas.width - padding * 2) / worldWidth,
                (sectionCanvas.height - padding * 2) / worldHeight
            );
            const centerY = sectionCanvas.height / 2;
            const worldCenterY = (bounds.minY + bounds.maxY) / 2;
            // Invert Y so higher values are at the top
            return centerY - (worldY - worldCenterY) * baseScale * sectionTransform.scale + sectionTransform.offsetY;
        }
        
        function sectionCanvasToWorldX(canvasX, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxH - bounds.minH;
            const worldHeight = bounds.maxY - bounds.minY;
            const baseScale = Math.min(
                (sectionCanvas.width - padding * 2) / worldWidth,
                (sectionCanvas.height - padding * 2) / worldHeight
            );
            const centerX = sectionCanvas.width / 2;
            const worldCenterH = (bounds.minH + bounds.maxH) / 2;
            return (canvasX - centerX - sectionTransform.offsetX) / (baseScale * sectionTransform.scale) + worldCenterH;
        }
        
        function sectionCanvasToWorldY(canvasY, bounds) {
            const padding = 30;
            const worldWidth = bounds.maxH - bounds.minH;
            const worldHeight = bounds.maxY - bounds.minY;
            const baseScale = Math.min(
                (sectionCanvas.width - padding * 2) / worldWidth,
                (sectionCanvas.height - padding * 2) / worldHeight
            );
            const centerY = sectionCanvas.height / 2;
            const worldCenterY = (bounds.minY + bounds.maxY) / 2;
            return -(canvasY - centerY - sectionTransform.offsetY) / (baseScale * sectionTransform.scale) + worldCenterY;
        }
        
        function drawSectionElement(elem, bounds) {
            const box = elem.box;
            const info = elem.info;
            const tipo = info.tipo;
            const node = elem.node;
            
            const x1 = sectionWorldToCanvasX(elem.minH, bounds);
            const y1 = sectionWorldToCanvasY(box.max.y, bounds);
            const x2 = sectionWorldToCanvasX(elem.maxH, bounds);
            const y2 = sectionWorldToCanvasY(box.min.y, bounds);
            
            const width = x2 - x1;
            const height = y2 - y1;
            
            const style = getSectionTypeStyle(tipo, elem.isBehind);
            
            // Detectar se é elemento circular (na vista de corte, aparece como círculo se cortado perpendicular)
            const isCircular = detectCircularElementSection(node, box, info, elem);
            
            // Obter contorno projetado para elementos inclinados
            const projectedContour = getProjectedContourSection(node, bounds, elem);
            
            sectionCtx.fillStyle = style.fill;
            sectionCtx.globalAlpha = style.opacity || 1;
            
            if (isCircular) {
                // Desenhar círculo/elipse
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                const radiusX = Math.abs(width) / 2;
                const radiusY = Math.abs(height) / 2;
                
                if (style.fill !== 'transparent') {
                    sectionCtx.beginPath();
                    sectionCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    sectionCtx.fill();
                }
                
                // Hatch para pilares circulares
                if (style.pattern === 'hatch' && !elem.isBehind) {
                    drawSectionCircularHatch(centerX, centerY, radiusX, radiusY);
                }
                
                // Stroke
                sectionCtx.strokeStyle = style.stroke;
                sectionCtx.lineWidth = style.lineWidth;
                if (elem.isBehind) {
                    sectionCtx.setLineDash([4, 2]);
                    sectionCtx.globalAlpha = 0.5;
                } else {
                    sectionCtx.setLineDash([]);
                }
                
                if (sectionSelectedLine && sectionSelectedLine.node === node) {
                    sectionCtx.strokeStyle = '#8b5cf6';
                    sectionCtx.lineWidth = 3;
                }
                
                sectionCtx.beginPath();
                sectionCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                sectionCtx.stroke();
                
            } else if (projectedContour && projectedContour.length > 2) {
                // Desenhar polígono projetado (para elementos inclinados)
                if (style.fill !== 'transparent') {
                    sectionCtx.beginPath();
                    sectionCtx.moveTo(projectedContour[0].x, projectedContour[0].y);
                    for (let i = 1; i < projectedContour.length; i++) {
                        sectionCtx.lineTo(projectedContour[i].x, projectedContour[i].y);
                    }
                    sectionCtx.closePath();
                    sectionCtx.fill();
                }
                
                // Hatch
                if (style.pattern === 'hatch' && !elem.isBehind) {
                    drawSectionPolygonHatch(projectedContour);
                }
                
                // Stroke
                sectionCtx.strokeStyle = style.stroke;
                sectionCtx.lineWidth = style.lineWidth;
                if (elem.isBehind) {
                    sectionCtx.setLineDash([4, 2]);
                    sectionCtx.globalAlpha = 0.5;
                } else {
                    sectionCtx.setLineDash([]);
                }
                
                if (sectionSelectedLine && sectionSelectedLine.node === node) {
                    sectionCtx.strokeStyle = '#8b5cf6';
                    sectionCtx.lineWidth = 3;
                }
                
                sectionCtx.beginPath();
                sectionCtx.moveTo(projectedContour[0].x, projectedContour[0].y);
                for (let i = 1; i < projectedContour.length; i++) {
                    sectionCtx.lineTo(projectedContour[i].x, projectedContour[i].y);
                }
                sectionCtx.closePath();
                sectionCtx.stroke();
                
            } else {
                // Desenhar retângulo padrão
                if (style.fill !== 'transparent') {
                    sectionCtx.fillRect(x1, y1, width, height);
                }
                
                // Hatch pattern for pilares
                if (style.pattern === 'hatch' && !elem.isBehind) {
                    drawSectionHatch(x1, y1, width, height);
                }
                
                // Stroke
                sectionCtx.strokeStyle = style.stroke;
                sectionCtx.lineWidth = style.lineWidth;
                if (elem.isBehind) {
                    sectionCtx.setLineDash([4, 2]);
                    sectionCtx.globalAlpha = 0.5;
                } else {
                    sectionCtx.setLineDash([]);
                }
                
                // Highlight selected
                if (sectionSelectedLine && sectionSelectedLine.node === node) {
                    sectionCtx.strokeStyle = '#8b5cf6';
                    sectionCtx.lineWidth = 3;
                }
                
                sectionCtx.strokeRect(x1, y1, width, height);
            }
            
            sectionCtx.setLineDash([]);
            sectionCtx.globalAlpha = 1;
            
            // Label
            const labelX = (x1 + x2) / 2;
            const labelY = (y1 + y2) / 2;
            if (Math.abs(width) > 25 && Math.abs(height) > 15 && !elem.isBehind) {
                sectionCtx.fillStyle = '#333';
                sectionCtx.font = '9px Arial';
                sectionCtx.textAlign = 'center';
                sectionCtx.textBaseline = 'middle';
                const label = info.nome.length > 10 ? info.nome.substring(0, 10) : info.nome;
                sectionCtx.fillText(label, labelX, labelY);
            }
            
            // Store for selection
            sectionLines.push({
                node: node,
                bounds: { minX: x1, maxX: x2, minY: y1, maxY: y2 }
            });
        }
        
        // Detecta se elemento é circular na vista de corte
        function detectCircularElementSection(node, box, info, elem) {
            if (!node || !node.geometry) return false;
            
            const cutAxis = sectionCuts[currentSection].axis;
            
            // Verificar pelo nome
            const nome = (info.nome || '').toLowerCase();
            if (nome.includes('circular') || nome.includes('cilind') || nome.includes('ø') || 
                nome.includes('diam') || nome.includes('tubo') || nome.includes('pipe')) {
                return true;
            }
            
            // Verificar se é estaca (geralmente circular)
            if (info.tipo === 'Estaca') {
                const sizeH = elem.maxH - elem.minH;
                const sizeY = box.max.y - box.min.y;
                // Se a altura é muito maior que a largura, é uma estaca vertical (circular em corte)
                if (sizeY > sizeH * 2) {
                    const otherDim = cutAxis === 'X' ? (box.max.x - box.min.x) : (box.max.z - box.min.z);
                    const ratio = Math.min(sizeH, otherDim) / Math.max(sizeH, otherDim);
                    if (ratio > 0.7) return true;
                }
            }
            
            // Verificar pela geometria
            const geometry = node.geometry;
            if (!geometry.attributes || !geometry.attributes.position) return false;
            
            const positions = geometry.attributes.position;
            const sizeH = elem.maxH - elem.minH;
            const sizeY = box.max.y - box.min.y;
            
            // Se seção é aproximadamente quadrada e tem muitos vértices
            const ratio = Math.min(sizeH, sizeY) / Math.max(sizeH, sizeY);
            if (ratio > 0.7) {
                const uniquePoints = new Set();
                const vertex = new THREE.Vector3();
                
                for (let i = 0; i < Math.min(positions.count, 300); i++) {
                    vertex.fromBufferAttribute(positions, i);
                    vertex.applyMatrix4(node.matrixWorld);
                    const h = cutAxis === 'X' ? vertex.z : vertex.x;
                    const key = `${(h * 100).toFixed(0)}_${(vertex.y * 100).toFixed(0)}`;
                    uniquePoints.add(key);
                }
                
                if (uniquePoints.size > 16) return true;
            }
            
            return false;
        }
        
        // Obtém contorno projetado para vista de corte
        function getProjectedContourSection(node, bounds, elem) {
            if (!node || !node.geometry) return null;
            
            const cutAxis = sectionCuts[currentSection].axis;
            
            const geometry = node.geometry;
            if (!geometry.attributes || !geometry.attributes.position) return null;
            
            const positions = geometry.attributes.position;
            const points = [];
            const vertex = new THREE.Vector3();
            
            // Coletar vértices transformados e projetar no plano do corte
            for (let i = 0; i < positions.count; i++) {
                vertex.fromBufferAttribute(positions, i);
                vertex.applyMatrix4(node.matrixWorld);
                
                // H é a coordenada horizontal no corte (Z para corte X, X para corte Z)
                const h = cutAxis === 'X' ? vertex.z : vertex.x;
                points.push({ h: h, y: vertex.y });
            }
            
            if (points.length < 3) return null;
            
            // Calcular convex hull 2D no plano do corte
            const hull = computeConvexHull2DSection(points);
            
            if (!hull || hull.length < 3) return null;
            
            // Converter para coordenadas do canvas
            return hull.map(p => ({
                x: sectionWorldToCanvasX(p.h, bounds),
                y: sectionWorldToCanvasY(p.y, bounds)
            }));
        }
        
        // Convex hull para seção (usa h e y)
        function computeConvexHull2DSection(points) {
            if (points.length < 3) return points;
            
            // Encontrar ponto mais à esquerda
            let leftmost = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].h < points[leftmost].h) {
                    leftmost = i;
                }
            }
            
            const hull = [];
            let current = leftmost;
            let iterations = 0;
            const maxIterations = Math.min(points.length, 50);
            
            do {
                hull.push(points[current]);
                let next = 0;
                
                for (let i = 1; i < points.length; i++) {
                    if (next === current) {
                        next = i;
                        continue;
                    }
                    
                    const cross = (points[i].h - points[current].h) * (points[next].y - points[current].y) -
                                  (points[i].y - points[current].y) * (points[next].h - points[current].h);
                    
                    if (cross > 0) {
                        next = i;
                    }
                }
                
                current = next;
                iterations++;
                
            } while (current !== leftmost && iterations < maxIterations);
            
            return hull;
        }
        
        // Desenha hachura circular em corte
        function drawSectionCircularHatch(cx, cy, radiusX, radiusY) {
            sectionCtx.save();
            sectionCtx.beginPath();
            sectionCtx.ellipse(cx, cy, radiusX, radiusY, 0, 0, Math.PI * 2);
            sectionCtx.clip();
            sectionCtx.strokeStyle = '#666';
            sectionCtx.lineWidth = 0.5;
            const spacing = 4;
            const maxR = Math.max(radiusX, radiusY);
            for (let i = -maxR * 2; i < maxR * 2; i += spacing) {
                sectionCtx.beginPath();
                sectionCtx.moveTo(cx + i - maxR, cy - maxR);
                sectionCtx.lineTo(cx + i + maxR, cy + maxR);
                sectionCtx.stroke();
            }
            sectionCtx.restore();
        }
        
        // Desenha hachura em polígono (corte)
        function drawSectionPolygonHatch(contour) {
            if (!contour || contour.length < 3) return;
            
            sectionCtx.save();
            sectionCtx.beginPath();
            sectionCtx.moveTo(contour[0].x, contour[0].y);
            for (let i = 1; i < contour.length; i++) {
                sectionCtx.lineTo(contour[i].x, contour[i].y);
            }
            sectionCtx.closePath();
            sectionCtx.clip();
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            contour.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });
            
            sectionCtx.strokeStyle = '#666';
            sectionCtx.lineWidth = 0.5;
            const spacing = 4;
            const diagonal = Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2));
            
            for (let i = -diagonal; i < diagonal; i += spacing) {
                sectionCtx.beginPath();
                sectionCtx.moveTo(minX + i, minY);
                sectionCtx.lineTo(minX + i + diagonal, maxY);
                sectionCtx.stroke();
            }
            sectionCtx.restore();
        }
        
        function getSectionTypeStyle(tipo, isBehind) {
            const styles = {
                'Pilar': { stroke: '#444', fill: '#D0D0D0', lineWidth: 2, pattern: 'hatch' },
                'Viga': { stroke: '#666', fill: '#E8E8E8', lineWidth: 1.5, pattern: 'solid' },
                'Laje': { stroke: '#888', fill: '#F5F5F5', lineWidth: 1, pattern: 'solid' },
                'Parede': { stroke: '#333', fill: '#E0E0E0', lineWidth: 1.5, pattern: 'solid' },
                'Fundação': { stroke: '#555', fill: '#C8C8C8', lineWidth: 2, pattern: 'cross' },
                'Estaca': { stroke: '#666', fill: '#B8B8B8', lineWidth: 1.5, pattern: 'solid' },
                'default': { stroke: '#888', fill: '#EEEEEE', lineWidth: 1, pattern: 'solid' }
            };
            
            const base = styles[tipo] || styles.default;
            if (isBehind) {
                return { ...base, fill: 'transparent', opacity: 0.4, lineWidth: base.lineWidth * 0.5 };
            }
            return base;
        }
        
        function drawSectionHatch(x, y, width, height) {
            sectionCtx.save();
            sectionCtx.beginPath();
            sectionCtx.rect(x, y, width, height);
            sectionCtx.clip();
            sectionCtx.strokeStyle = '#666';
            sectionCtx.lineWidth = 0.5;
            const spacing = 5;
            for (let i = -height; i < width + height; i += spacing) {
                sectionCtx.beginPath();
                sectionCtx.moveTo(x + i, y);
                sectionCtx.lineTo(x + i + height, y + height);
                sectionCtx.stroke();
            }
            sectionCtx.restore();
        }
        
        function drawSectionLegend() {
            const items = [
                { tipo: 'Pilar', label: 'Pilar' },
                { tipo: 'Viga', label: 'Viga' },
                { tipo: 'Laje', label: 'Laje' },
                { tipo: 'Fundação', label: 'Fundação' }
            ];
            
            const x = sectionCanvas.width - 90;
            const y = 10;
            const itemH = 18;
            
            sectionCtx.fillStyle = 'rgba(255,255,255,0.95)';
            sectionCtx.strokeStyle = '#ccc';
            sectionCtx.lineWidth = 1;
            sectionCtx.beginPath();
            sectionCtx.roundRect(x - 8, y, 90, items.length * itemH + 20, 4);
            sectionCtx.fill();
            sectionCtx.stroke();
            
            sectionCtx.fillStyle = '#333';
            sectionCtx.font = 'bold 9px Arial';
            sectionCtx.fillText('LEGENDA', x, y + 12);
            
            items.forEach((item, i) => {
                const yPos = y + 22 + i * itemH;
                const style = getSectionTypeStyle(item.tipo, false);
                
                sectionCtx.fillStyle = style.fill;
                sectionCtx.strokeStyle = style.stroke;
                sectionCtx.lineWidth = 1;
                sectionCtx.fillRect(x, yPos, 14, 10);
                sectionCtx.strokeRect(x, yPos, 14, 10);
                
                sectionCtx.fillStyle = '#333';
                sectionCtx.font = '9px Arial';
                sectionCtx.fillText(item.label, x + 20, yPos + 8);
            });
        }
        
        function drawSectionMeasurements() {
            // Draw completed measurements
            sectionTransform.measureLines.forEach(line => {
                drawSectionMeasureLine(line.start, line.end, line.distance);
            });
            
            // Draw current measurement in progress
            if (sectionTransform.measurePoints.length === 1 && sectionTransform.currentMouseWorld) {
                const start = sectionTransform.measurePoints[0];
                let end = sectionTransform.currentMouseWorld;
                
                if (sectionTransform.isOrtho) {
                    end = applySectionOrtho(start, end);
                }
                
                const dist = Math.sqrt(Math.pow(end.h - start.h, 2) + Math.pow(end.y - start.y, 2));
                drawSectionMeasureLine(start, end, dist, true);
            }
        }
        
        function drawSectionMeasureLine(start, end, distance, isTemp = false) {
            const bounds = sectionCache.lastBounds;
            if (!bounds) return;
            
            const x1 = sectionWorldToCanvasX(start.h, bounds);
            const y1 = sectionWorldToCanvasY(start.y, bounds);
            const x2 = sectionWorldToCanvasX(end.h, bounds);
            const y2 = sectionWorldToCanvasY(end.y, bounds);
            
            // Line
            sectionCtx.strokeStyle = isTemp ? '#a78bfa' : '#8b5cf6';
            sectionCtx.lineWidth = 2;
            sectionCtx.setLineDash(isTemp ? [5, 3] : []);
            sectionCtx.beginPath();
            sectionCtx.moveTo(x1, y1);
            sectionCtx.lineTo(x2, y2);
            sectionCtx.stroke();
            sectionCtx.setLineDash([]);
            
            // End markers
            const markerSize = 6;
            sectionCtx.fillStyle = '#8b5cf6';
            sectionCtx.beginPath();
            sectionCtx.arc(x1, y1, markerSize / 2, 0, Math.PI * 2);
            sectionCtx.fill();
            sectionCtx.beginPath();
            sectionCtx.arc(x2, y2, markerSize / 2, 0, Math.PI * 2);
            sectionCtx.fill();
            
            // Distance label
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const text = distance.toFixed(2) + 'm';
            
            sectionCtx.font = 'bold 11px Arial';
            const textWidth = sectionCtx.measureText(text).width;
            
            sectionCtx.fillStyle = 'rgba(139, 92, 246, 0.9)';
            sectionCtx.beginPath();
            sectionCtx.roundRect(midX - textWidth / 2 - 5, midY - 8, textWidth + 10, 16, 3);
            sectionCtx.fill();
            
            sectionCtx.fillStyle = 'white';
            sectionCtx.textAlign = 'center';
            sectionCtx.textBaseline = 'middle';
            sectionCtx.fillText(text, midX, midY);
        }
        
        function updateSectionInfo() {
            const zoomPercent = Math.round(sectionTransform.scale * 100);
            document.getElementById('section-zoom-info').textContent = zoomPercent + '%';
        }
        
        // Section Event Handlers
        function onSectionWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = sectionTransform.scale * delta;
            
            if (newScale >= sectionTransform.minScale && newScale <= sectionTransform.maxScale) {
                const rect = sectionCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                sectionTransform.offsetX = mouseX - (mouseX - sectionTransform.offsetX) * delta;
                sectionTransform.offsetY = mouseY - (mouseY - sectionTransform.offsetY) * delta;
                sectionTransform.scale = newScale;
                
                drawSectionView();
            }
        }
        
        function onSectionMouseDown(e) {
            const rect = sectionCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Botão do meio (wheel) ou shift+esquerdo para pan (estilo AutoCAD)
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                e.preventDefault();
                sectionTransform.isPanning = true;
                sectionTransform.lastMouseX = x;
                sectionTransform.lastMouseY = y;
                sectionCanvas.style.cursor = 'grabbing';
                return;
            }
            
            // Botão esquerdo para medição
            if (e.button === 0 && sectionTransform.isMeasuring) {
                const bounds = sectionCache.lastBounds;
                if (!bounds) return;
                
                let worldH = sectionCanvasToWorldX(x, bounds);
                let worldY = sectionCanvasToWorldY(y, bounds);
                
                if (sectionTransform.isSnap) {
                    const snapped = snapToSectionCorner(worldH, worldY);
                    worldH = snapped.h;
                    worldY = snapped.y;
                }
                
                if (sectionTransform.measurePoints.length === 0) {
                    sectionTransform.measurePoints.push({ h: worldH, y: worldY });
                } else {
                    let endPoint = { h: worldH, y: worldY };
                    if (sectionTransform.isOrtho) {
                        endPoint = applySectionOrtho(sectionTransform.measurePoints[0], endPoint);
                    }
                    
                    const start = sectionTransform.measurePoints[0];
                    const dist = Math.sqrt(Math.pow(endPoint.h - start.h, 2) + Math.pow(endPoint.y - start.y, 2));
                    
                    sectionTransform.measureLines.push({
                        start: start,
                        end: endPoint,
                        distance: dist
                    });
                    
                    sectionTransform.measurePoints = [];
                    showToast(`Medicao: ${dist.toFixed(3)}m`);
                }
                drawSectionView();
            }
        }
        
        function onSectionMouseMove(e) {
            const rect = sectionCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const bounds = sectionCache.lastBounds;
            
            if (bounds) {
                let worldH = sectionCanvasToWorldX(x, bounds);
                let worldY = sectionCanvasToWorldY(y, bounds);
                
                const cut = sectionCuts[currentSection];
                const axisLabel = cut.axis === 'X' ? 'Z' : 'X';
                document.getElementById('section-coordinates').textContent = 
                    `${axisLabel}: ${worldH.toFixed(2)}, Y: ${worldY.toFixed(2)}`;
                
                if (sectionTransform.isMeasuring && sectionTransform.measurePoints.length === 1) {
                    if (sectionTransform.isSnap) {
                        const snapped = snapToSectionCorner(worldH, worldY);
                        worldH = snapped.h;
                        worldY = snapped.y;
                    }
                    
                    sectionTransform.currentMouseWorld = { h: worldH, y: worldY };
                    
                    let endPoint = sectionTransform.currentMouseWorld;
                    if (sectionTransform.isOrtho) {
                        endPoint = applySectionOrtho(sectionTransform.measurePoints[0], endPoint);
                    }
                    
                    const start = sectionTransform.measurePoints[0];
                    const dist = Math.sqrt(Math.pow(endPoint.h - start.h, 2) + Math.pow(endPoint.y - start.y, 2));
                    
                    const label = document.getElementById('section-measure-label');
                    label.style.display = 'block';
                    label.style.left = (e.clientX + 15) + 'px';
                    label.style.top = (e.clientY - 10) + 'px';
                    label.textContent = dist.toFixed(3) + 'm';
                    
                    drawSectionView();
                }
            }
            
            if (sectionTransform.isPanning) {
                const dx = x - sectionTransform.lastMouseX;
                const dy = y - sectionTransform.lastMouseY;
                sectionTransform.offsetX += dx;
                sectionTransform.offsetY += dy;
                sectionTransform.lastMouseX = x;
                sectionTransform.lastMouseY = y;
                drawSectionView();
            }
        }
        
        function onSectionMouseUp(e) {
            if (sectionTransform.isPanning) {
                sectionTransform.isPanning = false;
                sectionCanvas.style.cursor = sectionTransform.isMeasuring ? 'crosshair' : 'default';
            }
            
            if (!sectionTransform.isMeasuring && !sectionTransform.isPanning) {
                const rect = sectionCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                selectSectionElement(x, y);
            }
        }
        
        function onSectionDoubleClick() {
            resetSectionView();
        }
        
        function selectSectionElement(x, y) {
            sectionLines = [];
            const bounds = sectionCache.lastBounds;
            
            sectionCache.elements.forEach(elem => {
                const x1 = sectionWorldToCanvasX(elem.minH, bounds);
                const y1 = sectionWorldToCanvasY(elem.box.max.y, bounds);
                const x2 = sectionWorldToCanvasX(elem.maxH, bounds);
                const y2 = sectionWorldToCanvasY(elem.box.min.y, bounds);
                sectionLines.push({ node: elem.node, bounds: { minX: x1, maxX: x2, minY: y1, maxY: y2 } });
            });
            
            for (const line of sectionLines) {
                if (x >= line.bounds.minX && x <= line.bounds.maxX &&
                    y >= line.bounds.minY && y <= line.bounds.maxY) {
                    sectionSelectedLine = line;
                    selectObject(line.node);
                    drawSectionView();
                    return;
                }
            }
            
            sectionSelectedLine = null;
            drawSectionView();
        }
        
        function toggleSectionMeasure() {
            sectionTransform.isMeasuring = !sectionTransform.isMeasuring;
            sectionTransform.measurePoints = [];
            const btn = document.getElementById('btn-section-measure');
            
            if (sectionTransform.isMeasuring) {
                btn.classList.add('active');
                sectionCanvas.style.cursor = 'crosshair';
                let status = '📏 Modo Medição ATIVO';
                if (sectionTransform.isOrtho) status += ' | ORTHO';
                if (sectionTransform.isSnap) status += ' | SNAP';
                showToast(status);
            } else {
                btn.classList.remove('active');
                sectionCanvas.style.cursor = 'default';
                document.getElementById('section-measure-label').style.display = 'none';
                showToast('📏 Modo Medição desativado');
            }
        }
        
        function toggleSectionOrtho() {
            sectionTransform.isOrtho = !sectionTransform.isOrtho;
            const btn = document.getElementById('btn-section-ortho');
            if (sectionTransform.isOrtho) {
                btn.classList.add('active');
                showToast('⊥ Modo ORTHO ativado (H/V)');
            } else {
                btn.classList.remove('active');
                showToast('⊥ Modo ORTHO desativado');
            }
        }
        
        function toggleSectionSnap() {
            sectionTransform.isSnap = !sectionTransform.isSnap;
            const btn = document.getElementById('btn-section-snap');
            if (sectionTransform.isSnap) {
                btn.classList.add('active');
                showToast('🎯 SNAP ativado');
            } else {
                btn.classList.remove('active');
                showToast('🎯 SNAP desativado');
            }
        }
        
        function clearSectionMeasurements() {
            sectionTransform.measureLines = [];
            sectionTransform.measurePoints = [];
            drawSectionView();
            showToast('🗑️ Medições do corte limpas');
        }
        
        function resetSectionView() {
            sectionTransform.scale = 1;
            sectionTransform.offsetX = 0;
            sectionTransform.offsetY = 0;
            sectionCache.needsUpdate = true;
            drawSectionView();
        }
        
        function applySectionOrtho(start, end) {
            if (!sectionTransform.isOrtho) return end;
            
            const dh = Math.abs(end.h - start.h);
            const dy = Math.abs(end.y - start.y);
            
            if (dh >= dy) {
                return { h: end.h, y: start.y };
            } else {
                return { h: start.h, y: end.y };
            }
        }
        
        function snapToSectionCorner(worldH, worldY) {
            if (!sectionTransform.isSnap || !sectionCache.elements) return { h: worldH, y: worldY };
            
            let minDist = 0.5;
            let snapPoint = { h: worldH, y: worldY };
            
            sectionCache.elements.forEach(elem => {
                const corners = [
                    { h: elem.minH, y: elem.box.min.y },
                    { h: elem.minH, y: elem.box.max.y },
                    { h: elem.maxH, y: elem.box.min.y },
                    { h: elem.maxH, y: elem.box.max.y },
                    { h: (elem.minH + elem.maxH) / 2, y: elem.box.min.y },
                    { h: (elem.minH + elem.maxH) / 2, y: elem.box.max.y },
                    { h: elem.minH, y: (elem.box.min.y + elem.box.max.y) / 2 },
                    { h: elem.maxH, y: (elem.box.min.y + elem.box.max.y) / 2 },
                    { h: (elem.minH + elem.maxH) / 2, y: (elem.box.min.y + elem.box.max.y) / 2 }
                ];
                
                corners.forEach(c => {
                    const d = Math.sqrt(Math.pow(c.h - worldH, 2) + Math.pow(c.y - worldY, 2));
                    if (d < minDist) {
                        minDist = d;
                        snapPoint = c;
                    }
                });
            });
            
            return snapPoint;
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);

            // Usar pointer events para melhor controle
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            renderer.domElement.addEventListener('pointermove', onMouseMove);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);
            document.addEventListener('keydown', onKeyDown);
        }

        function onWindowResize() {
            const container = document.getElementById('viewer-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);

            if (isPlanViewActive && planCanvas) {
                planCanvas.width = planCanvas.parentElement.clientWidth;
                planCanvas.height = planCanvas.parentElement.clientHeight;
                planCache.needsUpdate = true;
                drawFloorPlanOptimized();
            }
        }

        function onPointerDown(event) {
            // Só registrar para botão esquerdo
            if (event.button !== 0) return;
            mouseDownX = event.clientX;
            mouseDownY = event.clientY;
        }

        function onPointerUp(event) {
            // Só processar botão esquerdo
            if (event.button !== 0) return;

            // Calcular distância do mouse desde o pointerdown
            const dx = event.clientX - mouseDownX;
            const dy = event.clientY - mouseDownY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Ignorar se houve movimento significativo (usuário estava girando/pan)
            if (distance > DRAG_THRESHOLD) {
                return;
            }

            if (isMeasuring) {
                if (!measureMarker.visible) return;
                if (measureStep === 0) {
                    measureStart.copy(measureMarker.position);
                    measureStep = 1;
                    showToast('📏 Primeiro ponto marcado. Clique no segundo ponto.');
                } else {
                    let endPos = measureMarker.position.clone();
                    // Aplicar ORTHO se ativo
                    endPos = applyOrtho(measureStart, endPos);
                    measureEnd.copy(endPos);
                    
                    const dist = measureStart.distanceTo(measureEnd);
                    
                    // Criar medição permanente estilo AutoCAD
                    addPermanentMeasurement(measureStart.clone(), measureEnd.clone(), dist);
                    
                    showToast(`📏 Distância: ${dist.toFixed(3)}m`);
                    measureStep = 0;
                    measureLine.visible = false;
                }
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            const hit = intersects.find(i => i.object.isMesh && i.object.visible &&
                i.object !== measureMarker && i.object !== cutPlaneMesh);

            if (hit) {
                selectObject(hit.object);
            } else {
                deselect();
            }
        }

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (isMeasuring) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                const snapPos = getClosestVertex(intersects);

                if (snapPos) {
                    measureMarker.visible = true;
                    
                    // Aplicar ORTHO se está no segundo ponto
                    let displayPos = snapPos;
                    if (measureStep === 1 && isOrthoMode) {
                        displayPos = applyOrtho(measureStart, snapPos);
                    }
                    measureMarker.position.copy(displayPos);

                    if (measureStep === 1) {
                        measureLine.geometry.setFromPoints([measureStart, displayPos]);
                        measureLine.visible = true;
                        const dist = measureStart.distanceTo(displayPos);
                        const lbl = document.getElementById('measure-label');
                        lbl.style.display = 'block';
                        lbl.innerText = dist.toFixed(3) + " m";
                        lbl.style.left = (event.clientX + 15) + 'px';
                        lbl.style.top = (event.clientY + 15) + 'px';
                    }
                } else {
                    measureMarker.visible = false;
                }
            }
        }

        function onDoubleClick() {
            deselect();
        }

        function onKeyDown(event) {
            if (event.key === 'Escape') {
                if (isMeasuring) {
                    toggleMeasure();
                } else {
                    deselect();
                }
            }
            if (event.key === 'r' || event.key === 'R') {
                resetView();
            }
        }

        // ==========================================
        // SELECTION
        // ==========================================
        function selectObject(mesh) {
            if (selectedObject && selectedObject !== mesh) {
                if (originalMaterials.has(selectedObject.uuid)) {
                    selectedObject.material = originalMaterials.get(selectedObject.uuid).clone();
                    selectedObject.material.transparent = globalTransparency < 1;
                    selectedObject.material.opacity = globalTransparency;
                }
                clearDimensionLabels();
            }

            selectedObject = mesh;

            const highlight = new THREE.MeshStandardMaterial({
                color: 0x007AFF,
                emissive: 0x003366,
                transparent: true,
                opacity: 0.9
            });
            mesh.material = highlight;

            showProperties(mesh);
            showDimensionLabels(mesh);
            showInfoPanel(mesh);

            // Sync with plan view
            if (isPlanViewActive) {
                planSelectedLine = planCache.elements.find(e => e.node === mesh) || null;
                drawFloorPlanOptimized();
            }

            switchTab('properties');
        }

        function deselect() {
            if (selectedObject) {
                if (originalMaterials.has(selectedObject.uuid)) {
                    selectedObject.material = originalMaterials.get(selectedObject.uuid).clone();
                    selectedObject.material.transparent = globalTransparency < 1;
                    selectedObject.material.opacity = globalTransparency;
                }
                selectedObject = null;
            }

            clearDimensionLabels();
            hideInfoPanel();

            document.getElementById('properties-container').innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: #999;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">👆</div>
                    <p>Clique em um elemento para ver suas propriedades</p>
                </div>
            `;

            if (isPlanViewActive) {
                planSelectedLine = null;
                drawFloorPlanOptimized();
            }
        }

        function hideCurrent() {
            if (selectedObject) {
                selectedObject.visible = false;
                hiddenObjects.add(selectedObject.uuid);
                deselect();
                planCache.needsUpdate = true;
                if (isPlanViewActive) drawFloorPlanOptimized();
                updateQuantitiesPanel();
            }
        }

        function showAll() {
            if (!loadedModel) return;
            loadedModel.traverse((node) => {
                if (node.isMesh) node.visible = true;
            });
            hiddenObjects.clear();
            filterState.types = new Set(['Pilar', 'Viga', 'Laje', 'Parede', 'Fundação', 'Estaca', 'Cabos', 'Outros']);
            filterState.levels.clear();
            filterState.searchQuery = '';
            planCache.needsUpdate = true;
            if (isPlanViewActive) drawFloorPlanOptimized();
            updateQuantitiesPanel();
            renderFiltersPanel();
            showToast('👁️ Todos os elementos visíveis');
        }

        // ==========================================
        // DIMENSION LABELS
        // ==========================================
        function showDimensionLabels(mesh) {
            clearDimensionLabels();

            const box = new THREE.Box3().setFromObject(mesh);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            if (size.x > 0.05) {
                const label = createTextSprite(`${size.x.toFixed(2)}m`,
                    new THREE.Vector3(center.x, box.min.y - 0.2, box.max.z + 0.3), '#e74c3c');
                dimensionLabels.push(label);
                scene.add(label);
            }

            if (size.z > 0.05) {
                const label = createTextSprite(`${size.z.toFixed(2)}m`,
                    new THREE.Vector3(box.max.x + 0.3, box.min.y - 0.2, center.z), '#27ae60');
                dimensionLabels.push(label);
                scene.add(label);
            }

            if (size.y > 0.05) {
                const label = createTextSprite(`${size.y.toFixed(2)}m`,
                    new THREE.Vector3(box.max.x + 0.3, center.y, box.max.z + 0.3), '#3498db');
                dimensionLabels.push(label);
                scene.add(label);
            }
        }

        function createTextSprite(text, position, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 48;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.beginPath();
            ctx.roundRect(2, 2, 124, 44, 6);
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 24);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(1, 0.4, 1);
            sprite.renderOrder = 1000;
            return sprite;
        }

        function clearDimensionLabels() {
            dimensionLabels.forEach(label => {
                scene.remove(label);
                if (label.material.map) label.material.map.dispose();
                label.material.dispose();
            });
            dimensionLabels = [];
        }

        // ==========================================
        // PROPERTIES PANEL
        // ==========================================
        function showProperties(mesh) {
            const container = document.getElementById('properties-container');
            const info = mesh.userData.info || {};

            const nome = info.nome || mesh.name || 'Elemento';
            const tipo = info.tipo || 'Outros';
            const guid = info.guid || mesh.name || '-';
            const storey = info.storey || '';
            const elevation = info.elevation;
            const vol = (info.volume || 0).toFixed(3);
            const comp = (info.comp || 0).toFixed(2);
            const larg = (info.larg || 0).toFixed(2);
            const alt = (info.alt || 0).toFixed(2);

            let areaHtml = '';
            if (tipo === 'Laje' || (info.area && info.area > 0)) {
                areaHtml = `
                    <div class="prop-row">
                        <span class="prop-label">Área:</span>
                        <span class="prop-value" style="color: #27ae60;">${(info.area || 0).toFixed(2)} m²</span>
                    </div>
                `;
            }
            
            // Tipologia de laje
            let tipoLajeHtml = '';
            if (tipo === 'Laje' && info.tipoLaje) {
                const tipoLajeColors = {
                    'Maciça': '#3498db',
                    'Nervurada': '#9b59b6',
                    'Treliçada': '#8e44ad',
                    'Treliçada 1D': '#9b59b6',
                    'Treliçada 2D': '#8e44ad',
                    'Alveolar': '#e67e22',
                    'Steel Deck': '#34495e',
                    'Laje': '#95a5a6'
                };
                const cor = tipoLajeColors[info.tipoLaje] || '#666';
                tipoLajeHtml = `
                    <div class="prop-row" style="background: linear-gradient(135deg, ${cor}15, ${cor}05); border-radius: 4px; padding: 6px 8px; margin-top: 4px;">
                        <span class="prop-label">🏗️ Tipologia:</span>
                        <span class="prop-value" style="color: ${cor}; font-weight: bold;">${info.tipoLaje}</span>
                    </div>
                `;
            }
            
            // Área de forma para pilares e vigas
            let areaFormaHtml = '';
            
            // Seção especial para protensão
            let protensaoHtml = '';
            if (tipo === 'Cabos' || tipo === 'Ancoragem') {
                const tendonData = mesh.userData.tendonData || {};
                const numCord = tendonData.numCordoalhas || info.numCabos || 1;
                const compTotal = tendonData.comprimentoTotal || info.comp || 0;
                const compPorCord = tendonData.comprimentoPorCordoalha || (compTotal / numCord) || 0;
                const diamMm = tendonData.diametroMm || info.diametro || 15.2;
                const pesoTotal = tendonData.pesoTotal || info.pesoProtensao || 0;
                const pesoPorM = tendonData.pesoPorMetro || (diamMm >= 15 ? 1.126 : 0.792);
                
                protensaoHtml = `
                <div class="prop-group" style="background: linear-gradient(135deg, #e3f2fd, #bbdefb); border: 1px solid #64b5f6; border-radius: 8px;">
                    <div class="prop-header" style="color: #1565c0;">
                        <span>🔗 Protensão</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Cordoalhas:</span>
                        <span class="prop-value" style="font-size: 1.2rem; font-weight: bold; color: #1565c0;">\${numCord}</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Diâmetro:</span>
                        <span class="prop-value">Ø\${diamMm.toFixed(1)} mm</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Comp. por cordoalha:</span>
                        <span class="prop-value">\${compPorCord.toFixed(2)} m</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Comp. total:</span>
                        <span class="prop-value" style="font-weight: bold;">\${compTotal.toFixed(2)} m</span>
                    </div>
                    <div class="prop-row" style="background: #fff; border-radius: 4px; padding: 8px; margin-top: 4px;">
                        <span class="prop-label">Peso total:</span>
                        <span class="prop-value" style="font-size: 1.1rem; font-weight: bold; color: #c62828;">\${pesoTotal.toFixed(2)} kg</span>
                    </div>
                    <div style="font-size: 0.65rem; color: #666; margin-top: 4px; text-align: right;">
                        CP190 RB @ \${pesoPorM} kg/m
                    </div>
                </div>
                `;
            }
            const tipoLower = tipo.toLowerCase();
            if (tipoLower.includes('pilar') || tipoLower.includes('column')) {
                // Pilar: 4 faces laterais (sem topo nem base)
                // Perímetro × altura = 2 × (larg + comp) × alt
                const areaForma = 2 * ((info.larg || 0) + (info.comp || 0)) * (info.alt || 0);
                areaFormaHtml = `
                    <div class="prop-row" style="background: linear-gradient(135deg, #fff8e1, #ffecb3); border-radius: 4px; padding: 6px 8px; margin-top: 4px;">
                        <span class="prop-label">📐 Área de Forma:</span>
                        <span class="prop-value" style="color: #e65100; font-weight: bold;">${areaForma.toFixed(2)} m²</span>
                    </div>
                    <div style="font-size: 0.65rem; color: #888; margin-top: 2px; padding-left: 4px;">
                        4 faces laterais (sem topo/base)
                    </div>
                `;
            } else if (tipoLower.includes('viga') || tipoLower.includes('beam')) {
                // Viga: 2 laterais + fundo (sem topo)
                // (2 × altura + largura) × comprimento
                const areaForma = (2 * (info.alt || 0) + (info.larg || 0)) * (info.comp || 0);
                areaFormaHtml = `
                    <div class="prop-row" style="background: linear-gradient(135deg, #fff8e1, #ffecb3); border-radius: 4px; padding: 6px 8px; margin-top: 4px;">
                        <span class="prop-label">📐 Área de Forma:</span>
                        <span class="prop-value" style="color: #e65100; font-weight: bold;">${areaForma.toFixed(2)} m²</span>
                    </div>
                    <div style="font-size: 0.65rem; color: #888; margin-top: 2px; padding-left: 4px;">
                        2 laterais + fundo (sem topo)
                    </div>
                `;
            }

            // Seção de localização (pavimento)
            let locationHtml = '';
            if (storey || elevation !== null) {
                locationHtml = `
                <div class="prop-group">
                    <div class="prop-header">
                        <span>🏢 Localização</span>
                    </div>
                    ${storey ? `
                    <div class="prop-row">
                        <span class="prop-label">Pavimento:</span>
                        <span class="prop-value" style="color: #9b59b6;">${storey}</span>
                    </div>
                    ` : ''}
                    ${elevation !== null ? `
                    <div class="prop-row">
                        <span class="prop-label">Elevação:</span>
                        <span class="prop-value">${elevation.toFixed(2)} m</span>
                    </div>
                    ` : ''}
                </div>
                `;
            }

            container.innerHTML = `
                <div class="prop-group">
                    <div class="prop-header">
                        <span>📋 Identificação</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Nome:</span>
                        <span class="prop-value">${nome}</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Tipo:</span>
                        <span class="prop-value">${tipo}</span>
                    </div>
                    ${tipoLajeHtml}
                    <div class="prop-row">
                        <span class="prop-label">GUID:</span>
                        <span class="prop-value" style="font-size: 0.7rem; color: #888;">${guid}</span>
                    </div>
                </div>

                ${locationHtml}

                <div class="prop-group">
                    <div class="prop-header">
                        <span>📐 Dimensões</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Largura (X):</span>
                        <span class="prop-value">${larg} m</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Comprimento (Z):</span>
                        <span class="prop-value">${comp} m</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Altura (Y):</span>
                        <span class="prop-value">${alt} m</span>
                    </div>
                </div>

                <div class="prop-group">
                    <div class="prop-header">
                        <span>📊 Quantitativos</span>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Volume:</span>
                        <span class="prop-value" style="color: #007AFF; font-size: 1rem;">${vol} m³</span>
                    </div>
                    ${areaHtml}
                    ${areaFormaHtml}
                </div>

                <button class="btn-action btn-hide" onclick="hideCurrent()">
                    🚫 Ocultar Elemento
                </button>
                
                <button class="btn-action btn-secondary" onclick="zoomToSelected()">
                    🔍 Zoom no Elemento
                </button>
            `;
        }

        function showInfoPanel(mesh) {
            const info = mesh.userData.info || {};
            const panel = document.getElementById('info-panel');

            document.getElementById('info-volume').textContent = (info.volume || 0).toFixed(3) + ' m³';
            document.getElementById('info-dimensions').textContent =
                `${(info.larg || 0).toFixed(2)} × ${(info.comp || 0).toFixed(2)} × ${(info.alt || 0).toFixed(2)} m`;

            panel.style.display = 'block';
        }

        function hideInfoPanel() {
            document.getElementById('info-panel').style.display = 'none';
        }

        function zoomToSelected() {
            if (!selectedObject) return;

            const box = new THREE.Box3().setFromObject(selectedObject);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = Math.max(maxDim * 3, 3);

            const targetPos = new THREE.Vector3(
                center.x + distance * 0.7,
                center.y + distance * 0.5,
                center.z + distance * 0.7
            );

            animateCameraTo(targetPos, center);
        }

        // ==========================================
        // QUANTITIES PANEL
        // ==========================================
        function generateQuantitySummary() {
            const summary = {
                pilares: { count: 0, volume: 0, areaForma: 0, items: [] },
                vigas: { count: 0, volume: 0, areaForma: 0, items: [] },
                lajes: { count: 0, volume: 0, area: 0, items: [], byType: {}, byHeight: {}, byTypeHeight: {}, byStoreyTypeHeight: {} },
                paredes: { count: 0, volume: 0, items: [] },
                fundacoes: { count: 0, volume: 0, items: [] },
                estacas: { count: 0, volume: 0, items: [] },
                tendons: { count: 0, totalCabos: 0, comprimento: 0, comprimentoTotal: 0, peso152: 0, peso127: 0, items: [] },
                outros: { count: 0, volume: 0, items: [] }
            };

            if (!loadedModel) return summary;

            loadedModel.traverse((node) => {
                if (node.isMesh && node.visible && node.userData.info) {
                    const info = node.userData.info;
                    const tipo = (info.tipo || '').toLowerCase();
                    
                    // Dimensões do elemento
                    const comp = info.comp || 0;
                    const larg = info.larg || 0;
                    const alt = info.alt || 0;
                    
                    // Calcular área de forma baseado no tipo
                    let areaForma = 0;
                    if (tipo.includes('pilar') || tipo.includes('column')) {
                        // Pilar: 4 faces laterais (sem topo nem base)
                        // Perímetro × altura = 2 × (larg + prof) × alt
                        // Para pilares: comp e larg são a seção, alt é a altura
                        areaForma = 2 * (comp + larg) * alt;
                    } else if (tipo.includes('viga') || tipo.includes('beam')) {
                        // Viga: 2 laterais + fundo (sem topo - laje fecha)
                        // (2 × altura + largura) × comprimento
                        // Para vigas: comp é comprimento, alt é altura da seção, larg é largura
                        areaForma = (2 * alt + larg) * comp;
                    }
                    
                    const item = {
                        uuid: node.uuid,
                        nome: info.nome || 'Sem nome',
                        tipo: info.tipo || 'Outros',
                        volume: info.volume || 0,
                        area: info.area || 0,
                        areaForma: areaForma,
                        comp: comp,
                        larg: larg,
                        alt: alt,
                        storey: info.storey || '',
                        tipoLaje: info.tipoLaje || '',
                        diametro: info.diametro || 0,
                        numCabos: info.numCabos || 1,
                        pesoProtensao: info.pesoProtensao || 0
                    };

                    if (tipo.includes('pilar') || tipo.includes('column')) {
                        summary.pilares.count++;
                        summary.pilares.volume += item.volume;
                        summary.pilares.areaForma += areaForma;
                        summary.pilares.items.push(item);
                    } else if (tipo.includes('viga') || tipo.includes('beam')) {
                        summary.vigas.count++;
                        summary.vigas.volume += item.volume;
                        summary.vigas.areaForma += areaForma;
                        summary.vigas.items.push(item);
                    } else if (tipo.includes('laje') || tipo.includes('slab')) {
                        summary.lajes.count++;
                        summary.lajes.volume += item.volume;
                        summary.lajes.area += item.area;
                        summary.lajes.items.push(item);
                        
                        // Agrupar por tipo de laje
                        const tipoLaje = item.tipoLaje || 'Outros';
                        if (!summary.lajes.byType[tipoLaje]) {
                            summary.lajes.byType[tipoLaje] = { count: 0, area: 0, volume: 0 };
                        }
                        summary.lajes.byType[tipoLaje].count++;
                        summary.lajes.byType[tipoLaje].area += item.area;
                        summary.lajes.byType[tipoLaje].volume += item.volume;
                        
                        // Agrupar por altura (espessura)
                        const alturaKey = (item.alt * 100).toFixed(0) + 'cm';
                        if (!summary.lajes.byHeight[alturaKey]) {
                            summary.lajes.byHeight[alturaKey] = { count: 0, area: 0, volume: 0 };
                        }
                        summary.lajes.byHeight[alturaKey].count++;
                        summary.lajes.byHeight[alturaKey].area += item.area;
                        summary.lajes.byHeight[alturaKey].volume += item.volume;
                        
                        // Agrupar por tipo + altura (para tabela resumo)
                        const alturaCm = Math.round(item.alt * 100);
                        const typeHeightKey = tipoLaje + '|' + alturaCm;
                        if (!summary.lajes.byTypeHeight[typeHeightKey]) {
                            summary.lajes.byTypeHeight[typeHeightKey] = { 
                                tipo: tipoLaje, 
                                altura: alturaCm, 
                                count: 0, 
                                area: 0, 
                                volume: 0 
                            };
                        }
                        summary.lajes.byTypeHeight[typeHeightKey].count++;
                        summary.lajes.byTypeHeight[typeHeightKey].area += item.area;
                        summary.lajes.byTypeHeight[typeHeightKey].volume += item.volume;
                        
                        // Agrupar por pavimento + tipo + altura (para tabela por pavimento)
                        const storey = item.storey || 'Sem Pavimento';
                        const storeyTypeHeightKey = storey + '|' + tipoLaje + '|' + alturaCm;
                        if (!summary.lajes.byStoreyTypeHeight[storeyTypeHeightKey]) {
                            summary.lajes.byStoreyTypeHeight[storeyTypeHeightKey] = { 
                                storey: storey,
                                tipo: tipoLaje, 
                                altura: alturaCm, 
                                count: 0, 
                                area: 0, 
                                volume: 0 
                            };
                        }
                        summary.lajes.byStoreyTypeHeight[storeyTypeHeightKey].count++;
                        summary.lajes.byStoreyTypeHeight[storeyTypeHeightKey].area += item.area;
                        summary.lajes.byStoreyTypeHeight[storeyTypeHeightKey].volume += item.volume;
                        
                    } else if (tipo.includes('parede') || tipo.includes('wall')) {
                        summary.paredes.count++;
                        summary.paredes.volume += item.volume;
                        summary.paredes.items.push(item);
                    } else if (tipo.includes('estaca') || tipo.includes('pile')) {
                        summary.estacas.count++;
                        summary.estacas.volume += item.volume;
                        summary.estacas.items.push(item);
                    } else if (tipo.includes('fundação') || tipo.includes('sapata') || tipo.includes('footing')) {
                        summary.fundacoes.count++;
                        summary.fundacoes.volume += item.volume;
                        summary.fundacoes.items.push(item);
                    } else if (tipo.includes('tendon') || tipo.includes('cabo') || tipo.includes('protensão')) {
                        // Pegar dados de protensão (preferir tendonData extraído do IFC)
                        const tendonData = node.userData.tendonData || {};
                        const numCord = tendonData.numCordoalhas || item.numCabos || 1;
                        const compTotal = tendonData.comprimentoTotal || item.comp || 0;
                        const compPorCord = tendonData.comprimentoPorCordoalha || (compTotal / numCord) || 0;
                        const pesoTotal = tendonData.pesoTotal || item.pesoProtensao || 0;
                        const diamMm = tendonData.diametroMm || item.diametro || 15.2;
                        
                        // Atualizar item com dados corretos
                        item.numCabos = numCord;
                        item.comp = compTotal;
                        item.compPorCordoalha = compPorCord;
                        item.pesoProtensao = pesoTotal;
                        item.diametro = diamMm;
                        
                        summary.tendons.count++; // Número de cabos
                        summary.tendons.totalCabos += numCord; // Total de cordoalhas
                        summary.tendons.comprimento += compPorCord; // Comprimento médio por cordoalha
                        summary.tendons.comprimentoTotal += compTotal; // Comprimento total de cabo
                        summary.tendons.items.push(item);
                        
                        // Separar peso por diâmetro
                        if (diamMm >= 15) {
                            summary.tendons.peso152 += pesoTotal;
                        } else {
                            summary.tendons.peso127 += pesoTotal;
                        }
                    } else {
                        summary.outros.count++;
                        summary.outros.volume += item.volume;
                        summary.outros.items.push(item);
                    }
                }
            });

            return summary;
        }

        function updateQuantitiesPanel() {
            const container = document.getElementById('quantities-container');
            const summary = generateQuantitySummary();
            // Volume total de concreto (exclui tendons que não são concreto)
            const totalVolume = summary.pilares.volume + summary.vigas.volume + summary.lajes.volume + 
                               summary.paredes.volume + summary.fundacoes.volume + summary.estacas.volume + 
                               summary.outros.volume;
            // Contagem total de elementos (exclui tendons)
            const totalCount = summary.pilares.count + summary.vigas.count + summary.lajes.count + 
                              summary.paredes.count + summary.fundacoes.count + summary.estacas.count + 
                              summary.outros.count;
            // Área de forma total (pilares + vigas)
            const totalForma = summary.pilares.areaForma + summary.vigas.areaForma;

            container.innerHTML = `
                <div class="qty-total-card">
                    <div class="qty-total-label">Volume Total de Concreto</div>
                    <div class="qty-total-value">${totalVolume.toFixed(2)}</div>
                    <div class="qty-total-unit">metros cúbicos (m³)</div>
                </div>

                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <div style="flex: 1; background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 1.5rem; font-weight: bold; color: #333;">${totalCount}</div>
                        <div style="font-size: 0.75rem; color: #666;">Elementos</div>
                    </div>
                    <div style="flex: 1; background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 1.5rem; font-weight: bold; color: #333;">${summary.lajes.area.toFixed(1)}</div>
                        <div style="font-size: 0.75rem; color: #666;">m² Lajes</div>
                    </div>
                </div>
                
                ${totalForma > 0 ? `
                <div style="background: linear-gradient(135deg, #fff8e1, #ffecb3); padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #ffc107;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 0.75rem; color: #f57c00; font-weight: 500;">📐 Área de Forma Total</div>
                            <div style="font-size: 0.65rem; color: #666; margin-top: 2px;">Pilares + Vigas (sem lajes)</div>
                        </div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #e65100;">${totalForma.toFixed(1)} m²</div>
                    </div>
                </div>
                ` : ''}

                ${renderQtySection('🔲 Pilares', summary.pilares, 'pilares', false, true)}
                ${renderQtySection('━━ Vigas', summary.vigas, 'vigas', false, true)}
                ${renderLajesSection(summary.lajes)}
                ${renderQtySection('🧱 Paredes', summary.paredes, 'paredes')}
                ${renderQtySection('⬛ Fundações', summary.fundacoes, 'fundacoes')}
                ${summary.outros.count > 0 ? renderQtySection('📦 Outros', summary.outros, 'outros') : ''}
                ${summary.tendons.count > 0 ? renderTendonsSection(summary.tendons) : ''}

                <button onclick="openExportModal()" class="btn-action btn-primary" style="margin-top: 15px;">
                    📥 Exportar Quantitativos
                </button>
            `;
        }

        function renderQtySection(title, data, id, showArea = false, showForma = false) {
            if (data.count === 0) return '';
            return `
                <div class="qty-section">
                    <div class="qty-section-header" onclick="toggleQtySection('${id}')">
                        <span class="qty-section-title">${title}</span>
                        <span class="qty-section-badge">${data.count} un</span>
                    </div>
                    <div class="qty-section-content" id="qty-content-${id}">
                        <div class="qty-row">
                            <span class="qty-row-label">Volume Total:</span>
                            <span class="qty-row-value">${data.volume.toFixed(3)} m³</span>
                        </div>
                        ${showArea && data.area > 0 ? `
                        <div class="qty-row">
                            <span class="qty-row-label">Área Total:</span>
                            <span class="qty-row-value">${data.area.toFixed(2)} m²</span>
                        </div>
                        ` : ''}
                        ${showForma && data.areaForma > 0 ? `
                        <div class="qty-row" style="background: #fff8e1; padding: 6px 8px; border-radius: 4px; margin-top: 4px;">
                            <span class="qty-row-label">📐 Área de Forma:</span>
                            <span class="qty-row-value" style="color: #f57c00; font-weight: bold;">${data.areaForma.toFixed(2)} m²</span>
                        </div>
                        ` : ''}
                        <button onclick="filterByCategory('${id}')" class="btn-action btn-sm btn-secondary" style="margin-top: 8px;">
                            👁️ Mostrar apenas estes
                        </button>
                    </div>
                </div>
            `;
        }
        
        function renderLajesSection(data) {
            if (data.count === 0) return '';
            
            // Agrupar por pavimento
            const byStorey = {};
            Object.values(data.byStoreyTypeHeight || {}).forEach(item => {
                const storey = item.storey || 'Sem Pavimento';
                if (!byStorey[storey]) {
                    byStorey[storey] = [];
                }
                byStorey[storey].push(item);
            });
            
            // Ordenar pavimentos
            const storeys = Object.keys(byStorey).sort();
            
            // Gerar tabelas por pavimento
            let storeyTables = '';
            let totalGeralArea = 0;
            
            storeys.forEach(storey => {
                const items = byStorey[storey].sort((a, b) => {
                    if (a.tipo !== b.tipo) return a.tipo.localeCompare(b.tipo);
                    return a.altura - b.altura;
                });
                
                let rows = '';
                let subtotal = 0;
                
                items.forEach(item => {
                    rows += `
                        <tr>
                            <td style="padding: 5px 8px; border-bottom: 1px solid #eee;">${item.tipo || 'Laje'}</td>
                            <td style="padding: 5px 8px; border-bottom: 1px solid #eee; text-align: center;">${item.altura}</td>
                            <td style="padding: 5px 8px; border-bottom: 1px solid #eee; text-align: right;">${item.area.toFixed(2)}</td>
                        </tr>
                    `;
                    subtotal += item.area;
                });
                
                totalGeralArea += subtotal;
                
                storeyTables += `
                    <div style="margin-bottom: 10px;">
                        <div style="background: #e3f2fd; padding: 6px 10px; font-weight: 600; font-size: 0.8rem; color: #1565c0; border-radius: 4px 4px 0 0;">
                            🏢 ${storey}
                        </div>
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.75rem; border: 1px solid #e0e0e0; border-top: none;">
                            <thead>
                                <tr style="background: #fafafa;">
                                    <th style="padding: 5px 8px; text-align: left; font-weight: 600;">Tipo</th>
                                    <th style="padding: 5px 8px; text-align: center; font-weight: 600;">h (cm)</th>
                                    <th style="padding: 5px 8px; text-align: right; font-weight: 600;">Área (m²)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${rows}
                                <tr style="background: #e8f5e9; font-weight: 600;">
                                    <td colspan="2" style="padding: 5px 8px;">Subtotal</td>
                                    <td style="padding: 5px 8px; text-align: right; color: #2e7d32;">${subtotal.toFixed(2)}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                `;
            });
            
            // Gerar resumo geral
            const resumoGeral = Object.values(data.byTypeHeight || {}).sort((a, b) => {
                if (a.tipo !== b.tipo) return a.tipo.localeCompare(b.tipo);
                return a.altura - b.altura;
            });
            
            let resumoRows = '';
            resumoGeral.forEach(item => {
                resumoRows += `
                    <tr>
                        <td style="padding: 5px 8px; border-bottom: 1px solid #ddd;">${item.tipo || 'Laje'}</td>
                        <td style="padding: 5px 8px; border-bottom: 1px solid #ddd; text-align: center;">${item.altura}</td>
                        <td style="padding: 5px 8px; border-bottom: 1px solid #ddd; text-align: right; font-weight: 500;">${item.area.toFixed(2)}</td>
                    </tr>
                `;
            });
            
            return `
                <div class="qty-section">
                    <div class="qty-section-header" onclick="toggleQtySection('lajes')" style="background: linear-gradient(135deg, #43a047, #2e7d32);">
                        <span class="qty-section-title" style="color: white;">⬜ Lajes</span>
                        <span class="qty-section-badge" style="background: rgba(255,255,255,0.25); color: white;">${data.count} un</span>
                    </div>
                    <div class="qty-section-content" id="qty-content-lajes">
                        <div class="qty-row">
                            <span class="qty-row-label">Volume Total:</span>
                            <span class="qty-row-value">${data.volume.toFixed(3)} m³</span>
                        </div>
                        <div class="qty-row" style="margin-bottom: 12px;">
                            <span class="qty-row-label">Área Total:</span>
                            <span class="qty-row-value">${data.area.toFixed(2)} m²</span>
                        </div>
                        
                        <div style="border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; margin-bottom: 12px;">
                            <div style="background: #f5f5f5; padding: 8px 10px; font-weight: 600; font-size: 0.85rem; color: #333; border-bottom: 1px solid #e0e0e0;">
                                📊 Área de Lajes por Pavimento
                            </div>
                            <div style="padding: 10px; max-height: 300px; overflow-y: auto;">
                                ${storeyTables}
                            </div>
                        </div>
                        
                        <div style="border: 1px solid #4caf50; border-radius: 8px; overflow: hidden;">
                            <div style="background: #4caf50; padding: 8px 10px; font-weight: 600; font-size: 0.85rem; color: white;">
                                📋 Resumo Geral
                            </div>
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">
                                <thead>
                                    <tr style="background: #e8f5e9;">
                                        <th style="padding: 6px 8px; text-align: left; font-weight: 600;">Tipo</th>
                                        <th style="padding: 6px 8px; text-align: center; font-weight: 600;">h (cm)</th>
                                        <th style="padding: 6px 8px; text-align: right; font-weight: 600;">Área (m²)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${resumoRows}
                                    <tr style="background: #c8e6c9; font-weight: bold;">
                                        <td colspan="2" style="padding: 8px; border-top: 2px solid #4caf50;">TOTAL GERAL</td>
                                        <td style="padding: 8px; text-align: right; border-top: 2px solid #4caf50; color: #1b5e20; font-size: 1rem;">${totalGeralArea.toFixed(2)} m²</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <button onclick="filterByCategory('lajes')" class="btn-action btn-sm btn-secondary" style="margin-top: 10px;">
                            👁️ Mostrar apenas lajes
                        </button>
                    </div>
                </div>
            `;
        }

        function renderTendonsSection(data) {
            if (data.count === 0) return '';
            
            // Comprimento com acréscimo de 4% (ancoragens/perdas)
            const comprimentoComAcrescimo = data.comprimentoTotal * 1.075;
            
            // Peso com massa engraxada (Ø15.2mm: 1.24 kg/m, Ø12.7mm: 0.89 kg/m)
            const PESO_152_ENGRAXADA = 1.24;
            const PESO_127_ENGRAXADA = 0.89;
            const pesoEngraxado = comprimentoComAcrescimo * PESO_152_ENGRAXADA;
            
            return `
                <div class="qty-section">
                    <div class="qty-section-header" onclick="toggleQtySection('tendons')" style="background: linear-gradient(135deg, #1565c0, #0d47a1);">
                        <span class="qty-section-title" style="color: white;">🔗 Protensão</span>
                        <span class="qty-section-badge" style="background: rgba(255,255,255,0.25); color: white;">${data.totalCabos} cabos</span>
                    </div>
                    <div class="qty-section-content open" id="qty-content-tendons">
                        <div style="background: linear-gradient(135deg, #e3f2fd, #bbdefb); padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 12px;">
                            <div style="font-size: 2rem; font-weight: bold; color: #1565c0;">${data.totalCabos}</div>
                            <div style="font-size: 0.8rem; color: #1976d2; font-weight: 500;">Cabos de Protensão</div>
                        </div>
                        
                        <div class="qty-row" style="background: #fff3e0; padding: 8px 10px; border-radius: 6px; margin-bottom: 8px;">
                            <span class="qty-row-label" style="font-weight: 600;">📏 Comprimento Total (+7,5%):</span>
                            <span class="qty-row-value" style="font-weight: bold; font-size: 1.1rem; color: #e65100;">${comprimentoComAcrescimo.toFixed(2)} m</span>
                        </div>
                        
                        <div style="background: linear-gradient(135deg, #ffebee, #ffcdd2); padding: 12px; border-radius: 6px; border: 1px solid #ef9a9a;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 600; color: #c62828;">⚖️ Peso Total:</span>
                                <span style="font-size: 1.4rem; font-weight: bold; color: #b71c1c;">${pesoEngraxado.toFixed(2)} kg</span>
                            </div>
                        </div>
                        
                        <div style="font-size: 0.65rem; color: #888; margin-top: 8px; text-align: center;">
                            Cordoalha CP190 RB Ø15.2mm engraxada - 1.24 kg/m
                        </div>
                        
                        <button onclick="filterByCategory('tendons')" class="btn-action btn-sm btn-secondary" style="margin-top: 10px;">
                            👁️ Mostrar apenas cabos
                        </button>
                    </div>
                </div>
            `;
        }

        function toggleQtySection(id) {
            const content = document.getElementById(`qty-content-${id}`);
            content.classList.toggle('open');
        }

        function filterByCategory(category) {
            const categoryMap = {
                'pilares': 'Pilar',
                'vigas': 'Viga',
                'lajes': 'Laje',
                'paredes': 'Parede',
                'fundacoes': 'Fundação',
                'estacas': 'Estaca',
                'tendons': 'Cabos',
                'outros': 'Outros'
            };

            const tipo = categoryMap[category];
            if (!tipo || !loadedModel) return;

            loadedModel.traverse((node) => {
                if (node.isMesh && node.userData.info) {
                    node.visible = node.userData.info.tipo === tipo;
                }
            });

            planCache.needsUpdate = true;
            if (isPlanViewActive) drawFloorPlanOptimized();
            showToast(`👁️ Mostrando apenas: ${tipo}`);
        }

        // ==========================================
        // FILTERS PANEL
        // ==========================================
        function renderFiltersPanel() {
            // Agora os filtros estão no painel de controles
            if (controlsPanelOpen) {
                renderControlsFilters();
            }
        }
        // ==========================================
        // PAINEL DE CONTROLES - FILTROS E FERRAMENTAS
        // ==========================================
        
        let controlsPanelOpen = false;
        
        function toggleControlsPanel() {
            const panel = document.getElementById('controls-panel');
            const btn = document.getElementById('btn-controls');
            controlsPanelOpen = !controlsPanelOpen;
            
            if (controlsPanelOpen) {
                panel.classList.add('active');
                btn.classList.add('active');
                renderControlsFilters();
            } else {
                panel.classList.remove('active');
                btn.classList.remove('active');
            }
        }
        
        function renderControlsFilters() {
            // Renderizar chips de tipos
            const typesContainer = document.getElementById('type-filter-chips');
            const types = ['Pilar', 'Viga', 'Laje', 'Parede', 'Fundação', 'Estaca', 'Cabos', 'Outros'];
            
            // Contar elementos por tipo
            const typeCounts = {};
            types.forEach(t => typeCounts[t] = 0);
            if (loadedModel) {
                loadedModel.traverse((node) => {
                    if (node.isMesh && node.userData.info) {
                        const tipo = node.userData.info.tipo || 'Outros';
                        if (typeCounts.hasOwnProperty(tipo)) {
                            typeCounts[tipo]++;
                        } else {
                            typeCounts['Outros']++;
                        }
                    }
                });
            }
            
            typesContainer.innerHTML = types
                .filter(t => typeCounts[t] > 0)
                .map(tipo => `
                    <span class="control-chip ${filterState.types.has(tipo) ? 'active' : ''}" 
                          onclick="toggleTypeFilterControl('${tipo}', this)" 
                          data-tipo="${tipo}">
                        ${tipo} (${typeCounts[tipo]})
                    </span>
                `).join('');
            
            // Renderizar select de pavimentos
            const levelsSelect = document.getElementById('level-filter-select');
            const levels = detectLevels();
            
            levelsSelect.innerHTML = '<option value="all">Todos os pavimentos</option>' +
                levels.map(l => `<option value="${l.useStorey ? l.name : l.height}">${l.name} (${l.count} el.)</option>`).join('');
            
            // Atualizar slider de corte de altura
            updateCutHeightSliderControl();
        }
        
        function toggleTypeFilterControl(tipo, element) {
            if (filterState.types.has(tipo)) {
                filterState.types.delete(tipo);
                element.classList.remove('active');
            } else {
                filterState.types.add(tipo);
                element.classList.add('active');
            }
            applyFilters();
        }
        
        function selectAllTypesControl() {
            const types = ['Pilar', 'Viga', 'Laje', 'Parede', 'Fundação', 'Estaca', 'Cabos', 'Outros'];
            types.forEach(t => filterState.types.add(t));
            document.querySelectorAll('#type-filter-chips .control-chip').forEach(chip => {
                chip.classList.add('active');
            });
            applyFilters();
        }
        
        function deselectAllTypesControl() {
            filterState.types.clear();
            document.querySelectorAll('#type-filter-chips .control-chip').forEach(chip => {
                chip.classList.remove('active');
            });
            applyFilters();
        }
        
        function onLevelChangeControl(value) {
            onLevelChange(value);
        }
        
        function updateTransparencyControl(value) {
            const opacity = value / 100;
            document.getElementById('transparency-value').textContent = value + '%';
            updateTransparency(opacity);
        }
        
        function updateCutHeightSliderControl() {
            if (!loadedModel) return;
            
            const box = new THREE.Box3().setFromObject(loadedModel);
            const minY = box.min.y;
            const maxY = box.max.y;
            
            const slider = document.getElementById('control-cut-height-slider');
            slider.min = minY.toFixed(2);
            slider.max = maxY.toFixed(2);
            slider.value = maxY.toFixed(2);
            
            document.getElementById('cut-height-min').textContent = minY.toFixed(2) + 'm';
            document.getElementById('cut-height-value').textContent = maxY.toFixed(2) + 'm';
        }
        
        function updateCutHeightControl(value) {
            document.getElementById('cut-height-value').textContent = parseFloat(value).toFixed(2) + 'm';
            updateCutHeight(value);
        }
        
        function toggleCutPlaneVisibilityControl() {
            const checkbox = document.getElementById('toggle-cut-plane-control');
            // Sincronizar com o checkbox original se existir
            const originalCheckbox = document.getElementById('toggle-cut-plane');
            if (originalCheckbox) {
                originalCheckbox.checked = checkbox.checked;
            }
            toggleCutPlaneVisibility();
        }


        
        function selectAllTypes() {
            const types = ['Pilar', 'Viga', 'Laje', 'Parede', 'Fundação', 'Estaca', 'Cabos', 'Outros'];
            types.forEach(t => filterState.types.add(t));
            // Atualizar visual dos chips
            document.querySelectorAll('.filter-chip[data-tipo]').forEach(chip => {
                chip.classList.add('active');
            });
            applyFilters();
        }
        
        function deselectAllTypes() {
            filterState.types.clear();
            // Atualizar visual dos chips
            document.querySelectorAll('.filter-chip[data-tipo]').forEach(chip => {
                chip.classList.remove('active');
            });
            applyFilters();
        }

        function detectLevels() {
            const levelsByStorey = new Map(); // Prioridade: storey do IFC
            const levelsByHeight = new Map(); // Fallback: altura Y
            if (!loadedModel) return [];

            loadedModel.traverse((node) => {
                if (node.isMesh && node.userData.info) {
                    const info = node.userData.info;
                    
                    // Prioridade 1: usar storey do IFC se disponível
                    if (info.storey) {
                        const key = info.storey;
                        if (!levelsByStorey.has(key)) {
                            levelsByStorey.set(key, { 
                                name: info.storey, 
                                height: (info.elevation != null ? info.elevation : 0), 
                                count: 0,
                                useStorey: true
                            });
                        }
                        levelsByStorey.get(key).count++;
                    } else {
                        // Fallback: calcular pela posição Y
                        const box = new THREE.Box3().setFromObject(node);
                        const baseY = Math.round(box.min.y * 2) / 2;

                        if (!levelsByHeight.has(baseY)) {
                            levelsByHeight.set(baseY, { height: baseY, count: 0 });
                        }
                        levelsByHeight.get(baseY).count++;
                    }
                }
            });

            // Se temos níveis do IFC, usar eles
            if (levelsByStorey.size > 0) {
                return Array.from(levelsByStorey.values())
                    .sort((a, b) => a.height - b.height);
            }

            // Senão, usar níveis calculados por altura
            return Array.from(levelsByHeight.values())
                .sort((a, b) => a.height - b.height)
                .map((l, i) => ({
                    ...l,
                    name: l.height < 0 ? `Subsolo (${l.height.toFixed(1)}m)` :
                        l.height < 0.5 ? 'Térreo' : `Nível ${i} (${l.height.toFixed(1)}m)`
                }));
        }

        function onSearchInput(value) {
            filterState.searchQuery = value.trim();
            const resultsContainer = document.getElementById('sidebar-search-results');

            if (value.trim().length < 1) {
                if (resultsContainer) resultsContainer.innerHTML = '';
                return;
            }

            window._searchResults = [];
            const queryLower = value.toLowerCase();

            loadedModel.traverse((node) => {
                if (node.isMesh && node.userData.info) {
                    const nome = (node.userData.info.nome || '').toLowerCase();
                    if (nome.includes(queryLower)) {
                        window._searchResults.push({
                            node: node,
                            nome: node.userData.info.nome,
                            tipo: node.userData.info.tipo
                        });
                    }
                }
            });

            if (!resultsContainer) return;
            
            if (window._searchResults.length === 0) {
                resultsContainer.innerHTML = '<div style="padding: 10px; color: #999; text-align: center;">Nenhum resultado</div>';
            } else {
                resultsContainer.innerHTML = `
                    <div class="search-results">
                        ${window._searchResults.slice(0, 20).map((r, i) => `
                            <div class="search-result-item" onclick="selectSearchResult(${i})">
                                <div class="search-result-name">${r.nome}</div>
                                <div class="search-result-type">${r.tipo}</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        }

        function toggleTypeFilter(tipo, element) {
            if (filterState.types.has(tipo)) {
                filterState.types.delete(tipo);
                element.classList.remove('active');
            } else {
                filterState.types.add(tipo);
                element.classList.add('active');
            }
            applyFilters();
        }

        function onLevelChange(value) {
            filterState.levels.clear();
            filterState.selectedStorey = null;
            
            if (value !== 'all') {
                // Verificar se é nome de storey ou altura numérica
                if (isNaN(parseFloat(value))) {
                    filterState.selectedStorey = value;
                } else {
                    filterState.levels.add(parseFloat(value));
                }
            }
            applyFilters();
        }

        function applyFilters() {
            if (!loadedModel) return;

            loadedModel.traverse((node) => {
                if (node.isMesh && node.userData.info) {
                    const info = node.userData.info;
                    const tipo = info.tipo || 'Outros';

                    const typeMatch = filterState.types.has(tipo);

                    let levelMatch = true;
                    
                    // Filtro por storey (nome do pavimento)
                    if (filterState.selectedStorey) {
                        levelMatch = info.storey === filterState.selectedStorey;
                    }
                    // Filtro por altura Y
                    else if (filterState.levels.size > 0) {
                        const box = new THREE.Box3().setFromObject(node);
                        const baseY = Math.round(box.min.y * 2) / 2;
                        levelMatch = filterState.levels.has(baseY);
                    }

                    node.visible = typeMatch && levelMatch && !hiddenObjects.has(node.uuid);
                }
            });

            planCache.needsUpdate = true;
            if (isPlanViewActive) drawFloorPlanOptimized();
            updateQuantitiesPanel();
        }

        function resetFilters() {
            filterState.types = new Set(['Pilar', 'Viga', 'Laje', 'Parede', 'Fundação', 'Estaca', 'Cabos', 'Outros']);
            filterState.levels.clear();
            filterState.selectedStorey = null;
            filterState.searchQuery = '';

            const searchInput = document.getElementById('search-input');
            if (searchInput) searchInput.value = '';

            showAll();
            renderFiltersPanel();
            showToast('🔄 Filtros resetados');
        }

        // ==========================================
        // EXPORT
        // ==========================================
        function openExportModal() {
            document.getElementById('export-modal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('export-modal').classList.remove('active');
        }

        function generateSummaryByStorey() {
            const byStorey = new Map();
            
            if (!loadedModel) return byStorey;
            
            loadedModel.traverse((node) => {
                if (node.isMesh && node.visible && node.userData.info) {
                    const info = node.userData.info;
                    const storey = info.storey || 'Sem Pavimento';
                    const tipo = info.tipo || 'Outros';
                    const tipoLower = tipo.toLowerCase();
                    
                    // Calcular área de forma
                    let areaForma = 0;
                    if (tipoLower.includes('pilar') || tipoLower.includes('column')) {
                        areaForma = 2 * ((info.comp || 0) + (info.larg || 0)) * (info.alt || 0);
                    } else if (tipoLower.includes('viga') || tipoLower.includes('beam')) {
                        areaForma = (2 * (info.alt || 0) + (info.larg || 0)) * (info.comp || 0);
                    }
                    
                    if (!byStorey.has(storey)) {
                        byStorey.set(storey, {
                            name: storey,
                            elevation: info.elevation || 0,
                            types: {},
                            totalVolume: 0,
                            totalArea: 0,
                            totalForma: 0,
                            count: 0
                        });
                    }
                    
                    const storeyData = byStorey.get(storey);
                    
                    if (!storeyData.types[tipo]) {
                        storeyData.types[tipo] = { count: 0, volume: 0, area: 0, areaForma: 0, items: [] };
                    }
                    
                    storeyData.types[tipo].count++;
                    storeyData.types[tipo].volume += info.volume || 0;
                    storeyData.types[tipo].area += info.area || 0;
                    storeyData.types[tipo].areaForma += areaForma;
                    storeyData.types[tipo].items.push({
                        nome: info.nome,
                        volume: info.volume || 0,
                        area: info.area || 0,
                        areaForma: areaForma,
                        comp: info.comp || 0,
                        larg: info.larg || 0,
                        alt: info.alt || 0
                    });
                    
                    storeyData.totalVolume += info.volume || 0;
                    storeyData.totalArea += info.area || 0;
                    storeyData.totalForma += areaForma;
                    storeyData.count++;
                }
            });
            
            // Ordenar por elevação
            return new Map([...byStorey.entries()].sort((a, b) => 
                (a[1].elevation || 0) - (b[1].elevation || 0)
            ));
        }
        
        function exportToExcel() {
            if (typeof XLSX === 'undefined') {
                showToast('⚠️ Biblioteca de exportação não carregada', 'error');
                return;
            }

            const wb = XLSX.utils.book_new();
            const summary = generateQuantitySummary();
            const byStorey = generateSummaryByStorey();
            const date = new Date().toLocaleDateString('pt-BR');
            const datetime = new Date().toLocaleString('pt-BR');
            const totalVolume = summary.pilares.volume + summary.vigas.volume + summary.lajes.volume + 
                               summary.paredes.volume + summary.fundacoes.volume + summary.estacas.volume;
            const totalForma = summary.pilares.areaForma + summary.vigas.areaForma;
            const totalElements = summary.pilares.count + summary.vigas.count + summary.lajes.count +
                                 summary.paredes.count + summary.fundacoes.count + summary.estacas.count;

            // Função auxiliar para aplicar estilos
            function applyStyles(ws, styles) {
                if (!ws['!cols']) ws['!cols'] = [];
                Object.keys(styles).forEach(key => {
                    if (key === 'cols') {
                        ws['!cols'] = styles.cols;
                    }
                });
            }

            // ══════════════════════════════════════════════════════════════
            // ABA 1: RESUMO EXECUTIVO
            // ══════════════════════════════════════════════════════════════
            const resumoData = [
                ['QUANTITATIVO ESTRUTURAL'],
                [''],
                ['Projeto:', 'Modelo IFC'],
                ['Data de Extração:', datetime],
                ['Gerado por:', 'ProCalculo Viewer'],
                [''],
                [''],
                ['INDICADORES PRINCIPAIS'],
                [''],
                ['Total de Elementos', totalElements, 'un'],
                ['Volume Total de Concreto', Number(totalVolume.toFixed(2)), 'm³'],
                ['Área Total de Forma', Number(totalForma.toFixed(2)), 'm²'],
                ['Área de Lajes', Number(summary.lajes.area.toFixed(2)), 'm²'],
                [''],
                [''],
                ['ÍNDICES DE PROJETO'],
                [''],
                ['Taxa de Forma (Pilares+Vigas)', totalVolume > 0 ? Number((totalForma / totalVolume).toFixed(2)) : 0, 'm²/m³'],
                ['Concreto por Área de Laje', summary.lajes.area > 0 ? Number((totalVolume / summary.lajes.area).toFixed(3)) : 0, 'm³/m²'],
                [''],
                [''],
                ['RESUMO POR CATEGORIA'],
                [''],
                ['Categoria', 'Qtd', 'Volume (m³)', 'Forma (m²)', '% Volume'],
                ['Pilares', summary.pilares.count, Number(summary.pilares.volume.toFixed(3)), Number(summary.pilares.areaForma.toFixed(2)),
                    totalVolume > 0 ? Number((summary.pilares.volume/totalVolume*100).toFixed(1)) + '%' : '0%'],
                ['Vigas', summary.vigas.count, Number(summary.vigas.volume.toFixed(3)), Number(summary.vigas.areaForma.toFixed(2)),
                    totalVolume > 0 ? Number((summary.vigas.volume/totalVolume*100).toFixed(1)) + '%' : '0%'],
                ['Lajes', summary.lajes.count, Number(summary.lajes.volume.toFixed(3)), '—',
                    totalVolume > 0 ? Number((summary.lajes.volume/totalVolume*100).toFixed(1)) + '%' : '0%'],
                ['Paredes', summary.paredes.count, Number(summary.paredes.volume.toFixed(3)), '—',
                    totalVolume > 0 ? Number((summary.paredes.volume/totalVolume*100).toFixed(1)) + '%' : '0%'],
                ['Fundações', summary.fundacoes.count, Number(summary.fundacoes.volume.toFixed(3)), '—',
                    totalVolume > 0 ? Number((summary.fundacoes.volume/totalVolume*100).toFixed(1)) + '%' : '0%'],
                ['Estacas', summary.estacas.count, Number(summary.estacas.volume.toFixed(3)), '—',
                    totalVolume > 0 ? Number((summary.estacas.volume/totalVolume*100).toFixed(1)) + '%' : '0%'],
                [''],
                ['TOTAL', totalElements, Number(totalVolume.toFixed(3)), Number(totalForma.toFixed(2)), '100%'],
            ];
            
            const wsResumo = XLSX.utils.aoa_to_sheet(resumoData);
            wsResumo['!cols'] = [{ wch: 28 }, { wch: 18 }, { wch: 15 }, { wch: 15 }, { wch: 12 }];
            wsResumo['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 4 } }];
            XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');

            // ══════════════════════════════════════════════════════════════
            // ABA 2: POR PAVIMENTO (COMPLETO)
            // ══════════════════════════════════════════════════════════════
            const pavData = [
                ['QUANTITATIVO POR PAVIMENTO'],
                [''],
                ['Pavimento', 'Tipo', 'Qtd', 'Volume (m³)', 'Área (m²)', 'Forma (m²)'],
            ];
            
            let grandTotalForma = 0;
            byStorey.forEach((data, storeyName) => {
                let storeyVolume = 0;
                let storeyForma = 0;
                let first = true;
                
                Object.entries(data.types).forEach(([tipo, typeData]) => {
                    pavData.push([
                        first ? storeyName : '',
                        tipo,
                        typeData.count,
                        Number(typeData.volume.toFixed(3)),
                        typeData.area > 0 ? Number(typeData.area.toFixed(2)) : '—',
                        typeData.areaForma > 0 ? Number(typeData.areaForma.toFixed(2)) : '—'
                    ]);
                    storeyVolume += typeData.volume;
                    storeyForma += typeData.areaForma || 0;
                    first = false;
                });
                
                pavData.push(['', 'SUBTOTAL ' + storeyName, data.count, Number(storeyVolume.toFixed(3)), '', Number(storeyForma.toFixed(2))]);
                pavData.push(['']);
                grandTotalForma += storeyForma;
            });
            
            pavData.push(['TOTAL GERAL', '', totalElements, Number(totalVolume.toFixed(3)), Number(summary.lajes.area.toFixed(2)), Number(grandTotalForma.toFixed(2))]);
            
            const wsPav = XLSX.utils.aoa_to_sheet(pavData);
            wsPav['!cols'] = [{ wch: 20 }, { wch: 18 }, { wch: 8 }, { wch: 14 }, { wch: 12 }, { wch: 12 }];
            XLSX.utils.book_append_sheet(wb, wsPav, 'Por Pavimento');

            // ══════════════════════════════════════════════════════════════
            // ABA 3: CONCRETO (PARA PEDIDO)
            // ══════════════════════════════════════════════════════════════
            const concretoData = [
                ['RESUMO DE CONCRETO PARA PEDIDO'],
                [''],
                ['Este resumo pode ser usado para programação de concretagem'],
                [''],
                [''],
                ['POR PAVIMENTO'],
                [''],
                ['Pavimento', 'Pilares (m³)', 'Vigas (m³)', 'Lajes (m³)', 'Outros (m³)', 'Total (m³)'],
            ];
            
            byStorey.forEach((data, storeyName) => {
                const pilares = (data.types['Pilar'] ? data.types['Pilar'].volume : 0) || 0;
                const vigas = (data.types['Viga'] ? data.types['Viga'].volume : 0) || 0;
                const lajes = (data.types['Laje'] ? data.types['Laje'].volume : 0) || 0;
                const outros = data.totalVolume - pilares - vigas - lajes;
                concretoData.push([
                    storeyName,
                    Number(pilares.toFixed(3)),
                    Number(vigas.toFixed(3)),
                    Number(lajes.toFixed(3)),
                    Number(outros.toFixed(3)),
                    Number(data.totalVolume.toFixed(3))
                ]);
            });
            
            concretoData.push(['']);
            concretoData.push(['TOTAL', 
                Number(summary.pilares.volume.toFixed(3)),
                Number(summary.vigas.volume.toFixed(3)),
                Number(summary.lajes.volume.toFixed(3)),
                Number((summary.paredes.volume + summary.fundacoes.volume + summary.estacas.volume).toFixed(3)),
                Number(totalVolume.toFixed(3))
            ]);
            concretoData.push(['']);
            concretoData.push(['']);
            concretoData.push(['ESTIMATIVA DE CAMINHÕES BETONEIRA']);
            concretoData.push(['']);
            concretoData.push(['Capacidade caminhão', '8 m³']);
            concretoData.push(['Total necessário', Math.ceil(totalVolume / 8), 'caminhões']);
            concretoData.push(['Volume exato', Number(totalVolume.toFixed(2)), 'm³']);
            
            const wsConcreto = XLSX.utils.aoa_to_sheet(concretoData);
            wsConcreto['!cols'] = [{ wch: 20 }, { wch: 14 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }];
            XLSX.utils.book_append_sheet(wb, wsConcreto, 'Concreto');

            // ══════════════════════════════════════════════════════════════
            // ABA 4: FORMA (PARA ORÇAMENTO)
            // ══════════════════════════════════════════════════════════════
            const formaData = [
                ['RESUMO DE FORMA PARA ORÇAMENTO'],
                [''],
                ['Considera: Pilares (4 faces laterais) + Vigas (2 laterais + fundo)'],
                ['Lajes não incluídas (forma inferior da estrutura)'],
                [''],
                [''],
                ['POR PAVIMENTO'],
                [''],
                ['Pavimento', 'Forma Pilares (m²)', 'Forma Vigas (m²)', 'Total Forma (m²)'],
            ];
            
            let totalFormaPilares = 0;
            let totalFormaVigas = 0;
            
            byStorey.forEach((data, storeyName) => {
                const formaPilares = (data.types['Pilar'] ? data.types['Pilar'].areaForma : 0) || 0;
                const formaVigas = (data.types['Viga'] ? data.types['Viga'].areaForma : 0) || 0;
                formaData.push([
                    storeyName,
                    Number(formaPilares.toFixed(2)),
                    Number(formaVigas.toFixed(2)),
                    Number((formaPilares + formaVigas).toFixed(2))
                ]);
                totalFormaPilares += formaPilares;
                totalFormaVigas += formaVigas;
            });
            
            formaData.push(['']);
            formaData.push(['TOTAL', Number(totalFormaPilares.toFixed(2)), Number(totalFormaVigas.toFixed(2)), Number(totalForma.toFixed(2))]);
            formaData.push(['']);
            formaData.push(['']);
            formaData.push(['ÍNDICES']);
            formaData.push(['']);
            formaData.push(['Taxa de Forma', totalVolume > 0 ? Number((totalForma / totalVolume).toFixed(2)) : 0, 'm²/m³ concreto']);
            formaData.push(['Forma por m² construído', summary.lajes.area > 0 ? Number((totalForma / summary.lajes.area).toFixed(2)) : 0, 'm²/m² laje']);
            
            const wsForma = XLSX.utils.aoa_to_sheet(formaData);
            wsForma['!cols'] = [{ wch: 22 }, { wch: 18 }, { wch: 16 }, { wch: 16 }];
            XLSX.utils.book_append_sheet(wb, wsForma, 'Forma');

            // ══════════════════════════════════════════════════════════════
            // ABA 5: PILARES DETALHADO
            // ══════════════════════════════════════════════════════════════
            const pilaresData = [
                ['PILARES - LISTAGEM COMPLETA'],
                [''],
                ['#', 'Nome', 'Pavimento', 'Seção b×h (m)', 'Altura (m)', 'Volume (m³)', 'Forma (m²)', 'Perímetro (m)']
            ];
            let idx = 1;
            summary.pilares.items.forEach(item => {
                const secao = (item.larg || 0).toFixed(2) + ' × ' + (item.comp || 0).toFixed(2);
                const perimetro = 2 * ((item.larg || 0) + (item.comp || 0));
                pilaresData.push([
                    idx++,
                    item.nome,
                    item.storey || '—',
                    secao,
                    Number((item.alt || 0).toFixed(2)),
                    Number((item.volume || 0).toFixed(4)),
                    Number((item.areaForma || 0).toFixed(2)),
                    Number(perimetro.toFixed(2))
                ]);
            });
            pilaresData.push(['']);
            pilaresData.push(['', '', '', '', 'TOTAL:', Number(summary.pilares.volume.toFixed(3)), Number(summary.pilares.areaForma.toFixed(2)), '']);
            
            const wsPilares = XLSX.utils.aoa_to_sheet(pilaresData);
            wsPilares['!cols'] = [{ wch: 5 }, { wch: 18 }, { wch: 14 }, { wch: 14 }, { wch: 10 }, { wch: 12 }, { wch: 11 }, { wch: 12 }];
            XLSX.utils.book_append_sheet(wb, wsPilares, 'Pilares');

            // ══════════════════════════════════════════════════════════════
            // ABA 6: VIGAS DETALHADO
            // ══════════════════════════════════════════════════════════════
            const vigasData = [
                ['VIGAS - LISTAGEM COMPLETA'],
                [''],
                ['#', 'Nome', 'Pavimento', 'Seção b×h (m)', 'Comp. (m)', 'Volume (m³)', 'Forma (m²)', 'Forma/m (m²/m)']
            ];
            idx = 1;
            summary.vigas.items.forEach(item => {
                const secao = (item.larg || 0).toFixed(2) + ' × ' + (item.alt || 0).toFixed(2);
                const formaPorMetro = item.comp > 0 ? (item.areaForma || 0) / item.comp : 0;
                vigasData.push([
                    idx++,
                    item.nome,
                    item.storey || '—',
                    secao,
                    Number((item.comp || 0).toFixed(2)),
                    Number((item.volume || 0).toFixed(4)),
                    Number((item.areaForma || 0).toFixed(2)),
                    Number(formaPorMetro.toFixed(2))
                ]);
            });
            vigasData.push(['']);
            vigasData.push(['', '', '', '', 'TOTAL:', Number(summary.vigas.volume.toFixed(3)), Number(summary.vigas.areaForma.toFixed(2)), '']);
            
            const wsVigas = XLSX.utils.aoa_to_sheet(vigasData);
            wsVigas['!cols'] = [{ wch: 5 }, { wch: 18 }, { wch: 14 }, { wch: 14 }, { wch: 10 }, { wch: 12 }, { wch: 11 }, { wch: 13 }];
            XLSX.utils.book_append_sheet(wb, wsVigas, 'Vigas');

            // ══════════════════════════════════════════════════════════════
            // ABA 7: LAJES DETALHADO
            // ══════════════════════════════════════════════════════════════
            const lajesData = [
                ['LAJES - LISTAGEM COMPLETA'],
                [''],
                ['#', 'Nome', 'Pavimento', 'Tipologia', 'Espessura (cm)', 'Área (m²)', 'Volume (m³)', 'Conc/m² (m³/m²)']
            ];
            idx = 1;
            summary.lajes.items.forEach(item => {
                const concPorM2 = item.area > 0 ? (item.volume || 0) / item.area : 0;
                lajesData.push([
                    idx++,
                    item.nome,
                    item.storey || '—',
                    item.tipoLaje || '—',
                    Number(((item.alt || 0) * 100).toFixed(1)),
                    Number((item.area || 0).toFixed(2)),
                    Number((item.volume || 0).toFixed(4)),
                    Number(concPorM2.toFixed(3))
                ]);
            });
            lajesData.push(['']);
            lajesData.push(['', '', '', '', 'TOTAL:', Number(summary.lajes.area.toFixed(2)), Number(summary.lajes.volume.toFixed(3)), '']);
            lajesData.push(['']);
            lajesData.push(['']);
            
            // RESUMO POR PAVIMENTO + TIPO + ESPESSURA
            lajesData.push(['══════════════════════════════════════════════════════════════════════════']);
            lajesData.push(['RESUMO DE LAJES POR PAVIMENTO']);
            lajesData.push(['══════════════════════════════════════════════════════════════════════════']);
            lajesData.push(['']);
            
            // Agrupar por pavimento
            const lajesByStorey = {};
            Object.values(summary.lajes.byStoreyTypeHeight || {}).forEach(item => {
                const storey = item.storey || 'Sem Pavimento';
                if (!lajesByStorey[storey]) {
                    lajesByStorey[storey] = [];
                }
                lajesByStorey[storey].push(item);
            });
            
            // Gerar tabelas por pavimento
            Object.keys(lajesByStorey).sort().forEach(storey => {
                const items = lajesByStorey[storey].sort((a, b) => {
                    if (a.tipo !== b.tipo) return a.tipo.localeCompare(b.tipo);
                    return a.altura - b.altura;
                });
                
                lajesData.push(['🏢 ' + storey]);
                lajesData.push(['Tipo', 'Altura (cm)', 'Área (m²)']);
                
                let subtotal = 0;
                items.forEach(item => {
                    lajesData.push([item.tipo || 'Laje', item.altura, Number(item.area.toFixed(2))]);
                    subtotal += item.area;
                });
                
                lajesData.push(['Subtotal', '', Number(subtotal.toFixed(2))]);
                lajesData.push(['']);
            });
            
            // RESUMO GERAL
            lajesData.push(['']);
            lajesData.push(['══════════════════════════════════════════════════════════════════════════']);
            lajesData.push(['📋 RESUMO GERAL DE LAJES']);
            lajesData.push(['══════════════════════════════════════════════════════════════════════════']);
            lajesData.push(['']);
            lajesData.push(['Tipo', 'Altura (cm)', 'Área (m²)']);
            
            let totalGeralArea = 0;
            Object.values(summary.lajes.byTypeHeight || {}).sort((a, b) => {
                if (a.tipo !== b.tipo) return a.tipo.localeCompare(b.tipo);
                return a.altura - b.altura;
            }).forEach(item => {
                lajesData.push([item.tipo || 'Laje', item.altura, Number(item.area.toFixed(2))]);
                totalGeralArea += item.area;
            });
            
            lajesData.push(['']);
            lajesData.push(['TOTAL GERAL', '', Number(totalGeralArea.toFixed(2))]);
            
            const wsLajes = XLSX.utils.aoa_to_sheet(lajesData);
            wsLajes['!cols'] = [{ wch: 20 }, { wch: 18 }, { wch: 14 }, { wch: 18 }, { wch: 14 }, { wch: 11 }, { wch: 12 }, { wch: 13 }];
            XLSX.utils.book_append_sheet(wb, wsLajes, 'Lajes');

            // ══════════════════════════════════════════════════════════════
            // ABA 8: FUNDAÇÕES E ESTACAS
            // ══════════════════════════════════════════════════════════════
            if (summary.fundacoes.count > 0 || summary.estacas.count > 0) {
                const fundData = [
                    ['FUNDAÇÕES E ESTACAS'],
                    [''],
                ];
                
                if (summary.fundacoes.count > 0) {
                    fundData.push(['FUNDAÇÕES']);
                    fundData.push(['#', 'Nome', 'Pavimento', 'Dimensões (m)', 'Volume (m³)']);
                    idx = 1;
                    summary.fundacoes.items.forEach(item => {
                        const dims = (item.larg || 0).toFixed(2) + ' × ' + (item.comp || 0).toFixed(2) + ' × ' + (item.alt || 0).toFixed(2);
                        fundData.push([idx++, item.nome, item.storey || '—', dims, Number((item.volume || 0).toFixed(3))]);
                    });
                    fundData.push(['', '', '', 'TOTAL:', Number(summary.fundacoes.volume.toFixed(3))]);
                    fundData.push(['']);
                }
                
                if (summary.estacas.count > 0) {
                    fundData.push(['ESTACAS']);
                    fundData.push(['#', 'Nome', 'Pavimento', 'Diâmetro (m)', 'Comp. (m)', 'Volume (m³)']);
                    idx = 1;
                    summary.estacas.items.forEach(item => {
                        fundData.push([idx++, item.nome, item.storey || '—', 
                            Number((item.larg || 0).toFixed(2)), 
                            Number((item.alt || 0).toFixed(2)), 
                            Number((item.volume || 0).toFixed(3))]);
                    });
                    fundData.push(['', '', '', '', 'TOTAL:', Number(summary.estacas.volume.toFixed(3))]);
                }
                
                const wsFund = XLSX.utils.aoa_to_sheet(fundData);
                wsFund['!cols'] = [{ wch: 5 }, { wch: 20 }, { wch: 14 }, { wch: 16 }, { wch: 12 }, { wch: 12 }];
                XLSX.utils.book_append_sheet(wb, wsFund, 'Fundações');
            }

            // ══════════════════════════════════════════════════════════════
            // ABA 9: PROTENSÃO (se houver)
            // ══════════════════════════════════════════════════════════════
            if (summary.tendons.count > 0) {
                const tendonsData = [
                    ['PROTENSÃO - CORDOALHAS'],
                    [''],
                    ['Especificação: CP190 RB - 7 fios'],
                    ['Peso Ø15.2mm: 1.10 kg/m  |  Peso Ø12.7mm: 0.79 kg/m'],
                    [''],
                    [''],
                    ['LISTAGEM DE CABOS DE PROTENSAO'],
                    [''],
                    ['#', 'Nome', 'Pavimento', 'Ø (mm)', 'Cabos/Feixe', 'Comp. (m)', 'Comp. Total (m)', 'Peso (kg)']
                ];
                idx = 1;
                summary.tendons.items.forEach(item => {
                    const compTotal = (item.comp || 0) * (item.numCabos || 1);
                    tendonsData.push([
                        idx++,
                        item.nome,
                        item.storey || '—',
                        item.diametro || '—',
                        item.numCabos || 1,
                        Number((item.comp || 0).toFixed(2)),
                        Number(compTotal.toFixed(2)),
                        Number((item.pesoProtensao || 0).toFixed(2))
                    ]);
                });
                tendonsData.push(['']);
                tendonsData.push(['', '', '', '', 'TOTAIS:', 
                    Number(summary.tendons.comprimento.toFixed(2)),
                    Number(summary.tendons.comprimentoTotal.toFixed(2)),
                    Number((summary.tendons.peso152 + summary.tendons.peso127).toFixed(2))
                ]);
                tendonsData.push(['']);
                // Calcular valores com acréscimo de 4% e massa engraxada
                const compComAcrescimo = summary.tendons.comprimentoTotal * 1.075;
                const pesoEngraxado = compComAcrescimo * 1.24; // massa engraxada Ø15.2mm
                
                tendonsData.push(['']);
                tendonsData.push(['RESUMO PARA PEDIDO']);
                tendonsData.push(['']);
                tendonsData.push(['Item', 'Quantidade', 'Unidade']);
                tendonsData.push(['Total de Cordoalhas', summary.tendons.totalCabos, 'un']);
                tendonsData.push(['Comprimento Total (+7,5%)', Number(compComAcrescimo.toFixed(2)), 'm']);
                tendonsData.push(['']);
                tendonsData.push(['PESO TOTAL (engraxada 1.24 kg/m)', Number(pesoEngraxado.toFixed(2)), 'kg']);
                
                const wsTendons = XLSX.utils.aoa_to_sheet(tendonsData);
                wsTendons['!cols'] = [{ wch: 5 }, { wch: 22 }, { wch: 14 }, { wch: 10 }, { wch: 12 }, { wch: 12 }, { wch: 14 }, { wch: 12 }];
                XLSX.utils.book_append_sheet(wb, wsTendons, 'Protensão');
            }

            // Aba de Informações/Créditos
            const infoData = [
                ['INFORMAÇÕES DO DOCUMENTO'],
                [''],
                ['Tipo:', 'Quantitativo Estrutural'],
                ['Data de Geração:', new Date().toLocaleDateString('pt-BR') + ' ' + new Date().toLocaleTimeString('pt-BR')],
                [''],
                ['DESENVOLVEDOR'],
                ['Nome:', 'Eng.Civil Pedro Leite de O. Santos'],
                ['Empresa:', 'ProCalculo Engenharia'],
                [''],
                ['SOFTWARE'],
                ['Visualizador:', 'IFC 3D Viewer - ProCalculo'],
                ['Versão:', '2.0'],
                [''],
                ['OBSERVAÇÕES'],
                ['Este documento foi gerado automaticamente a partir de modelo IFC.'],
                ['Confira os valores com o projeto executivo antes de utilizar.']
            ];
            
            const wsInfo = XLSX.utils.aoa_to_sheet(infoData);
            wsInfo['!cols'] = [{ wch: 20 }, { wch: 50 }];
            XLSX.utils.book_append_sheet(wb, wsInfo, 'Informações');

            const fileName = 'Quantitativo_Estrutural_' + new Date().toISOString().split('T')[0] + '.xlsx';
            XLSX.writeFile(wb, fileName);
            closeExportModal();
            showToast('📥 Excel exportado com sucesso!', 'success');
        }

        function exportToPDF() {
            const summary = generateQuantitySummary();
            const byStorey = generateSummaryByStorey();
            const date = new Date().toLocaleDateString('pt-BR');
            const totalVolume = summary.pilares.volume + summary.vigas.volume + summary.lajes.volume + 
                               summary.paredes.volume + summary.fundacoes.volume + summary.estacas.volume;
            const totalElements = summary.pilares.count + summary.vigas.count + summary.lajes.count + 
                                 summary.paredes.count + summary.fundacoes.count + summary.estacas.count;
            
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                showToast('Popup bloqueado. Permita popups para exportar PDF.', 'error');
                return;
            }
            
            let html = '<!DOCTYPE html><html><head><meta charset="UTF-8">';
            html += '<title>Quantitativos - ProCalculo</title>';
            html += '<style>';
            html += '* { margin: 0; padding: 0; box-sizing: border-box; }';
            html += '@page { size: A4; margin: 12mm; }';
            html += 'body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; font-size: 9pt; color: #333; padding: 20px; background: #fff; }';
            html += '.watermark { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-30deg); opacity: 0.03; font-size: 100pt; font-weight: bold; color: #000; pointer-events: none; z-index: -1; white-space: nowrap; }';
            html += '.header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid #2c3e50; }';
            html += '.header-left h1 { font-size: 20pt; font-weight: 700; color: #2c3e50; letter-spacing: -0.5px; }';
            html += '.header-left .subtitle { color: #7f8c8d; font-size: 9pt; margin-top: 3px; }';
            html += '.logo { height: 90px; opacity: 0.9; }';
            html += '.cards { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 25px; }';
            html += '.card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; padding: 15px; text-align: center; color: white; }';
            html += '.card.alt { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }';
            html += '.card.alt2 { background: linear-gradient(135deg, #ee9ca7 0%, #ffdde1 100%); color: #333; }';
            html += '.card.alt3 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }';
            html += '.card .value { font-size: 22pt; font-weight: 700; }';
            html += '.card .label { font-size: 8pt; opacity: 0.9; text-transform: uppercase; margin-top: 5px; letter-spacing: 0.5px; }';
            html += '.section { margin-bottom: 20px; page-break-inside: avoid; }';
            html += '.section-title { font-size: 11pt; font-weight: 600; color: #2c3e50; margin-bottom: 10px; padding: 8px 12px; background: #ecf0f1; border-radius: 6px; border-left: 4px solid #3498db; }';
            html += 'table { width: 100%; border-collapse: collapse; font-size: 8pt; margin-bottom: 15px; }';
            html += 'th { text-align: left; padding: 8px 10px; background: #34495e; color: white; font-weight: 500; }';
            html += 'td { padding: 7px 10px; border-bottom: 1px solid #ecf0f1; }';
            html += 'tr:nth-child(even) { background: #f8f9fa; }';
            html += '.text-right { text-align: right; }';
            html += '.text-center { text-align: center; }';
            html += '.total-row { background: #2c3e50 !important; color: white; font-weight: 600; }';
            html += '.bar-container { width: 100%; height: 18px; background: #ecf0f1; border-radius: 9px; overflow: hidden; margin: 3px 0; }';
            html += '.bar { height: 100%; border-radius: 9px; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; color: white; font-size: 7pt; font-weight: 600; }';
            html += '.bar.pilares { background: linear-gradient(90deg, #3498db, #2980b9); }';
            html += '.bar.vigas { background: linear-gradient(90deg, #e74c3c, #c0392b); }';
            html += '.bar.lajes { background: linear-gradient(90deg, #2ecc71, #27ae60); }';
            html += '.bar.outros { background: linear-gradient(90deg, #9b59b6, #8e44ad); }';
            html += '.mini-card { display: inline-block; background: #f8f9fa; border-radius: 6px; padding: 8px 12px; margin: 3px; text-align: center; border: 1px solid #ecf0f1; }';
            html += '.mini-card .val { font-size: 14pt; font-weight: 700; color: #2c3e50; }';
            html += '.mini-card .lbl { font-size: 7pt; color: #7f8c8d; text-transform: uppercase; }';
            html += '.footer { margin-top: 30px; text-align: center; color: #95a5a6; font-size: 7pt; padding-top: 15px; border-top: 1px solid #ecf0f1; }';
            html += '.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }';
            html += '@media print { .watermark { position: fixed; } body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }';
            html += '</style></head><body>';
            
            html += '<div class="watermark">ProCalculo</div>';
            
            // Header com Logo
            html += '<div class="header">';
            html += '<div class="header-left"><h1>Quantitativos Estruturais</h1><div class="subtitle">' + date + ' | Desenvolvido por Eng.Civil Pedro Leite de O. Santos</div></div>';
            html += '<img class="logo" src="data:image/png;base64,UklGRixOAABXRUJQVlA4WAoAAAAwAAAA/wMA/wMASUNDUMgBAAAAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADZBTFBItEMAAAH/JyRI8P94a0Sk7kkK2rZhUv7A3wYgIhKnj1zrG9Ybtv+PlPb/93zNbKVIr/YuijRFBCl2UOyxYXpMN9Uk77xjTDRFY0yixhZLir3GgmLvFRELiD0qChYUpC27y5aZ542ZnZmdQT77ee+NRPR/AoAC8fcfRUTCv/7/1//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvv/7/+/9f/rlGqdUpaSvqIJm57JGlD0eXLRT/5uuvRiTtNiNaVHWh3vfhtRkT70rYUuOeT7jssiJZ17Shw04/eZkXENa0pcNPvmo2I1rUdKXDPp6P+RkTLls7gpk933WxHNK2NpNz0VDGbEdGwJZ6Aez4dtcmGrGFDLAH3fBL1NyLWbOxJgXs+idrMIFuzqQe46VMx2xGxdmM85aZH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HEiDWOKflhofKEbVpn/vaC8eaJOW3DtcEICq5dDX33lrZISegHjSNC01wV8CoHy7Z739zqsDQmkQ6dEvLSmQB4J7pqaFUTx080H9EsOIAHVKWmo3Dz4AogpNzXrjnddHRTehwLVKgrciomnHgIiODjs4bC+wXbt27YV34O/Yoam6gQIiEoQSQkAgIQQkJJRKQxMQTYSDUEIIcQRACAGhhBACjgkhIJAQAoIJIQQcE0IIOCSEEAFACAGBhBAQTggBiYljkJQIB+mJSCEAQAitVlEEpCSEgGhCCAGHhBAiAoDQahUBiQkhIC2hVGqKgHhCCDgkhIBDQggBwYQQAoIJoVU0IeBq7bjdjGjem6YG93zSNseCaNmfpAU3/ZY5ZkTb4Xg1uOl3yjEjMqcSaHDTD8iuR8T8FhS46UfkWBDxYhS46VNt15sQmbzm4KZPd91oQrSdjAY3fVX0KgOi5XA3yk1PE/1XHWL94Vga3PNVsatqEc17UjXgnq+JWWpANO3rToN7vjp2pQHRuLOPDtzz1XF/1iAac1LV4J6villhQDTl9NOBez7VaW0toim7tw7c9CNXGhHNe/uqwT2fhG2pQzTvTNSDm36nv02I9fvTaHDPJ62y6xEtB3pqwU2/zQ4zovVwDzW455MO202I9pPdVeCmH5RtRmTz2lDgpt8xpx4RL3QFN30Ssr4ekckPATd9qvNmM6LtWDS46dMRK42IliNRxE1PE/1Xrd1uPtBdBW76Yf/Zt3//gTUpanDX1wUFBwUFedPwr///9f+//v/X//7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv//++++///7777///vvvv///+v9f///r/3/9/6////X/v/7/1///+v9f///r/3/9/6////X/v/53SwdWUDgggggAANDkAJ0BKgAEAAQ+USiPRyOioSGgGAgIcAoJaW7kqpc8La0D2ufN5ezAE9yHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ96TIHDvtk5D32ychvQz3Ie+2TkPfbJyHvtk5D32xwz3Ie+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfasZAoiE6GlLSEZ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfcTfbJyHvtk5D32ych77ZOQ99snIe+2TkN5w77ZOQ99snpUCyXa8XJyHvtk5D32ych77ZOQ9YRYFakp9LvYpaVAsl2u4M9yHrDPch77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvrCEtk5DeTlODTIG7Ex1Y0cO+2Tj+UnghLZOQ99snIe+2TkPfbJyHvtk4Uz3H8Utuzh32ychvO3aVAsl2vFych77obSoFku14uTkPfbU5RAsl2vFych77ZOQ99smI0SJcnIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJiAAD+/+J/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AG4AZIBuAJ322+a7ib5bQll+aZzpLS0GDtGjadkTXcseAAAc+c8TvWt1qxW714u02dXbn4+0/l23sKo3y7XSGP0ATgBMfuMZwEDIALfnSeC86aeGLKF94zrSJaqV/oD7gL73shukY3hFhKK4gRkBnK1twMHfw+m9cpnwe4AAAberSI/NuSKpP7QeNIoCxz8aqfNj4D3NuylfeYKiwAacA9cVU7MY8IsdZwsr12RuYvyyN9NMrGiL1wq6qNuzATgCVJ8JghgZgL5MbZ5CvDxvbK7ar/0AcQrDUbaIdqBg2zgisI3rR6wUaaJghTIrAAEeBg6A9ZBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==" alt="ProCálculo" style="height:100px;width:auto;">';
            html += '</div>';
            
            // Cards principais
            const totalFormaP = summary.pilares.areaForma + summary.vigas.areaForma;
            html += '<div class="cards">';
            html += '<div class="card"><div class="value">' + totalElements + '</div><div class="label">Elementos</div></div>';
            html += '<div class="card alt"><div class="value">' + totalVolume.toFixed(1) + '</div><div class="label">Concreto (m³)</div></div>';
            html += '<div class="card alt2"><div class="value">' + totalFormaP.toFixed(1) + '</div><div class="label">Forma (m²)</div></div>';
            if (summary.tendons.count > 0) {
                html += '<div class="card alt3"><div class="value">' + (summary.tendons.peso152 + summary.tendons.peso127).toFixed(0) + '</div><div class="label">Protensão (kg)</div></div>';
            } else {
                html += '<div class="card alt3"><div class="value">' + (summary.lajes.area || 0).toFixed(1) + '</div><div class="label">Área Lajes (m²)</div></div>';
            }
            html += '</div>';
            
            // Índices de Projeto
            const taxaForma = totalVolume > 0 ? (totalFormaP / totalVolume).toFixed(2) : 0;
            const concPorArea = summary.lajes.area > 0 ? (totalVolume / summary.lajes.area).toFixed(3) : 0;
            html += '<div style="display:flex; gap:15px; margin-bottom:20px;">';
            html += '<div style="flex:1; background:#f8f9fa; border-radius:8px; padding:12px; border-left:3px solid #3498db;">';
            html += '<div style="font-size:7pt; color:#666; text-transform:uppercase;">Taxa de Forma</div>';
            html += '<div style="font-size:14pt; font-weight:600; color:#2c3e50;">' + taxaForma + ' <span style="font-size:9pt;font-weight:400;">m²/m³</span></div>';
            html += '</div>';
            html += '<div style="flex:1; background:#f8f9fa; border-radius:8px; padding:12px; border-left:3px solid #27ae60;">';
            html += '<div style="font-size:7pt; color:#666; text-transform:uppercase;">Concreto por Área</div>';
            html += '<div style="font-size:14pt; font-weight:600; color:#2c3e50;">' + concPorArea + ' <span style="font-size:9pt;font-weight:400;">m³/m² laje</span></div>';
            html += '</div>';
            html += '<div style="flex:1; background:#f8f9fa; border-radius:8px; padding:12px; border-left:3px solid #9b59b6;">';
            html += '<div style="font-size:7pt; color:#666; text-transform:uppercase;">Caminhões Betoneira</div>';
            html += '<div style="font-size:14pt; font-weight:600; color:#2c3e50;">≈' + Math.ceil(totalVolume / 8) + ' <span style="font-size:9pt;font-weight:400;">unidades</span></div>';
            html += '</div>';
            html += '</div>';
            
            // Gráfico de distribuição
            html += '<div class="section">';
            html += '<div class="section-title">Distribuição de Volume</div>';
            const maxVol = Math.max(summary.pilares.volume, summary.vigas.volume, summary.lajes.volume);
            
            html += '<table><tbody>';
            html += '<tr><td style="width:80px">Pilares</td><td><div class="bar-container"><div class="bar pilares" style="width:' + (maxVol > 0 ? (summary.pilares.volume/maxVol*100) : 0) + '%">' + summary.pilares.volume.toFixed(1) + ' m³</div></div></td><td class="text-right" style="width:60px">' + (totalVolume > 0 ? (summary.pilares.volume/totalVolume*100).toFixed(1) : 0) + '%</td></tr>';
            html += '<tr><td>Vigas</td><td><div class="bar-container"><div class="bar vigas" style="width:' + (maxVol > 0 ? (summary.vigas.volume/maxVol*100) : 0) + '%">' + summary.vigas.volume.toFixed(1) + ' m³</div></div></td><td class="text-right">' + (totalVolume > 0 ? (summary.vigas.volume/totalVolume*100).toFixed(1) : 0) + '%</td></tr>';
            html += '<tr><td>Lajes</td><td><div class="bar-container"><div class="bar lajes" style="width:' + (maxVol > 0 ? (summary.lajes.volume/maxVol*100) : 0) + '%">' + summary.lajes.volume.toFixed(1) + ' m³</div></div></td><td class="text-right">' + (totalVolume > 0 ? (summary.lajes.volume/totalVolume*100).toFixed(1) : 0) + '%</td></tr>';
            const outrosVol = summary.paredes.volume + summary.fundacoes.volume + summary.estacas.volume;
            html += '<tr><td>Outros</td><td><div class="bar-container"><div class="bar outros" style="width:' + (maxVol > 0 ? (outrosVol/maxVol*100) : 0) + '%">' + outrosVol.toFixed(1) + ' m³</div></div></td><td class="text-right">' + (totalVolume > 0 ? (outrosVol/totalVolume*100).toFixed(1) : 0) + '%</td></tr>';
            html += '</tbody></table></div>';
            
            // Seção de Área de Forma
            const totalForma = summary.pilares.areaForma + summary.vigas.areaForma;
            if (totalForma > 0) {
                html += '<div class="section">';
                html += '<div class="section-title">Área de Forma</div>';
                html += '<table><thead><tr><th>Elemento</th><th class="text-right">Qtd</th><th class="text-right">Forma (m²)</th><th>Observação</th></tr></thead><tbody>';
                html += '<tr><td>Pilares</td><td class="text-right">' + summary.pilares.count + '</td><td class="text-right">' + summary.pilares.areaForma.toFixed(2) + '</td><td style="font-size:7pt;color:#666;">4 faces laterais (sem topo/base)</td></tr>';
                html += '<tr><td>Vigas</td><td class="text-right">' + summary.vigas.count + '</td><td class="text-right">' + summary.vigas.areaForma.toFixed(2) + '</td><td style="font-size:7pt;color:#666;">2 laterais + fundo (sem topo)</td></tr>';
                html += '<tr style="background:#34495e;color:white;font-weight:bold;"><td>TOTAL</td><td></td><td class="text-right">' + totalForma.toFixed(2) + ' m²</td><td></td></tr>';
                html += '</tbody></table></div>';
            }
            
            // LAJES - Por Pavimento e Tipo (nova estrutura)
            if (Object.keys(summary.lajes.byStoreyTypeHeight || {}).length > 0) {
                // Agrupar por pavimento
                const lajesByStorey = {};
                Object.values(summary.lajes.byStoreyTypeHeight).forEach(item => {
                    const storey = item.storey || 'Sem Pavimento';
                    if (!lajesByStorey[storey]) {
                        lajesByStorey[storey] = [];
                    }
                    lajesByStorey[storey].push(item);
                });
                
                html += '<div class="section">';
                html += '<div class="section-title">📊 Área de Lajes por Pavimento</div>';
                
                // Tabela por pavimento
                let totalGeralArea = 0;
                Object.keys(lajesByStorey).sort().forEach(storey => {
                    const items = lajesByStorey[storey].sort((a, b) => {
                        if (a.tipo !== b.tipo) return a.tipo.localeCompare(b.tipo);
                        return a.altura - b.altura;
                    });
                    
                    let subtotal = 0;
                    html += '<table style="margin-bottom:15px;"><thead>';
                    html += '<tr style="background:#e3f2fd;"><th colspan="3" style="color:#1565c0;font-weight:600;">🏢 ' + storey + '</th></tr>';
                    html += '<tr><th>Tipo</th><th class="text-center">Altura (cm)</th><th class="text-right">Área (m²)</th></tr>';
                    html += '</thead><tbody>';
                    
                    items.forEach(item => {
                        html += '<tr>';
                        html += '<td>' + (item.tipo || 'Laje') + '</td>';
                        html += '<td class="text-center">' + item.altura + '</td>';
                        html += '<td class="text-right">' + item.area.toFixed(2) + '</td>';
                        html += '</tr>';
                        subtotal += item.area;
                    });
                    
                    totalGeralArea += subtotal;
                    html += '<tr style="background:#e8f5e9;font-weight:600;"><td colspan="2">Subtotal</td><td class="text-right" style="color:#2e7d32;">' + subtotal.toFixed(2) + ' m²</td></tr>';
                    html += '</tbody></table>';
                });
                
                // Resumo Geral
                html += '<div style="background:#4caf50;color:white;padding:10px;border-radius:6px;margin-top:10px;">';
                html += '<div style="font-weight:600;margin-bottom:8px;">📋 Resumo Geral de Lajes</div>';
                html += '<table style="width:100%;"><thead><tr style="background:rgba(255,255,255,0.2);"><th style="color:white;">Tipo</th><th class="text-center" style="color:white;">Altura (cm)</th><th class="text-right" style="color:white;">Área (m²)</th></tr></thead><tbody>';
                
                Object.values(summary.lajes.byTypeHeight || {}).sort((a, b) => {
                    if (a.tipo !== b.tipo) return a.tipo.localeCompare(b.tipo);
                    return a.altura - b.altura;
                }).forEach(item => {
                    html += '<tr style="border-bottom:1px solid rgba(255,255,255,0.2);">';
                    html += '<td style="color:white;padding:4px 8px;">' + (item.tipo || 'Laje') + '</td>';
                    html += '<td class="text-center" style="color:white;padding:4px 8px;">' + item.altura + '</td>';
                    html += '<td class="text-right" style="color:white;padding:4px 8px;">' + item.area.toFixed(2) + '</td>';
                    html += '</tr>';
                });
                
                html += '<tr style="background:rgba(255,255,255,0.3);font-weight:bold;"><td colspan="2" style="color:white;padding:6px 8px;">TOTAL GERAL</td><td class="text-right" style="color:white;padding:6px 8px;font-size:12pt;">' + totalGeralArea.toFixed(2) + ' m²</td></tr>';
                html += '</tbody></table></div>';
                html += '</div>';
            }
            
            // Protensão (se houver) - com +7,5% no comprimento e massa engraxada
            if (summary.tendons.count > 0) {
                const compComAcrescimo = summary.tendons.comprimentoTotal * 1.075;
                const pesoEngraxado = compComAcrescimo * 1.24; // massa engraxada
                
                html += '<div class="section">';
                html += '<div class="section-title">Resumo de Protensão</div>';
                html += '<div style="text-align:center; padding: 10px 0;">';
                html += '<div class="mini-card"><div class="val">' + summary.tendons.totalCabos + '</div><div class="lbl">Cabos</div></div>';
                html += '<div class="mini-card"><div class="val">' + compComAcrescimo.toFixed(1) + '</div><div class="lbl">Comp. +7,5% (m)</div></div>';
                html += '<div class="mini-card" style="background:#2c3e50;border-color:#2c3e50;"><div class="val" style="color:#fff;">' + pesoEngraxado.toFixed(1) + '</div><div class="lbl" style="color:#fff;">Peso (kg)</div></div>';
                html += '</div></div>';
            }
            
            // Por Pavimento
            if (byStorey.size > 0) {
                html += '<div class="section">';
                html += '<div class="section-title">Resumo por Pavimento</div>';
                html += '<table><thead><tr><th>Pavimento</th><th>Tipo</th><th class="text-right">Qtd</th><th class="text-right">Volume (m³)</th><th class="text-right">Forma (m²)</th></tr></thead><tbody>';
                
                let grandTotalFormaByStorey = 0;
                byStorey.forEach((data, storeyName) => {
                    let first = true;
                    let storeyVol = 0;
                    let storeyForma = 0;
                    Object.entries(data.types).forEach(([tipo, typeData]) => {
                        html += '<tr>';
                        html += '<td>' + (first ? '<strong>' + storeyName + '</strong>' : '') + '</td>';
                        html += '<td>' + tipo + '</td>';
                        html += '<td class="text-right">' + typeData.count + '</td>';
                        html += '<td class="text-right">' + typeData.volume.toFixed(3) + '</td>';
                        html += '<td class="text-right">' + (typeData.areaForma > 0 ? typeData.areaForma.toFixed(2) : '—') + '</td>';
                        html += '</tr>';
                        first = false;
                        storeyVol += typeData.volume;
                        storeyForma += typeData.areaForma || 0;
                    });
                    grandTotalFormaByStorey += storeyForma;
                });
                
                html += '<tr class="total-row"><td>TOTAL</td><td></td><td class="text-right">' + totalElements + '</td><td class="text-right">' + totalVolume.toFixed(3) + '</td><td class="text-right">' + grandTotalFormaByStorey.toFixed(2) + '</td></tr>';
                html += '</tbody></table></div>';
            }
            
            // Footer
            html += '<div class="footer">';
            html += '<strong>ProCalculo Engenharia</strong> — Quantitativos de Estruturas<br>';
            html += '<span style="font-size: 0.85em;">Desenvolvido por <strong>Eng.Civil Pedro Leite de O. Santos</strong></span><br>';
            html += '<span style="font-size: 0.8em; opacity: 0.8;">Pressione Ctrl+P para salvar como PDF</span>';
            html += '</div>';
            
            html += '</body></html>';
            
            printWindow.document.write(html);
            printWindow.document.close();
            
            printWindow.onload = function() {
                printWindow.focus();
                setTimeout(function() { printWindow.print(); }, 300);
            };
            
            closeExportModal();
            showToast('✓ PDF gerado', 'success');
        }

        // ==========================================
        // UI HELPERS
        // ==========================================
        function switchTab(tabName) {
            document.querySelectorAll('.sidebar-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            document.getElementById(`tab-${tabName}`).classList.add('active');
            document.getElementById(`content-${tabName}`).classList.add('active');

            if (tabName === 'quantities') updateQuantitiesPanel();
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function resetView() {
            if (loadedModel) {
                fitCamera(loadedModel);
                showToast('Vista resetada');
            }
        }

        // ==========================================
        // ANIMATION LOOP
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateViewCube();
            updateMeasureLabels();
        }

        // ==========================================
        // START
        // ==========================================
        document.addEventListener('DOMContentLoaded', function () {
            // Timeout de segurança - se após 30s ainda estiver carregando, mostrar upload
            const safetyTimeout = setTimeout(function() {
                const overlay = document.getElementById('loading-overlay');
                if (overlay && overlay.style.display !== 'none') {
                    console.warn('Timeout de segurança: escondendo overlay');
                    overlay.style.display = 'none';
                    showError('Tempo limite de carregamento excedido.');
                }
            }, 30000);
            
            // Verificar THREE.js
            if (typeof THREE === 'undefined') {
                clearTimeout(safetyTimeout);
                document.getElementById('loading-overlay').style.display = 'none';
                showError('Three.js não foi carregado. Verifique sua conexão com a internet.');
                return;
            }
            
            // Inicializar
            init().then(function() {
                clearTimeout(safetyTimeout);
            }).catch(function(e) {
                clearTimeout(safetyTimeout);
                console.error('Erro fatal:', e);
                document.getElementById('loading-overlay').style.display = 'none';
                showError('Erro na inicialização: ' + (e.message || 'Desconhecido'));
            });
        });

        // ==========================================
        // TOP 5 FEATURES - FUNCTIONS
        // ==========================================

        // ============================================
        // 0. MODO ESCURO
        // ============================================
        
        let darkMode = false;
        
        function toggleDarkMode() {
            darkMode = !darkMode;
            const btn = document.getElementById('btn-dark-mode');
            
            if (darkMode) {
                document.body.classList.add('dark-mode');
                btn.classList.add('active-feature');
                btn.innerHTML = '☀️ Claro';
                localStorage.setItem('darkMode', 'true');
                // Alterar fundo da cena 3D
                if (scene) scene.background = new THREE.Color(0x1a1a2e);
                showToast('Modo escuro ativado');
            } else {
                document.body.classList.remove('dark-mode');
                btn.classList.remove('active-feature');
                btn.innerHTML = '🌙 Escuro';
                localStorage.setItem('darkMode', 'false');
                // Restaurar fundo claro da cena 3D
                if (scene) scene.background = new THREE.Color(0xf5f5f7);
                showToast('Modo claro ativado');
            }
        }
        
        // Carregar preferência de modo escuro
        if (localStorage.getItem('darkMode') === 'true') {
            darkMode = true;
            document.body.classList.add('dark-mode');
            document.addEventListener('DOMContentLoaded', function() {
                const btn = document.getElementById('btn-dark-mode');
                if (btn) {
                    btn.classList.add('active-feature');
                    btn.innerHTML = '☀️ Claro';
                }
                // Aplicar fundo escuro à cena se já carregada
                if (scene) scene.background = new THREE.Color(0x1a1a2e);
            });
        }

        // ============================================
        // 1. BUSCA INTELIGENTE
        // ============================================
        
        function toggleSearch() {
            searchActive = !searchActive;
            const container = document.getElementById('search-container');
            const btn = document.getElementById('btn-search');
            
            if (searchActive) {
                container.classList.add('active');
                btn.classList.add('active-feature');
                document.getElementById('search-input').focus();
            } else {
                container.classList.remove('active');
                btn.classList.remove('active-feature');
                clearSearch();
            }
        }
        
        function clearSearch() {
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').classList.remove('has-results');
            document.getElementById('search-results').innerHTML = '';
        }
        
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                toggleSearch();
            }
            if (e.key === 'Escape' && searchActive) {
                toggleSearch();
            }
        });
        
        document.getElementById('search-input').addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => performSearch(e.target.value), 150);
        });
        
        function performSearch(query) {
            if (!loadedModel || query.length < 1) {
                document.getElementById('search-results').classList.remove('has-results');
                return;
            }
            
            const results = [];
            const queryLower = query.toLowerCase().trim();
            
            // Parse query inteligente
            let volumeFilter = null;
            let tipoFilter = null;
            let pavFilter = null;
            
            // Detectar filtros especiais
            const volumeMatch = queryLower.match(/volume\s*([<>])\s*(\d+(?:\.\d+)?)/);
            if (volumeMatch) {
                volumeFilter = { op: volumeMatch[1], val: parseFloat(volumeMatch[2]) };
            }
            
            const espMatch = queryLower.match(/(?:esp|espessura|h)\s*([<>])\s*(\d+)\s*cm/);
            
            // Detectar tipos
            if (queryLower.includes('pilar') || queryLower.includes('coluna')) tipoFilter = 'Pilar';
            if (queryLower.includes('viga') || queryLower.includes('beam')) tipoFilter = 'Viga';
            if (queryLower.includes('laje') || queryLower.includes('slab')) tipoFilter = 'Laje';
            if (queryLower.includes('maciça') || queryLower.includes('macica')) tipoFilter = 'Maciça';
            if (queryLower.includes('nervurada')) tipoFilter = 'Nervurada';
            
            // Detectar pavimento
            if (queryLower.includes('térreo') || queryLower.includes('terreo')) pavFilter = 'térreo';
            if (queryLower.includes('cobertura')) pavFilter = 'cobertura';
            if (queryLower.includes('subsolo')) pavFilter = 'subsolo';
            
            loadedModel.traverse((node) => {
                if (!node.isMesh || !node.userData.info) return;
                
                const info = node.userData.info;
                const nome = (info.nome || '').toLowerCase();
                const tipo = (info.tipo || '').toLowerCase();
                const storey = (info.storey || '').toLowerCase();
                const tipoLaje = (info.tipoLaje || '').toLowerCase();
                
                let match = false;
                
                // Busca por nome direto
                if (nome.includes(queryLower) || tipo.includes(queryLower)) {
                    match = true;
                }
                
                // Filtro por tipo
                if (tipoFilter && !match) {
                    if (tipoFilter === 'Maciça' || tipoFilter === 'Nervurada') {
                        if (tipoLaje.includes(tipoFilter.toLowerCase())) match = true;
                    } else if (tipo.includes(tipoFilter.toLowerCase())) {
                        match = true;
                    }
                }
                
                // Filtro por pavimento
                if (pavFilter && match) {
                    if (!storey.includes(pavFilter)) match = false;
                }
                
                // Filtro por volume
                if (volumeFilter && match) {
                    const vol = info.volume || 0;
                    if (volumeFilter.op === '>' && vol <= volumeFilter.val) match = false;
                    if (volumeFilter.op === '<' && vol >= volumeFilter.val) match = false;
                }
                
                if (match && results.length < 20) {
                    results.push({
                        node: node,
                        info: info
                    });
                }
            });
            
            renderSearchResults(results);
        }
        
        function renderSearchResults(results) {
            const container = document.getElementById('search-results');
            
            if (results.length === 0) {
                container.classList.remove('has-results');
                return;
            }
            
            container.classList.add('has-results');
            container.innerHTML = results.map((r, i) => {
                const tipo = (r.info.tipo || 'Outros').toLowerCase();
                let iconClass = 'other';
                let icon = '📦';
                
                if (tipo.includes('pilar')) { iconClass = 'pilar'; icon = '🏛️'; }
                if (tipo.includes('viga')) { iconClass = 'viga'; icon = '📏'; }
                if (tipo.includes('laje')) { iconClass = 'laje'; icon = '⬛'; }
                
                return `
                    <div class="search-result-item" onclick="selectSearchResult(${i})">
                        <div class="search-result-icon ${iconClass}">${icon}</div>
                        <div class="search-result-info">
                            <div class="search-result-name">${r.info.nome || 'Sem nome'}</div>
                            <div class="search-result-meta">${r.info.tipo || '-'} • ${r.info.storey || '-'} • ${(r.info.volume || 0).toFixed(3)} m³</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Guardar resultados para seleção
            window._searchResults = results;
        }
        
        function selectSearchResult(index) {
            const result = window._searchResults[index];
            if (!result || !result.node) return;
            
            // Desselecionar anterior
            if (selectedMesh && selectedMesh.material) {
                if (selectedMesh.material.emissive) {
                    selectedMesh.material.emissive.setHex(0x000000);
                }
            }
            
            selectedMesh = result.node;
            
            // Selecionar novo (com verificação de material)
            if (selectedMesh.material && selectedMesh.material.emissive) {
                selectedMesh.material.emissive.setHex(0x444444);
            }
            
            // Focar câmera no elemento com zoom adequado
            const box = new THREE.Box3().setFromObject(result.node);
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            
            // Calcular distância da câmera baseado no tamanho do elemento
            const maxDim = Math.max(size.x, size.y, size.z);
            const minDist = 3; // Distância mínima
            const dist = Math.max(maxDim * 3, minDist); // 3x o tamanho do elemento ou mínimo
            
            // Posicionar câmera em ângulo isométrico
            const offsetX = dist * 0.7;
            const offsetY = dist * 0.5;
            const offsetZ = dist * 0.7;
            
            camera.position.set(
                center.x + offsetX,
                center.y + offsetY,
                center.z + offsetZ
            );
            
            // Apontar para o centro do elemento
            controls.target.copy(center);
            controls.update();
            
            // Forçar render
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            
            // Mostrar propriedades
            const info = result.node.userData.info || { nome: result.nome, tipo: result.tipo };
            showProperties(info, result.node);
            
            // Fechar busca
            toggleSearch();
            
            showToast(`${result.nome} selecionado`);
        }

        // ============================================
        // 2. CORTE DINÂMICO 3D
        // ============================================
        
        function toggleDynamicCut() {
            dynamicCutActive = !dynamicCutActive;
            const panel = document.getElementById('dynamic-cut-panel');
            const btn = document.getElementById('btn-dynamic-cut');
            
            if (dynamicCutActive) {
                panel.classList.add('active');
                btn.classList.add('active-feature');
                initDynamicCut();
            } else {
                panel.classList.remove('active');
                btn.classList.remove('active-feature');
                resetDynamicCut();
            }
        }
        
        function initDynamicCut() {
            if (!loadedModel) return;
            
            // Calcular bounds do modelo
            const box = new THREE.Box3().setFromObject(loadedModel);
            
            dynamicCutBounds = {
                X: { min: box.min.x, max: box.max.x },
                Y: { min: box.min.y, max: box.max.y },
                Z: { min: box.min.z, max: box.max.z }
            };
            
            // Criar clipping plane real
            clippingPlane = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0);
            
            // Aplicar clipping plane a todos os materiais do modelo
            loadedModel.traverse((node) => {
                if (node.isMesh && node.material) {
                    // Clonar material para não afetar outros objetos
                    if (!node.userData.originalMaterial) {
                        node.userData.originalMaterial = node.material;
                        node.material = node.material.clone();
                    }
                    node.material.clippingPlanes = [clippingPlane];
                    node.material.clipShadows = true;
                    node.material.needsUpdate = true;
                }
            });
            
            updateCutSliderBounds();
            
            // Criar plano de corte visual
            createCutPlaneVisual();
            
            // Aplicar corte inicial
            updateDynamicCut(document.getElementById('cut-slider').value);
        }
        
        function createCutPlaneVisual() {
            // Não criar visualização do plano - apenas o corte real
            if (dynamicCutPlane) {
                scene.remove(dynamicCutPlane);
                dynamicCutPlane = null;
            }
        }
        
        function updateCutSliderBounds() {
            const bounds = dynamicCutBounds[dynamicCutAxis];
            if (!bounds) return;
            
            document.getElementById('cut-min').textContent = bounds.min.toFixed(2);
            document.getElementById('cut-max').textContent = bounds.max.toFixed(2);
            
            const slider = document.getElementById('cut-slider');
            slider.min = bounds.min;
            slider.max = bounds.max;
            
            // Começar no máximo (mostrando tudo)
            slider.value = bounds.max;
            
            dynamicCutValue = parseFloat(slider.value);
            document.getElementById('cut-value').textContent = dynamicCutValue.toFixed(2);
        }
        
        function setCutAxis(axis) {
            dynamicCutAxis = axis;
            
            // Atualizar botões
            document.querySelectorAll('.cut-axis-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('cut-axis-' + axis.toLowerCase()).classList.add('active');
            
            // Atualizar normal do clipping plane
            if (clippingPlane) {
                if (axis === 'X') {
                    clippingPlane.normal.set(-1, 0, 0);
                } else if (axis === 'Y') {
                    clippingPlane.normal.set(0, -1, 0);
                } else {
                    clippingPlane.normal.set(0, 0, -1);
                }
            }
            
            updateCutSliderBounds();
            createCutPlaneVisual();
            updateDynamicCut(document.getElementById('cut-slider').value);
        }
        
        function updateCutPlanePosition() {
            // Plano visual removido - função mantida para compatibilidade
        }
        
        function updateDynamicCut(value) {
            dynamicCutValue = parseFloat(value);
            document.getElementById('cut-value').textContent = dynamicCutValue.toFixed(2);
            
            updateCutPlanePosition();
            
            // Atualizar clipping plane real
            if (clippingPlane) {
                // A constante do plano é a distância da origem
                // Plane: normal.x * x + normal.y * y + normal.z * z + constant = 0
                // Para cortar em X=value: -1*x + 0*y + 0*z + value = 0 -> x = value
                clippingPlane.constant = dynamicCutValue;
            }
        }
        
        function animateCut() {
            if (cutAnimationId) {
                cancelAnimationFrame(cutAnimationId);
                cutAnimationId = null;
                showToast('⏹ Animação parada');
                return;
            }
            
            const bounds = dynamicCutBounds[dynamicCutAxis];
            const slider = document.getElementById('cut-slider');
            let direction = -1; // Começar removendo
            const speed = (bounds.max - bounds.min) / 150;
            
            // Começar do máximo
            dynamicCutValue = bounds.max;
            
            function animate() {
                dynamicCutValue += speed * direction;
                
                if (dynamicCutValue <= bounds.min) direction = 1;
                if (dynamicCutValue >= bounds.max) direction = -1;
                
                slider.value = dynamicCutValue;
                updateDynamicCut(dynamicCutValue);
                
                cutAnimationId = requestAnimationFrame(animate);
            }
            
            animate();
            showToast('▶ Animando corte...');
        }
        
        function resetDynamicCut() {
            if (cutAnimationId) {
                cancelAnimationFrame(cutAnimationId);
                cutAnimationId = null;
            }
            
            // Remover clipping planes dos materiais e restaurar originais
            if (loadedModel) {
                loadedModel.traverse((node) => {
                    if (node.isMesh && node.material) {
                        node.material.clippingPlanes = [];
                        node.material.needsUpdate = true;
                        
                        // Restaurar visibilidade
                        node.visible = true;
                    }
                });
            }
            
            // Limpar clipping plane
            clippingPlane = null;
            
            // Remover plano de corte visual
            if (dynamicCutPlane) {
                scene.remove(dynamicCutPlane);
                dynamicCutPlane = null;
            }
            
            // Aplicar filtros existentes
            applyFilters();
        }

        // ============================================
        // 3. CHECKLIST DE EXECUÇÃO
        // ============================================
        
        function toggleChecklist() {
            checklistActive = !checklistActive;
            const panel = document.getElementById('checklist-panel');
            const btn = document.getElementById('btn-checklist');
            
            if (checklistActive) {
                panel.classList.add('active');
                btn.classList.add('active-feature');
                renderChecklist();
            } else {
                panel.classList.remove('active');
                btn.classList.remove('active-feature');
            }
        }
        
        function renderChecklist() {
            const body = document.getElementById('checklist-body');
            if (!loadedModel) {
                body.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">Carregue um modelo primeiro</div>';
                return;
            }
            
            // Agrupar por pavimento e depois por tipo
            const byStorey = new Map();
            let totalCount = 0;
            
            // Tipos permitidos (incluindo fundações)
            const tiposPermitidos = ['Pilar', 'Viga', 'Laje', 'Fundacao', 'Estaca', 'Parede'];
            
            loadedModel.traverse((node) => {
                if (!node.isMesh || !node.userData.info) return;
                
                const info = node.userData.info;
                const storey = info.storey || 'Sem Pavimento';
                let tipo = info.tipo || 'Outros';
                
                // Normalizar tipo
                if (tipo.toLowerCase().includes('fundacao') || tipo.toLowerCase().includes('sapata') || tipo.toLowerCase().includes('bloco')) {
                    tipo = 'Fundacao';
                } else if (tipo.toLowerCase().includes('estaca')) {
                    tipo = 'Estaca';
                }
                
                // Só incluir tipos permitidos
                if (!tiposPermitidos.includes(tipo)) return;
                
                if (!byStorey.has(storey)) {
                    byStorey.set(storey, new Map());
                }
                
                const storeyMap = byStorey.get(storey);
                if (!storeyMap.has(tipo)) {
                    storeyMap.set(tipo, []);
                }
                
                storeyMap.get(tipo).push({
                    node: node,
                    info: info,
                    id: node.uuid
                });
                totalCount++;
            });
            
            // Ordenar pavimentos
            const sortedStoreys = Array.from(byStorey.keys()).sort((a, b) => {
                const _mA = a.match(/-?\d+\.?\d*/);
            const numA = parseFloat((_mA && _mA[0]) ? _mA[0] : '0');
                const _mB = b.match(/-?\d+\.?\d*/);
            const numB = parseFloat((_mB && _mB[0]) ? _mB[0] : '0');
                return numA - numB;
            });
            
            // Ordem dos tipos
            const tipoOrdem = ['Fundacao', 'Estaca', 'Pilar', 'Viga', 'Laje', 'Parede'];
            
            // Renderizar
            let html = '';
            sortedStoreys.forEach((storey) => {
                const storeyMap = byStorey.get(storey);
                let allItems = [];
                storeyMap.forEach(items => allItems = allItems.concat(items));
                const completedInStorey = allItems.filter(it => completedElements.has(it.id)).length;
                const storeyId = storey.replace(/[^a-zA-Z0-9]/g, '_');
                
                html += `
                    <div class="checklist-storey" data-storey-id="${storeyId}">
                        <div class="checklist-storey-header" onclick="toggleChecklistStorey(this)">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <div class="checklist-folder-check" onclick="event.stopPropagation(); toggleStoreyComplete('${storeyId}', this)" 
                                     style="width:18px; height:18px; border:2px solid #007AFF; border-radius:4px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:12px; color:#007AFF;">
                                    ${completedInStorey === allItems.length && allItems.length > 0 ? '✓' : ''}
                                </div>
                                <span>${storey}</span>
                            </div>
                            <span class="checklist-storey-count">${completedInStorey}/${allItems.length}</span>
                        </div>
                        <div class="checklist-items" style="display:none;">
                `;
                
                // Ordenar tipos
                const sortedTipos = Array.from(storeyMap.keys()).sort((a, b) => {
                    return tipoOrdem.indexOf(a) - tipoOrdem.indexOf(b);
                });
                
                sortedTipos.forEach(tipo => {
                    const items = storeyMap.get(tipo);
                    const completedInTipo = items.filter(it => completedElements.has(it.id)).length;
                    const tipoId = `${storeyId}_${tipo}`;
                    
                    html += `
                        <div class="checklist-tipo" data-tipo-id="${tipoId}">
                            <div class="checklist-tipo-header" onclick="toggleChecklistTipo(this)" style="padding:8px 12px; background:#f8f9fa; margin:4px 0; border-radius:6px; cursor:pointer; display:flex; justify-content:space-between; align-items:center;">
                                <div style="display:flex; align-items:center; gap:8px;">
                                    <div class="checklist-tipo-check" onclick="event.stopPropagation(); toggleTipoComplete('${tipoId}', this)"
                                         style="width:16px; height:16px; border:2px solid #888; border-radius:3px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:10px; color:#888;">
                                        ${completedInTipo === items.length && items.length > 0 ? '✓' : ''}
                                    </div>
                                    <span style="font-weight:500; font-size:12px;">${tipo}s</span>
                                </div>
                                <span style="font-size:11px; color:#666;">${completedInTipo}/${items.length}</span>
                            </div>
                            <div class="checklist-tipo-items" style="display:none; padding-left:20px;">
                                ${items.map(it => `
                                    <div class="checklist-item ${completedElements.has(it.id) ? 'completed' : ''}" 
                                         data-id="${it.id}"
                                         data-tipo="${tipo}"
                                         data-storey="${storeyId}"
                                         onclick="toggleChecklistItem('${it.id}', this)"
                                         onmouseenter="highlightElement('${it.id}')"
                                         onmouseleave="unhighlightElement('${it.id}')">
                                        <div class="checklist-checkbox">${completedElements.has(it.id) ? '✓' : ''}</div>
                                        <span class="checklist-item-name">${it.info.nome || 'Sem nome'}</span>
                                        <span class="checklist-item-vol">${(it.info.volume || 0).toFixed(2)}m³</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            body.innerHTML = html;
            updateChecklistProgress(totalCount);
        }
        
        function toggleChecklistTipo(header) {
            const items = header.nextElementSibling;
            items.style.display = items.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleTipoComplete(tipoId, checkEl) {
            const tipoDiv = checkEl.closest('.checklist-tipo');
            const items = tipoDiv.querySelectorAll('.checklist-item');
            const allCompleted = Array.from(items).every(it => it.classList.contains('completed'));
            
            items.forEach(item => {
                const id = item.dataset.id;
                if (allCompleted) {
                    completedElements.delete(id);
                    item.classList.remove('completed');
                    item.querySelector('.checklist-checkbox').textContent = '';
                } else {
                    completedElements.add(id);
                    item.classList.add('completed');
                    item.querySelector('.checklist-checkbox').textContent = '✓';
                }
                updateElementCompletionVisual(id);
            });
            
            // Atualizar visual do check do tipo
            const newCompleted = !allCompleted;
            checkEl.textContent = newCompleted ? '✓' : '';
            checkEl.style.borderColor = newCompleted ? '#34c759' : '#888';
            checkEl.style.color = newCompleted ? '#34c759' : '#888';
            
            // Atualizar contadores
            updateChecklistCounters();
            saveChecklistState();
        }
        
        function toggleStoreyComplete(storeyId, checkEl) {
            const storeyDiv = checkEl.closest('.checklist-storey');
            const items = storeyDiv.querySelectorAll('.checklist-item');
            const allCompleted = Array.from(items).every(it => it.classList.contains('completed'));
            
            items.forEach(item => {
                const id = item.dataset.id;
                if (allCompleted) {
                    completedElements.delete(id);
                    item.classList.remove('completed');
                    item.querySelector('.checklist-checkbox').textContent = '';
                } else {
                    completedElements.add(id);
                    item.classList.add('completed');
                    item.querySelector('.checklist-checkbox').textContent = '✓';
                }
                updateElementCompletionVisual(id);
            });
            
            // Atualizar visual do check do pavimento
            const newCompleted = !allCompleted;
            checkEl.textContent = newCompleted ? '✓' : '';
            checkEl.style.borderColor = newCompleted ? '#34c759' : '#007AFF';
            checkEl.style.color = newCompleted ? '#34c759' : '#007AFF';
            
            // Atualizar checks dos tipos
            storeyDiv.querySelectorAll('.checklist-tipo-check').forEach(tc => {
                tc.textContent = newCompleted ? '✓' : '';
                tc.style.borderColor = newCompleted ? '#34c759' : '#888';
                tc.style.color = newCompleted ? '#34c759' : '#888';
            });
            
            // Atualizar contadores
            updateChecklistCounters();
            saveChecklistState();
        }
        
        function updateChecklistCounters() {
            // Atualizar contadores de cada pavimento e tipo
            document.querySelectorAll('.checklist-storey').forEach(storey => {
                const allItems = storey.querySelectorAll('.checklist-item');
                const completed = storey.querySelectorAll('.checklist-item.completed');
                storey.querySelector('.checklist-storey-count').textContent = `${completed.length}/${allItems.length}`;
                
                // Atualizar check do pavimento
                const folderCheck = storey.querySelector('.checklist-folder-check');
                if (folderCheck) {
                    const allDone = completed.length === allItems.length && allItems.length > 0;
                    folderCheck.textContent = allDone ? '✓' : '';
                    folderCheck.style.borderColor = allDone ? '#34c759' : '#007AFF';
                    folderCheck.style.color = allDone ? '#34c759' : '#007AFF';
                }
                
                // Atualizar cada tipo
                storey.querySelectorAll('.checklist-tipo').forEach(tipo => {
                    const tipoItems = tipo.querySelectorAll('.checklist-item');
                    const tipoCompleted = tipo.querySelectorAll('.checklist-item.completed');
                    const countEl = tipo.querySelector('.checklist-tipo-header span:last-child');
                    if (countEl) {
                        countEl.textContent = `${tipoCompleted.length}/${tipoItems.length}`;
                    }
                    
                    const tipoCheck = tipo.querySelector('.checklist-tipo-check');
                    if (tipoCheck) {
                        const allDone = tipoCompleted.length === tipoItems.length && tipoItems.length > 0;
                        tipoCheck.textContent = allDone ? '✓' : '';
                        tipoCheck.style.borderColor = allDone ? '#34c759' : '#888';
                        tipoCheck.style.color = allDone ? '#34c759' : '#888';
                    }
                });
            });
            
            // Atualizar progresso total
            let total = document.querySelectorAll('.checklist-item').length;
            updateChecklistProgress(total);
        }
        
        function toggleChecklistStorey(header) {
            const items = header.nextElementSibling;
            items.style.display = items.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleChecklistItem(id, element) {
            if (completedElements.has(id)) {
                completedElements.delete(id);
                element.classList.remove('completed');
                element.querySelector('.checklist-checkbox').textContent = '';
            } else {
                completedElements.add(id);
                element.classList.add('completed');
                element.querySelector('.checklist-checkbox').textContent = '✓';
            }
            
            // Atualizar visual no 3D
            updateElementCompletionVisual(id);
            
            // Atualizar todos os contadores
            updateChecklistCounters();
            
            // Salvar no localStorage
            saveChecklistState();
        }
        
        function updateElementCompletionVisual(id) {
            if (!loadedModel) return;
            
            loadedModel.traverse((node) => {
                if (node.uuid === id && node.isMesh) {
                    if (completedElements.has(id)) {
                        node.material.color.setHex(0x34c759); // Verde
                    } else {
                        // Restaurar cor original
                        const tipo = (((node.userData && node.userData.info && node.userData.info.tipo) ? node.userData.info.tipo : '') || '').toLowerCase();
                        if (tipo.includes('pilar')) node.material.color.setHex(0x4a90d9);
                        else if (tipo.includes('viga')) node.material.color.setHex(0x7cb342);
                        else if (tipo.includes('laje')) node.material.color.setHex(0xb0bec5);
                        else node.material.color.setHex(0x999999);
                    }
                }
            });
        }
        
        function highlightElement(id) {
            if (!loadedModel) return;
            loadedModel.traverse((node) => {
                if (node.uuid === id && node.isMesh) {
                    node.material.emissive.setHex(0x333333);
                }
            });
        }
        
        function unhighlightElement(id) {
            if (!loadedModel) return;
            loadedModel.traverse((node) => {
                if (node.uuid === id && node.isMesh) {
                    node.material.emissive.setHex(0x000000);
                }
            });
        }
        
        function updateChecklistProgress(total) {
            const completed = completedElements.size;
            const percent = total > 0 ? Math.round((completed / total) * 100) : 0;
            
            document.getElementById('checklist-progress-fill').style.width = percent + '%';
            document.getElementById('checklist-progress-text').textContent = percent + '%';
        }
        
        function clearChecklist() {
            if (!confirm('Limpar todo o progresso do checklist?')) return;
            
            completedElements.clear();
            renderChecklist();
            
            // Restaurar cores
            if (loadedModel) {
                loadedModel.traverse((node) => {
                    if (node.isMesh && node.userData.info) {
                        const tipo = (node.userData.info.tipo || '').toLowerCase();
                        if (tipo.includes('pilar')) node.material.color.setHex(0x4a90d9);
                        else if (tipo.includes('viga')) node.material.color.setHex(0x7cb342);
                        else if (tipo.includes('laje')) node.material.color.setHex(0xb0bec5);
                    }
                });
            }
            
            localStorage.removeItem('checklistState');
            showToast('🗑️ Checklist limpo');
        }
        
        function saveChecklistState() {
            const state = Array.from(completedElements);
            localStorage.setItem('checklistState', JSON.stringify(state));
        }
        
        function loadChecklistState() {
            try {
                const state = JSON.parse(localStorage.getItem('checklistState') || '[]');
                completedElements = new Set(state);
            } catch (e) {
                completedElements = new Set();
            }
        }
        
        function exportChecklist() {
            const summary = generateQuantitySummary();
            const totalElements = summary.pilares.count + summary.vigas.count + summary.lajes.count;
            const completedCount = completedElements.size;
            const percent = totalElements > 0 ? Math.round((completedCount / totalElements) * 100) : 0;
            
            let text = 'CHECKLIST DE EXECUÇÃO - ProCalculo\n';
            text += '=' .repeat(40) + '\n';
            text += `Data: ${new Date().toLocaleString('pt-BR')}\n`;
            text += `Progresso: ${completedCount}/${totalElements} (${percent}%)\n\n`;
            
            // Listar completos
            text += 'ELEMENTOS CONCLUÍDOS:\n';
            text += '-'.repeat(40) + '\n';
            
            loadedModel.traverse((node) => {
                if (node.isMesh && completedElements.has(node.uuid)) {
                    const info = node.userData.info;
                    text += `✓ ${info.nome} | ${info.storey || '-'} | ${(info.volume || 0).toFixed(3)} m³\n`;
                }
            });
            
            // Download
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'checklist_' + new Date().toISOString().split('T')[0] + '.txt';
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('📤 Checklist exportado');
        }

        // ============================================
        // 4. COMPOSIÇÃO DE CUSTOS
        // ============================================
        
        let acoMode = 'informar'; // 'informar' ou 'estimar'
        
        function openCostModal() {
            document.getElementById('cost-modal').classList.add('active');
            recalcCosts();
        }
        
        function closeCostModal() {
            document.getElementById('cost-modal').classList.remove('active');
        }
        
        // Fechar modal ao clicar fora
        document.getElementById('cost-modal').addEventListener('click', function(e) {
            if (e.target === this) closeCostModal();
        });
        
        // Recalcular ao mudar inputs
        document.querySelectorAll('.cost-input').forEach(input => {
            input.addEventListener('input', recalcCosts);
        });
        
        function setAcoMode(mode) {
            acoMode = mode;
            
            const btnInformar = document.getElementById('btn-aco-informar');
            const btnEstimar = document.getElementById('btn-aco-estimar');
            const modeInformar = document.getElementById('aco-mode-informar');
            const modeEstimar = document.getElementById('aco-mode-estimar');
            
            if (mode === 'informar') {
                btnInformar.style.background = '#007AFF';
                btnInformar.style.color = 'white';
                btnEstimar.style.background = '#f0f0f0';
                btnEstimar.style.color = '#333';
                modeInformar.style.display = 'block';
                modeEstimar.style.display = 'none';
            } else {
                btnEstimar.style.background = '#007AFF';
                btnEstimar.style.color = 'white';
                btnInformar.style.background = '#f0f0f0';
                btnInformar.style.color = '#333';
                modeInformar.style.display = 'none';
                modeEstimar.style.display = 'block';
            }
            
            recalcCosts();
        }
        
        let escoraMode = 'madeira'; // 'madeira' ou 'metalico'
        
        function setEscoraMode(mode) {
            escoraMode = mode;
            
            const btnMadeira = document.getElementById('btn-escora-madeira');
            const btnMetalico = document.getElementById('btn-escora-metalico');
            const modeMadeira = document.getElementById('escora-mode-madeira');
            const modeMetalico = document.getElementById('escora-mode-metalico');
            
            if (mode === 'madeira') {
                btnMadeira.style.background = '#007AFF';
                btnMadeira.style.color = 'white';
                btnMetalico.style.background = '#f0f0f0';
                btnMetalico.style.color = '#333';
                modeMadeira.style.display = 'block';
                modeMetalico.style.display = 'none';
            } else {
                btnMetalico.style.background = '#007AFF';
                btnMetalico.style.color = 'white';
                btnMadeira.style.background = '#f0f0f0';
                btnMadeira.style.color = '#333';
                modeMadeira.style.display = 'none';
                modeMetalico.style.display = 'block';
            }
            
            recalcCosts();
        }
        
        function recalcCosts() {
            const summary = generateQuantitySummary();
            
            // Obter preços
            const precoConcreto = parseFloat(document.getElementById('cost-concreto').value) || 0;
            const precoBomba = parseFloat(document.getElementById('cost-bomba').value) || 0;
            const precoForma = parseFloat(document.getElementById('cost-forma').value) || 0;
            const precoAco = parseFloat(document.getElementById('cost-aco').value) || 0;
            const precoEscoraMadeira = parseFloat(document.getElementById('cost-escora-madeira').value) || 0;
            const precoEscoraMetalico = parseFloat(document.getElementById('cost-escora-metalico').value) || 0;
            const precoProtensaoMaterial = parseFloat(document.getElementById('cost-protensao-material').value) || 0;
            const precoProtensaoMO = parseFloat(document.getElementById('cost-protensao-mo').value) || 0;
            
            // Protensão - dados do summary com acréscimo de 4% e massa engraxada
            const protensaoNumCabos = summary.tendons ? summary.tendons.totalCabos : 0;
            const protensaoComprimentoBase = summary.tendons ? summary.tendons.comprimentoTotal : 0;
            const protensaoComprimento = protensaoComprimentoBase * 1.075; // +7,5% para ancoragens/perdas
            const PESO_ENGRAXADA = 1.24; // kg/m - massa engraxada Ø15.2mm
            const protensaoPeso = protensaoComprimento * PESO_ENGRAXADA;
            
            // Mostrar/esconder seção de protensão
            const sectionProtensao = document.getElementById('cost-section-protensao');
            const totalProtensaoRow = document.getElementById('total-protensao-row');
            if (protensaoNumCabos > 0) {
                sectionProtensao.style.display = 'block';
                totalProtensaoRow.style.display = 'flex';
                
                // Atualizar displays de protensão
                document.getElementById('protensao-num-cabos').textContent = protensaoNumCabos;
                document.getElementById('protensao-comprimento').textContent = protensaoComprimento.toFixed(2).replace('.', ',') + ' m (+7,5%)';
                document.getElementById('protensao-peso').textContent = protensaoPeso.toFixed(2).replace('.', ',') + ' kg';
                
                // Calcular subtotais de protensão
                const subtotalProtensaoMaterial = protensaoPeso * precoProtensaoMaterial;
                const subtotalProtensaoMO = protensaoPeso * precoProtensaoMO;
                const subtotalProtensao = subtotalProtensaoMaterial + subtotalProtensaoMO;
                
                document.getElementById('subtotal-protensao-material').textContent = formatCurrency(subtotalProtensaoMaterial);
                document.getElementById('subtotal-protensao-mo').textContent = formatCurrency(subtotalProtensaoMO);
                document.getElementById('subtotal-protensao').textContent = formatCurrency(subtotalProtensao);
                document.getElementById('total-protensao').textContent = formatCurrency(subtotalProtensao);
            } else {
                sectionProtensao.style.display = 'none';
                totalProtensaoRow.style.display = 'none';
            }
            
            // Volumes
            const volTotal = summary.pilares.volume + summary.vigas.volume + summary.lajes.volume +
                            summary.paredes.volume + summary.fundacoes.volume + summary.estacas.volume;
            
            // Forma
            const areaForma = summary.pilares.areaForma + summary.vigas.areaForma;
            
            // Área de laje para escoramento
            const areaLaje = summary.lajes.area || 0;
            
            // Estimativa de aço por taxas
            const acoEstimado = 
                summary.pilares.volume * costTaxasAco.pilar +
                summary.vigas.volume * costTaxasAco.viga +
                summary.lajes.volume * costTaxasAco.laje +
                summary.fundacoes.volume * costTaxasAco.fundacao +
                summary.estacas.volume * costTaxasAco.estaca +
                summary.paredes.volume * costTaxasAco.parede;
            
            // Atualizar display de aço estimado
            document.getElementById('aco-estimado-total').textContent = acoEstimado.toFixed(0) + ' kg';
            document.getElementById('subtotal-aco-estimado').textContent = formatCurrency(acoEstimado * precoAco);
            
            // Calcular aço - depende do modo
            let acoTotal = 0;
            
            if (acoMode === 'informar') {
                // Usar valores informados pelo usuário
                const acoPilares = parseFloat(document.getElementById('aco-pilares-kg').value) || 0;
                const acoVigas = parseFloat(document.getElementById('aco-vigas-kg').value) || 0;
                const acoLajes = parseFloat(document.getElementById('aco-lajes-kg').value) || 0;
                const acoFundacoes = parseFloat(document.getElementById('aco-fundacoes-kg').value) || 0;
                
                acoTotal = acoPilares + acoVigas + acoLajes + acoFundacoes;
                
                // Atualizar subtotais de cada tipo
                document.getElementById('subtotal-aco-pilares').textContent = formatCurrency(acoPilares * precoAco);
                document.getElementById('subtotal-aco-vigas').textContent = formatCurrency(acoVigas * precoAco);
                document.getElementById('subtotal-aco-lajes').textContent = formatCurrency(acoLajes * precoAco);
                document.getElementById('subtotal-aco-fundacoes').textContent = formatCurrency(acoFundacoes * precoAco);
                document.getElementById('aco-total-informado').textContent = acoTotal.toFixed(0) + ' kg';
            } else {
                // Usar estimativa por taxas
                acoTotal = acoEstimado;
            }
            
            // Calcular escoramento - depende do modo e área de laje
            let precoEscora = escoraMode === 'madeira' ? precoEscoraMadeira : precoEscoraMetalico;
            const subtotalEscora = areaLaje * precoEscora;
            
            // Atualizar display de escoramento
            document.getElementById('area-laje-escora').textContent = areaLaje.toFixed(2).replace('.', ',') + ' m²';
            document.getElementById('subtotal-escora').textContent = formatCurrency(subtotalEscora);
            
            // Calcular subtotais
            const subtotalConcreto = volTotal * precoConcreto;
            const subtotalBomba = volTotal * precoBomba;
            const subtotalForma = areaForma * precoForma;
            const subtotalAco = acoTotal * precoAco;
            
            // Atualizar displays
            document.getElementById('subtotal-concreto').textContent = formatCurrency(subtotalConcreto);
            document.getElementById('subtotal-bomba').textContent = formatCurrency(subtotalBomba);
            document.getElementById('subtotal-forma').textContent = formatCurrency(subtotalForma);
            document.getElementById('subtotal-aco').textContent = formatCurrency(subtotalAco);
            
            // Totais
            const totalConcreto = subtotalConcreto + subtotalBomba;
            const totalForma = subtotalForma;
            const totalAco = subtotalAco;
            const totalEscora = subtotalEscora;
            
            // Total de protensão
            const totalProtensao = protensaoNumCabos > 0 ? 
                (protensaoPeso * precoProtensaoMaterial) + (protensaoPeso * precoProtensaoMO) : 0;
            
            const totalDireto = totalConcreto + totalForma + totalAco + totalEscora + totalProtensao;
            
            document.getElementById('total-concreto').textContent = formatCurrency(totalConcreto);
            document.getElementById('total-forma').textContent = formatCurrency(totalForma);
            document.getElementById('total-aco').textContent = formatCurrency(totalAco);
            document.getElementById('total-escora').textContent = formatCurrency(totalEscora);
            document.getElementById('total-direto').textContent = formatCurrency(totalDireto);
            
            // Guardar para exportação
            window._costData = {
                volumes: {
                    total: volTotal,
                    pilares: summary.pilares.volume,
                    vigas: summary.vigas.volume,
                    lajes: summary.lajes.volume,
                    fundacoes: summary.fundacoes.volume,
                    estacas: summary.estacas.volume
                },
                areas: {
                    forma: areaForma,
                    lajes: areaLaje
                },
                protensao: {
                    numCabos: protensaoNumCabos,
                    comprimento: protensaoComprimento,
                    peso: protensaoPeso,
                    precoMaterial: precoProtensaoMaterial,
                    precoMO: precoProtensaoMO
                },
                acoTotal: acoTotal,
                acoEstimado: acoEstimado,
                acoMode: acoMode,
                escoraMode: escoraMode,
                precoEscora: precoEscora,
                precos: { precoConcreto, precoBomba, precoForma, precoAco, precoEscoraMadeira, precoEscoraMetalico, precoProtensaoMaterial, precoProtensaoMO },
                totais: { totalConcreto, totalForma, totalAco, totalEscora, totalProtensao, totalDireto }
            };
        }
        
        function formatCurrency(value) {
            return 'R$ ' + value.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }
        
        function exportCostPDF() {
            const data = window._costData;
            if (!data) {
                showToast('Calcule os custos primeiro', 'error');
                return;
            }
            
            const date = new Date().toLocaleDateString('pt-BR');
            
            const printWindow = window.open('', '_blank');
            let html = '<!DOCTYPE html><html><head><meta charset="UTF-8">';
            html += '<title>Orcamento Estrutural - ProCalculo</title>';
            html += '<style>';
            html += 'body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; }';
            html += 'h1 { color: #2c3e50; border-bottom: 2px solid #007AFF; padding-bottom: 10px; }';
            html += 'h2 { color: #333; margin-top: 30px; font-size: 16px; }';
            html += 'table { width: 100%; border-collapse: collapse; margin: 15px 0; }';
            html += 'th, td { padding: 10px; text-align: left; border-bottom: 1px solid #eee; }';
            html += 'th { background: #f8f9fa; font-weight: 500; }';
            html += '.text-right { text-align: right; }';
            html += '.total { background: #007AFF; color: white; font-weight: bold; }';
            html += '.subtotal { background: #f0f0f0; font-weight: 500; }';
            html += '.footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; font-size: 12px; color: #888; }';
            html += '</style></head><body>';
            
            html += '<h1>Orcamento Estrutural Estimado</h1>';
            html += `<p><strong>Data:</strong> ${date} | <strong>Desenvolvido por:</strong> Eng.Civil Pedro Leite de O. Santos</p>`;
            
            html += '<h2>Quantitativos</h2>';
            html += '<table>';
            html += '<tr><th>Item</th><th class="text-right">Quantidade</th><th class="text-right">Unidade</th></tr>';
            html += `<tr><td>Volume Total de Concreto</td><td class="text-right">${data.volumes.total.toFixed(2)}</td><td class="text-right">m3</td></tr>`;
            html += `<tr><td>Area de Forma</td><td class="text-right">${data.areas.forma.toFixed(2)}</td><td class="text-right">m2</td></tr>`;
            html += `<tr><td>Area de Laje (escoramento)</td><td class="text-right">${data.areas.lajes.toFixed(2)}</td><td class="text-right">m2</td></tr>`;
            html += `<tr><td>Aco ${data.acoMode === 'informar' ? 'Informado' : 'Estimado'}</td><td class="text-right">${data.acoTotal.toFixed(0)}</td><td class="text-right">kg</td></tr>`;
            
            // Protensão (se houver)
            if (data.protensao && data.protensao.numCabos > 0) {
                html += `<tr><td colspan="3" style="background:#e3f2fd; font-weight:500; color:#1565c0;">Protensao</td></tr>`;
                html += `<tr><td>  Cabos de Protensao</td><td class="text-right">${data.protensao.numCabos}</td><td class="text-right">un</td></tr>`;
                html += `<tr><td>  Comprimento Total (+7,5%)</td><td class="text-right">${data.protensao.comprimento.toFixed(2)}</td><td class="text-right">m</td></tr>`;
                html += `<tr><td>  Peso Total (engraxada)</td><td class="text-right">${data.protensao.peso.toFixed(2)}</td><td class="text-right">kg</td></tr>`;
            }
            
            html += '</table>';
            
            html += '<h2>Composicao de Custos</h2>';
            html += '<table>';
            html += '<tr><th>Servico</th><th class="text-right">Qtd</th><th class="text-right">Preco Unit.</th><th class="text-right">Total</th></tr>';
            html += `<tr><td>Concreto fck 30 MPa</td><td class="text-right">${data.volumes.total.toFixed(2)} m3</td><td class="text-right">R$ ${data.precos.precoConcreto.toFixed(2)}</td><td class="text-right">${formatCurrency(data.volumes.total * data.precos.precoConcreto)}</td></tr>`;
            html += `<tr><td>Bombeamento</td><td class="text-right">${data.volumes.total.toFixed(2)} m3</td><td class="text-right">R$ ${data.precos.precoBomba.toFixed(2)}</td><td class="text-right">${formatCurrency(data.volumes.total * data.precos.precoBomba)}</td></tr>`;
            html += `<tr class="subtotal"><td colspan="3">Subtotal Concreto</td><td class="text-right">${formatCurrency(data.totais.totalConcreto)}</td></tr>`;
            html += `<tr><td>Forma (material + MO)</td><td class="text-right">${data.areas.forma.toFixed(2)} m2</td><td class="text-right">R$ ${data.precos.precoForma.toFixed(2)}</td><td class="text-right">${formatCurrency(data.totais.totalForma)}</td></tr>`;
            html += `<tr><td>Aco CA-50/60 (material + MO)</td><td class="text-right">${data.acoTotal.toFixed(0)} kg</td><td class="text-right">R$ ${data.precos.precoAco.toFixed(2)}</td><td class="text-right">${formatCurrency(data.totais.totalAco)}</td></tr>`;
            const tipoEscora = data.escoraMode === 'madeira' ? 'Madeira' : 'Metalico';
            html += `<tr><td>Escoramento ${tipoEscora}</td><td class="text-right">${data.areas.lajes.toFixed(2)} m2</td><td class="text-right">R$ ${data.precoEscora.toFixed(2)}</td><td class="text-right">${formatCurrency(data.totais.totalEscora)}</td></tr>`;
            
            // Protensão (se houver)
            if (data.protensao && data.protensao.numCabos > 0) {
                html += `<tr><td colspan="4" style="background:#e3f2fd; font-weight:500; color:#1565c0;">Protensao</td></tr>`;
                html += `<tr><td>  Cordoalha CP190 engraxada (material)</td><td class="text-right">${data.protensao.peso.toFixed(2)} kg</td><td class="text-right">R$ ${data.protensao.precoMaterial.toFixed(2)}</td><td class="text-right">${formatCurrency(data.protensao.peso * data.protensao.precoMaterial)}</td></tr>`;
                html += `<tr><td>  Mao de Obra (aplicacao)</td><td class="text-right">${data.protensao.peso.toFixed(2)} kg</td><td class="text-right">R$ ${data.protensao.precoMO.toFixed(2)}</td><td class="text-right">${formatCurrency(data.protensao.peso * data.protensao.precoMO)}</td></tr>`;
                html += `<tr class="subtotal"><td colspan="3">Subtotal Protensao</td><td class="text-right">${formatCurrency(data.totais.totalProtensao)}</td></tr>`;
            }
            
            html += `<tr class="total"><td colspan="3">CUSTO TOTAL</td><td class="text-right">${formatCurrency(data.totais.totalDireto)}</td></tr>`;
            html += '</table>';
            
            html += '<h2>Taxas de Aco Utilizadas</h2>';
            html += '<table>';
            html += '<tr><th>Elemento</th><th class="text-right">Taxa</th></tr>';
            html += '<tr><td>Pilares</td><td class="text-right">110 kg/m3</td></tr>';
            html += '<tr><td>Vigas</td><td class="text-right">100 kg/m3</td></tr>';
            html += '<tr><td>Lajes</td><td class="text-right">70 kg/m3</td></tr>';
            html += '<tr><td>Fundacoes</td><td class="text-right">90 kg/m3</td></tr>';
            html += '</table>';
            
            html += '<div class="footer">';
            html += '<strong>Nota:</strong> Este e um orcamento estimado para fins de planejamento. ';
            html += 'A quantidade de aco e baseada em taxas tipicas e deve ser confirmada com o projeto de armacao. ';
            html += 'Consulte um profissional para orcamento definitivo.<br><br>';
            html += '<strong>ProCalculo Engenharia</strong> - Gerado automaticamente<br>';
            html += '<span style="font-size: 0.9em;">Desenvolvido por <strong>Eng.Civil Pedro Leite de O. Santos</strong></span>';
            html += '</div>';
            
            html += '</body></html>';
            
            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.onload = function() {
                printWindow.focus();
                setTimeout(() => printWindow.print(), 300);
            };
            
            showToast('PDF de custos gerado');
        }
        
        function exportCostExcel() {
            if (typeof XLSX === 'undefined') {
                showToast('Biblioteca de exportacao nao carregada', 'error');
                return;
            }
            
            const data = window._costData;
            if (!data) {
                showToast('Calcule os custos primeiro', 'error');
                return;
            }
            
            const wb = XLSX.utils.book_new();
            const date = new Date().toLocaleDateString('pt-BR');
            const tipoEscora = data.escoraMode === 'madeira' ? 'Madeira' : 'Metalico';
            
            // Construir dados base
            const wsData = [
                ['ORCAMENTO ESTRUTURAL ESTIMADO'],
                ['ProCalculo - ' + date],
                [''],
                [''],
                ['QUANTITATIVOS'],
                ['Item', 'Quantidade', 'Unidade'],
                ['Volume Total Concreto', Number(data.volumes.total.toFixed(2)), 'm3'],
                ['  Pilares', Number(data.volumes.pilares.toFixed(2)), 'm3'],
                ['  Vigas', Number(data.volumes.vigas.toFixed(2)), 'm3'],
                ['  Lajes', Number(data.volumes.lajes.toFixed(2)), 'm3'],
                ['  Fundacoes', Number(data.volumes.fundacoes.toFixed(2)), 'm3'],
                ['  Estacas', Number(data.volumes.estacas.toFixed(2)), 'm3'],
                ['Area de Forma', Number(data.areas.forma.toFixed(2)), 'm2'],
                ['Area de Laje (escoramento)', Number(data.areas.lajes.toFixed(2)), 'm2'],
                ['Aco ' + (data.acoMode === 'informar' ? 'Informado' : 'Estimado'), Number(data.acoTotal.toFixed(0)), 'kg'],
            ];
            
            // Adicionar protensão aos quantitativos (se houver)
            if (data.protensao && data.protensao.numCabos > 0) {
                wsData.push(['']);
                wsData.push(['PROTENSAO']);
                wsData.push(['Cabos de Protensao', data.protensao.numCabos, 'un']);
                wsData.push(['Comprimento Total (+7,5%)', Number(data.protensao.comprimento.toFixed(2)), 'm']);
                wsData.push(['Peso Total (engraxada)', Number(data.protensao.peso.toFixed(2)), 'kg']);
            }
            
            // Composição de custos
            wsData.push(['']);
            wsData.push(['']);
            wsData.push(['COMPOSICAO DE CUSTOS']);
            wsData.push(['Servico', 'Qtd', 'Un', 'Preco Unit.', 'Total']);
            wsData.push(['Concreto fck 30', data.volumes.total, 'm3', data.precos.precoConcreto, data.volumes.total * data.precos.precoConcreto]);
            wsData.push(['Bombeamento', data.volumes.total, 'm3', data.precos.precoBomba, data.volumes.total * data.precos.precoBomba]);
            wsData.push(['Forma', data.areas.forma, 'm2', data.precos.precoForma, data.totais.totalForma]);
            wsData.push(['Aco CA-50/60', data.acoTotal, 'kg', data.precos.precoAco, data.totais.totalAco]);
            wsData.push(['Escoramento ' + tipoEscora, data.areas.lajes, 'm2', data.precoEscora, data.totais.totalEscora]);
            
            // Adicionar protensão aos custos (se houver)
            if (data.protensao && data.protensao.numCabos > 0) {
                wsData.push(['']);
                wsData.push(['PROTENSAO']);
                wsData.push(['Cordoalha CP190 engraxada (material)', data.protensao.peso, 'kg', data.protensao.precoMaterial, data.protensao.peso * data.protensao.precoMaterial]);
                wsData.push(['Mao de Obra (aplicacao)', data.protensao.peso, 'kg', data.protensao.precoMO, data.protensao.peso * data.protensao.precoMO]);
                wsData.push(['', '', '', 'Subtotal Protensao:', data.totais.totalProtensao]);
            }
            
            wsData.push(['']);
            wsData.push(['', '', '', 'CUSTO TOTAL:', data.totais.totalDireto]);
            
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            ws['!cols'] = [{ wch: 40 }, { wch: 12 }, { wch: 8 }, { wch: 12 }, { wch: 15 }];
            XLSX.utils.book_append_sheet(wb, ws, 'Orcamento');
            
            // Aba de Informações/Créditos
            const infoData = [
                ['INFORMAÇÕES DO DOCUMENTO'],
                [''],
                ['Tipo:', 'Orçamento Estrutural Estimado'],
                ['Data de Geração:', new Date().toLocaleDateString('pt-BR') + ' ' + new Date().toLocaleTimeString('pt-BR')],
                [''],
                ['DESENVOLVEDOR'],
                ['Nome:', 'Eng.Civil Pedro Leite de O. Santos'],
                ['Empresa:', 'ProCalculo Engenharia'],
                [''],
                ['SOFTWARE'],
                ['Visualizador:', 'IFC 3D Viewer - ProCalculo'],
                ['Versão:', '2.0'],
                [''],
                ['OBSERVAÇÕES'],
                ['Este é um orçamento estimado para fins de planejamento.'],
                ['A quantidade de aço é baseada em taxas típicas e deve ser confirmada.'],
                ['Consulte um profissional para orçamento definitivo.']
            ];
            
            const wsInfo = XLSX.utils.aoa_to_sheet(infoData);
            wsInfo['!cols'] = [{ wch: 20 }, { wch: 50 }];
            XLSX.utils.book_append_sheet(wb, wsInfo, 'Informações');
            
            XLSX.writeFile(wb, 'Orcamento_Estrutural_' + new Date().toISOString().split('T')[0] + '.xlsx');
            showToast('Excel de custos exportado');
        }

        // Carregar estado do checklist ao iniciar
        loadChecklistState();
    </script>
    
    <!-- Rodapé com créditos -->
    <div id="footer-credits" style="
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #1a237e, #283593);
        color: white;
        text-align: center;
        padding: 6px 15px;
        font-size: 0.75rem;
        z-index: 999;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
    ">
        <span style="opacity: 0.9;">🏗️ Visualizador IFC 3D</span>
        <span style="margin: 0 8px;">|</span>
        <span style="font-weight: 600;">Desenvolvido por Eng.Civil Pedro Leite de O. Santos</span>
        <span style="margin: 0 8px;">|</span>
        <span style="opacity: 0.8;">ProCalculo Engenharia</span>
    </div>
</body>

</html>